2023-10-12 21:57:39:366 grammar LogManager.java:25 before: (LEXER_GRAMMAR Lex (RULES (RULE STRINGS (BLOCK (ALT 'String'))) (RULE INTS (BLOCK (ALT 'Int'))) (RULE FLOATS (BLOCK (ALT 'Float'))) (RULE BOOLS (BLOCK (ALT 'Bool'))) (RULE CHARACTERS (BLOCK (ALT 'Character'))) (RULE VAR (BLOCK (ALT 'var'))) (RULE NIL (BLOCK (ALT 'nil'))) (RULE TRUE (BLOCK (ALT 'true'))) (RULE FALSE (BLOCK (ALT 'false'))) (RULE PRINT (BLOCK (ALT 'print'))) (RULE IF (BLOCK (ALT 'if'))) (RULE ELSE (BLOCK (ALT 'else'))) (RULE WHILE (BLOCK (ALT 'while'))) (RULE LET (BLOCK (ALT 'let'))) (RULE FOR (BLOCK (ALT 'for'))) (RULE IN (BLOCK (ALT 'in'))) (RULE SWITCH (BLOCK (ALT 'switch'))) (RULE CASE (BLOCK (ALT 'case'))) (RULE DEFAULT (BLOCK (ALT 'default'))) (RULE GUARD (BLOCK (ALT 'guard'))) (RULE CONTINUE (BLOCK (ALT 'continue'))) (RULE RETURN (BLOCK (ALT 'return'))) (RULE BREAK (BLOCK (ALT 'break'))) (RULE APPEND (BLOCK (ALT 'append'))) (RULE REMOVELAST (BLOCK (ALT 'removeLast'))) (RULE REMOVE (BLOCK (ALT 'remove'))) (RULE AT (BLOCK (ALT 'at'))) (RULE ISEMPTY (BLOCK (ALT 'isEmpty'))) (RULE COUNT (BLOCK (ALT 'count'))) (RULE FUNC (BLOCK (ALT 'func'))) (RULE INOUT (BLOCK (ALT 'inout'))) (RULE STRUCT (BLOCK (ALT 'struct'))) (RULE NUMBER (BLOCK (ALT (+ (BLOCK (ALT [0-9]))) (? (BLOCK (ALT '.' (+ (BLOCK (ALT [0-9]))))))))) (RULE STRING (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["]))))) '"'))) (RULE ID (BLOCK (ALT (BLOCK (ALT [a-zA-Z_])) (* (BLOCK (ALT [a-zA-Z0-9_])))))) (RULE DIF (BLOCK (ALT '!='))) (RULE IG_IG (BLOCK (ALT '=='))) (RULE NOT (BLOCK (ALT '!'))) (RULE OR (BLOCK (ALT '||'))) (RULE AND (BLOCK (ALT '&&'))) (RULE IG (BLOCK (ALT '='))) (RULE IG_ADD (BLOCK (ALT '+='))) (RULE IG_SUB (BLOCK (ALT '-='))) (RULE MAY_IG (BLOCK (ALT '>='))) (RULE MEN_IG (BLOCK (ALT '<='))) (RULE MAYOR (BLOCK (ALT '>'))) (RULE MENOR (BLOCK (ALT '<'))) (RULE MUL (BLOCK (ALT '*'))) (RULE DIV (BLOCK (ALT '/'))) (RULE ADD (BLOCK (ALT '+'))) (RULE SUB (BLOCK (ALT '-'))) (RULE PERCENT (BLOCK (ALT '%'))) (RULE PARIZQ (BLOCK (ALT '('))) (RULE PARDER (BLOCK (ALT ')'))) (RULE LLAVEIZQ (BLOCK (ALT '{'))) (RULE LLAVEDER (BLOCK (ALT '}'))) (RULE DOUBLEPTS (BLOCK (ALT ':'))) (RULE QUESTION (BLOCK (ALT '?'))) (RULE POINT (BLOCK (ALT '.'))) (RULE COMA (BLOCK (ALT ','))) (RULE PTCOMA (BLOCK (ALT ';'))) (RULE CORCHETEIZQ (BLOCK (ALT '['))) (RULE CORCHETEDER (BLOCK (ALT ']'))) (RULE GUION_BAJO (BLOCK (ALT '_'))) (RULE AND_SIMPLE (BLOCK (ALT '&'))) (RULE WHITESPACE (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \\\r\n\t])))) skip))) (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '/*' (* (BLOCK (ALT .))) '*/') skip))) (RULE LINE_COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '//' (* (BLOCK (ALT (~ (SET [\r\n])))))) skip))) (RULE ESC_SEQ (RULEMODIFIERS fragment) (BLOCK (ALT '\\' (BLOCK (ALT '\\') (ALT '@') (ALT '[') (ALT ']') (ALT '.') (ALT '#') (ALT '+') (ALT '-') (ALT '!') (ALT ':') (ALT ' ')))))))
2023-10-12 21:57:39:382 grammar LogManager.java:25 after: (LEXER_GRAMMAR Lex (RULES (RULE STRINGS (BLOCK (ALT 'String'))) (RULE INTS (BLOCK (ALT 'Int'))) (RULE FLOATS (BLOCK (ALT 'Float'))) (RULE BOOLS (BLOCK (ALT 'Bool'))) (RULE CHARACTERS (BLOCK (ALT 'Character'))) (RULE VAR (BLOCK (ALT 'var'))) (RULE NIL (BLOCK (ALT 'nil'))) (RULE TRUE (BLOCK (ALT 'true'))) (RULE FALSE (BLOCK (ALT 'false'))) (RULE PRINT (BLOCK (ALT 'print'))) (RULE IF (BLOCK (ALT 'if'))) (RULE ELSE (BLOCK (ALT 'else'))) (RULE WHILE (BLOCK (ALT 'while'))) (RULE LET (BLOCK (ALT 'let'))) (RULE FOR (BLOCK (ALT 'for'))) (RULE IN (BLOCK (ALT 'in'))) (RULE SWITCH (BLOCK (ALT 'switch'))) (RULE CASE (BLOCK (ALT 'case'))) (RULE DEFAULT (BLOCK (ALT 'default'))) (RULE GUARD (BLOCK (ALT 'guard'))) (RULE CONTINUE (BLOCK (ALT 'continue'))) (RULE RETURN (BLOCK (ALT 'return'))) (RULE BREAK (BLOCK (ALT 'break'))) (RULE APPEND (BLOCK (ALT 'append'))) (RULE REMOVELAST (BLOCK (ALT 'removeLast'))) (RULE REMOVE (BLOCK (ALT 'remove'))) (RULE AT (BLOCK (ALT 'at'))) (RULE ISEMPTY (BLOCK (ALT 'isEmpty'))) (RULE COUNT (BLOCK (ALT 'count'))) (RULE FUNC (BLOCK (ALT 'func'))) (RULE INOUT (BLOCK (ALT 'inout'))) (RULE STRUCT (BLOCK (ALT 'struct'))) (RULE NUMBER (BLOCK (ALT (+ (BLOCK (ALT [0-9]))) (? (BLOCK (ALT '.' (+ (BLOCK (ALT [0-9]))))))))) (RULE STRING (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["]))))) '"'))) (RULE ID (BLOCK (ALT (BLOCK (ALT [a-zA-Z_])) (* (BLOCK (ALT [a-zA-Z0-9_])))))) (RULE DIF (BLOCK (ALT '!='))) (RULE IG_IG (BLOCK (ALT '=='))) (RULE NOT (BLOCK (ALT '!'))) (RULE OR (BLOCK (ALT '||'))) (RULE AND (BLOCK (ALT '&&'))) (RULE IG (BLOCK (ALT '='))) (RULE IG_ADD (BLOCK (ALT '+='))) (RULE IG_SUB (BLOCK (ALT '-='))) (RULE MAY_IG (BLOCK (ALT '>='))) (RULE MEN_IG (BLOCK (ALT '<='))) (RULE MAYOR (BLOCK (ALT '>'))) (RULE MENOR (BLOCK (ALT '<'))) (RULE MUL (BLOCK (ALT '*'))) (RULE DIV (BLOCK (ALT '/'))) (RULE ADD (BLOCK (ALT '+'))) (RULE SUB (BLOCK (ALT '-'))) (RULE PERCENT (BLOCK (ALT '%'))) (RULE PARIZQ (BLOCK (ALT '('))) (RULE PARDER (BLOCK (ALT ')'))) (RULE LLAVEIZQ (BLOCK (ALT '{'))) (RULE LLAVEDER (BLOCK (ALT '}'))) (RULE DOUBLEPTS (BLOCK (ALT ':'))) (RULE QUESTION (BLOCK (ALT '?'))) (RULE POINT (BLOCK (ALT '.'))) (RULE COMA (BLOCK (ALT ','))) (RULE PTCOMA (BLOCK (ALT ';'))) (RULE CORCHETEIZQ (BLOCK (ALT '['))) (RULE CORCHETEDER (BLOCK (ALT ']'))) (RULE GUION_BAJO (BLOCK (ALT '_'))) (RULE AND_SIMPLE (BLOCK (ALT '&'))) (RULE WHITESPACE (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \\\r\n\t])))) skip))) (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '/*' (* (BLOCK (ALT .))) '*/') skip))) (RULE LINE_COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '//' (* (BLOCK (ALT (~ (SET [\r\n])))))) skip))) (RULE ESC_SEQ (RULEMODIFIERS fragment) (BLOCK (ALT '\\' (SET '\\' '@' '[' ']' '.' '#' '+' '-' '!' ':' ' '))))))
2023-10-12 21:57:40:277 grammar LogManager.java:25 before: (COMBINED_GRAMMAR Grammar (OPTIONS (= tokenVocab Lex)) (@ header {
    import "Server/Interfaces"
    import "Server/Environment"
    import "Server/Expression"
    import "Server/Instruction"
    import "strings"
}) (RULES (RULE s (returns []interface{} code) (BLOCK (ALT block EOF {$code = $block.blk}))) (RULE block (returns []interface{} blk) (@ init {
$blk = []interface{}{}
    var listInt []IInstructionContext
  }) (BLOCK (ALT (+ (BLOCK (ALT (+= ins instruction)))) {
        listInt = localctx.(*BlockContext).GetIns()
        for _, e := range listInt {
            $blk = append($blk, e.GetInst())
            
        }
    }))) (RULE instruction (returns interfaces.Instruction inst) (BLOCK (ALT printstmt { $inst = $printstmt.prnt}) (ALT declarestmt {$inst = $declarestmt.dec}) (ALT constantstmt {$inst = $constantstmt.const}) (ALT assignationstmt {$inst = $assignationstmt.assign}) (ALT increaseanddecreasestmt {$inst = $increaseanddecreasestmt.increasedecrease}) (ALT ifstmt { $inst = $ifstmt.ift }) (ALT whilestmt {$inst = $whilestmt.while}) (ALT forstmt {$inst = $forstmt.for}) (ALT switchstmt {$inst = $switchstmt.switch}) (ALT guardstmt {$inst = $guardstmt.gua}) (ALT transferstmt {$inst = $transferstmt.tran}) (ALT declarevectorstmt {$inst = $declarevectorstmt.decvec}) (ALT appendstmt {$inst = $appendstmt.app}) (ALT removelaststmt {$inst = $removelaststmt.removl}) (ALT removestmt {$inst = $removestmt.remov}) (ALT assignationvecstmt {$inst = $assignationvecstmt.assignvec}) (ALT declarefuncstmt {$inst = $declarefuncstmt.decfunc}) (ALT accessfuncinstruction {$inst = $accessfuncinstruction.accessfuncin}) (ALT declarestructstmt {$inst = $declarestructstmt.decstruct }) (ALT assignationstructstmt {$inst = $assignationstructstmt.assignstruct}))) (RULE printstmt (returns interfaces.Instruction prnt) (BLOCK (ALT PRINT PARIZQ listParams PARDER (? (BLOCK (ALT PTCOMA))) { $prnt = instructions.NewPrint($PRINT.line, $PRINT.pos, $listParams.l)}))) (RULE declarestmt (returns interfaces.Instruction dec) (BLOCK (ALT VAR ID DOUBLEPTS type IG expr (? (BLOCK (ALT PTCOMA))) {$dec = instructions.NewTodeclare($VAR.line, $VAR.pos, $ID.text, $type.t, $expr.e, false)}) (ALT VAR ID IG expr (? (BLOCK (ALT PTCOMA))) {$dec = instructions.NewTodeclare($VAR.line, $VAR.pos, $ID.text, environment.NULL, $expr.e, false)}) (ALT VAR ID DOUBLEPTS type QUESTION (? (BLOCK (ALT PTCOMA))) {$dec = instructions.NewTodeclare($VAR.line, $VAR.pos, $ID.text, $type.t, nil, false)}))) (RULE constantstmt (returns interfaces.Instruction const) (BLOCK (ALT LET ID DOUBLEPTS type IG expr (? (BLOCK (ALT PTCOMA))) {$const = instructions.NewTodeclare($LET.line, $LET.pos, $ID.text, $type.t, $expr.e, true)}) (ALT LET ID IG expr (? (BLOCK (ALT PTCOMA))) {$const = instructions.NewTodeclare($LET.line, $LET.pos, $ID.text, environment.NULL, $expr.e, true)}))) (RULE ifstmt (returns interfaces.Instruction ift) (BLOCK (ALT IF expr LLAVEIZQ block LLAVEDER (* (BLOCK (ALT (+= e elseifstmt)))) elsestmt {
    elif  := []interface{}
    listelif = localctx.(*IfstmtContext).GetE()
    for _, a := range listelif {
            elif = append(elif, a.GetElif())
            
    }
    $ift = instructions.NewIf($IF.line, $IF.pos, $expr.e, $block.blk, elif, $elsestmt.blkelse); 
}))) (RULE elseifstmt (returns interfaces.Instruction elif) (BLOCK (ALT ELSE IF expr LLAVEIZQ block LLAVEDER {
    elif := []interface{}
    condelse := []interface{}
    $elif = instructions.NewIf($ELSE.line, $ELSE.pos, $expr.e, $block.blk, elif, $elsestmt.blkelse); 

}))) (RULE elsestmt (returns interfaces.Instruction blkelse) (BLOCK (ALT ELSE LLAVEIZQ block LLAVEDER {$blkelse = $block.blk}) (ALT {$blkelse = []interface{}}))) (RULE switchstmt (returns interfaces.Instruction switch) (BLOCK (ALT SWITCH expr LLAVEIZQ DEFAULT DOUBLEPTS block LLAVEDER { $switch = instructions.NewSwitch($SWITCH.line, $SWITCH.pos, $expr.e, nil,  nil, $block.blk);}) (ALT SWITCH expr LLAVEIZQ casestmt LLAVEDER {$switch = instructions.NewSwitch($SWITCH.line, $SWITCH.pos, $expr.e, nil, $casestmt.cas, nil);}))) (RULE casestmt (returns interfaces.Instruction cas) (BLOCK (ALT CASE expr DOUBLEPTS block blockcases { $cas = instructions.NewCase($CASE.line,$CASE.pos, $expr.e,$block.blk, $blockcases.blkcase)
                                }) (ALT CASE expr DOUBLEPTS (= sen block) DEFAULT DOUBLEPTS (= def block) { $cas = instructions.NewCase($CASE.line,$CASE.pos, $expr.e,$sen.blk, $def.blk)}))) (RULE blockcases (returns []interface{} blkcase) (@ init {
    $blkcase = []interface{}{}
    var listcases []ICasestmtContext
  }) (BLOCK (ALT (+ (BLOCK (ALT (+= casedef casestmt)))) {
        listcases = localctx.(*BlockcasesContext).GetCasedef()
        for _, a := range listcases {
            $blkcase = append($blkcase, a.GetCas())
      
        }
    }))) (RULE assignationstmt (returns interfaces.Instruction assign) (BLOCK (ALT ID IG expr (? (BLOCK (ALT PTCOMA))) {$assign = instructions.NewAssignation($ID.line, $ID.pos,  $ID.text, $expr.e)}))) (RULE assignationstructstmt (returns interfaces.Instruction assignstruct) (BLOCK (ALT ID POINT (= second ID) IG expr (? (BLOCK (ALT PTCOMA))) {$assignstruct = instructions.NewAssignationStruct($ID.line, $ID.pos, $ID.text, $second.text, $expr.e)}))) (RULE whilestmt (returns interfaces.Instruction while) (BLOCK (ALT WHILE expr LLAVEIZQ block LLAVEDER {$while = instructions.NewWhile($WHILE.line, $WHILE.pos,  $expr.e, $block.blk)}))) (RULE forstmt (returns interfaces.Instruction for) (BLOCK (ALT FOR ID IN expr LLAVEIZQ block LLAVEDER {$for = instructions.NewFor($FOR.line, $FOR.pos, $ID.text, $expr.e, nil, $block.blk)}) (ALT FOR ID IN (= first expr) POINT POINT (= second expr) LLAVEIZQ block LLAVEDER {$for = instructions.NewFor($FOR.line, $FOR.pos, $ID.text, $first.e, $second.e, $block.blk)}))) (RULE guardstmt (returns interfaces.Instruction gua) (BLOCK (ALT GUARD expr ELSE LLAVEIZQ block (= r (BLOCK (ALT CONTINUE) (ALT RETURN) (ALT BREAK))) LLAVEDER {$gua = instructions.NewGuard($GUARD.line, $GUARD.pos, $expr.e, $block.blk, $r.text)}))) (RULE transferstmt (returns interfaces.Instruction tran) (BLOCK (ALT RETURN (? (BLOCK (ALT PTCOMA))) {$tran = instructions.NewReturnIn($RETURN.line, $RETURN.pos, nil)}) (ALT RETURN expr (? (BLOCK (ALT PTCOMA))) {$tran = instructions.NewReturnIn($RETURN.line, $RETURN.pos, $expr.e)}) (ALT CONTINUE (? (BLOCK (ALT PTCOMA))) {$tran = instructions.NewContinue($CONTINUE.line, $CONTINUE.pos)}) (ALT BREAK (? (BLOCK (ALT PTCOMA))) {$tran = instructions.NewBreak($BREAK.line, $BREAK.pos)}))) (RULE declarevectorstmt (returns interfaces.Instruction decvec) (BLOCK (ALT VAR ID DOUBLEPTS CORCHETEIZQ type CORCHETEDER IG CORCHETEIZQ listParams CORCHETEDER (? (BLOCK (ALT PTCOMA))) {$decvec = instructions.NewToDeclareVector($VAR.line, $VAR.pos, $ID.text, $type.t, $listParams.l, "")}) (ALT VAR ID DOUBLEPTS CORCHETEIZQ type CORCHETEDER IG CORCHETEIZQ CORCHETEDER (? (BLOCK (ALT PTCOMA))) {$decvec = instructions.NewToDeclareVector($VAR.line, $VAR.pos, $ID.text, $type.t, nil, "")}) (ALT VAR ID IG CORCHETEIZQ type CORCHETEDER PARIZQ PARDER (? (BLOCK (ALT PTCOMA)))) (ALT VAR (= F ID) DOUBLEPTS CORCHETEIZQ type CORCHETEDER IG (= S ID) (? (BLOCK (ALT PTCOMA))) {$decvec = instructions.NewToDeclareVector($VAR.line, $VAR.pos, $F.text, $type.t, nil, $S.text)}))) (RULE accessfuncinstruction (returns interfaces.Instruction accessfuncin) (BLOCK (ALT ID PARIZQ listParams PARDER PTCOMA {$accessfuncin = instructions.NewCallFunction($ID.line, $ID.pos, $ID.text, $listParams.l, 1)}))) (RULE appendstmt (returns interfaces.Instruction app) (BLOCK (ALT ID POINT APPEND PARIZQ expr PARDER (? (BLOCK (ALT PTCOMA))) {$app = instructions.NewAppend($ID.line, $ID.pos, $ID.text, $expr.e)}))) (RULE removelaststmt (returns interfaces.Instruction removl) (BLOCK (ALT ID POINT REMOVELAST PARIZQ PARDER (? (BLOCK (ALT PTCOMA))) {$removl = instructions.NewRemoveLast($ID.line, $ID.pos, $ID.text)}))) (RULE removestmt (returns interfaces.Instruction remov) (BLOCK (ALT ID POINT REMOVE PARIZQ AT DOUBLEPTS expr PARDER (? (BLOCK (ALT PTCOMA))) {$remov = instructions.NewRemove($ID.line, $ID.pos, $ID.text, $expr.e)}))) (RULE emptvecstmt (returns interfaces.Expression emptyvec) (BLOCK (ALT ID POINT ISEMPTY {$emptyvec = expressions.NewEmptyVector($ID.line, $ID.pos, $ID.text)}))) (RULE countvecstmt (returns interfaces.Expression count) (BLOCK (ALT ID POINT COUNT {$count = expressions.NewCount($ID.line, $ID.pos, $ID.text)}))) (RULE accessvecstmt (returns interfaces.Expression accessvec) (BLOCK (ALT ID CORCHETEIZQ expr CORCHETEDER {$accessvec = expressions.NewAccessVector($ID.line, $ID.pos, $ID.text, $expr.e)}))) (RULE assignationvecstmt (returns interfaces.Instruction assignvec) (BLOCK (ALT ID CORCHETEIZQ (= expprim expr) CORCHETEDER IG (= expsegundo expr) (? (BLOCK (ALT PTCOMA))) {$assignvec = instructions.NewAssignationVector($ID.line, $ID.pos, $ID.text, $expprim.e, $expsegundo.e)}))) (RULE declarematrixstmt (returns interfaces.Instruction decmatrix) (BLOCK (ALT VAR ID PARIZQ DOUBLEPTS type PARDER IG (? (BLOCK (ALT PTCOMA)))))) (RULE declarefuncstmt (returns interfaces.Instruction decfunc) (BLOCK (ALT FUNC ID PARIZQ listParamsFunc PARDER SUB MAYOR type LLAVEIZQ block LLAVEDER {$decfunc = instructions.NewToDeclareFunction($ID.line, $ID.pos, $ID.text, $listParamsFunc.lf, $type.t, $block.blk, 1)}) (ALT FUNC ID PARIZQ listParamsFunc PARDER LLAVEIZQ block LLAVEDER {
    
    $decfunc = instructions.NewToDeclareFunction($ID.line, $ID.pos, $ID.text, $listParamsFunc.lf, environment.NULL, $block.blk, 2);}) (ALT FUNC ID PARIZQ PARDER SUB MAYOR type LLAVEIZQ block LLAVEDER {$decfunc = instructions.NewToDeclareFunction($ID.line, $ID.pos, $ID.text, nil, $type.t, $block.blk, 3)}) (ALT FUNC ID PARIZQ PARDER LLAVEIZQ block LLAVEDER {
    if($block.blk!=nil){ 
         $decfunc = instructions.NewToDeclareFunction($ID.line, $ID.pos, $ID.text, nil, environment.NULL, $block.blk, 4)
    }
}))) (RULE listParamsFunc (returns []interface{} lf) (BLOCK (ALT (= listf listParamsFunc) COMA parameterfuncstmt {
                    
                                var arrf []interface{}
                                arrf = append($listf.lf, $parameterfuncstmt.parameterfunc)
                                $lf = arrf
                            }) (ALT parameterfuncstmt {
    
            $lf = []interface{}{}
            $lf = append($lf, $parameterfuncstmt.parameterfunc)
        }))) (RULE parameterfuncstmt (returns interfaces.Expression parameterfunc) (BLOCK (ALT (= exte (BLOCK (ALT ID) (ALT GUION_BAJO))) ID DOUBLEPTS type {$parameterfunc = expressions.NewParameters($exte.line, $exte.pos, $type.t, $exte.text,  $ID.text, 1)}) (ALT (= exte (BLOCK (ALT ID) (ALT GUION_BAJO))) ID DOUBLEPTS (? (BLOCK (ALT INOUT))) CORCHETEIZQ type CORCHETEDER {$parameterfunc = expressions.NewParameters($exte.line, $exte.pos, $type.t, $exte.text,  $ID.text,2);}) (ALT ID DOUBLEPTS type {$parameterfunc = expressions.NewParameters($ID.line, $ID.pos, $type.t, "_",  $ID.text, 1)}))) (RULE declarestructstmt (returns interfaces.Instruction decstruct) (BLOCK (ALT STRUCT ID LLAVEIZQ listStruct LLAVEDER { $decstruct = instructions.NewToDeclareStruct($STRUCT.line, $STRUCT.pos, $ID.text, $listStruct.l) }))) (RULE listStruct (returns []interface{} l) (BLOCK (ALT (= list listStruct) VAR ID DOUBLEPTS type {
                            var arr []interface{}
                            newParams := environment.NewStructType($ID.text, $type.t)
                            arr = append($list.l, newParams)
                            $l = arr

}) (ALT VAR ID DOUBLEPTS type {
                        var arr []interface{}
                        newParams := environment.NewStructType($ID.text, $type.t)
                        arr = append(arr, newParams)
                        $l = arr
}) (ALT { $l = []interface{}{} }))) (RULE expr (returns interfaces.Expression e) (BLOCK (ALT (= left expr) (= op (BLOCK (ALT MUL) (ALT DIV))) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (BLOCK (ALT ADD) (ALT SUB) (ALT PERCENT))) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (BLOCK (ALT MAY_IG) (ALT MAYOR))) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (BLOCK (ALT MEN_IG) (ALT MENOR))) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (BLOCK (ALT IG_IG) (ALT DIF))) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op AND) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op OR) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= op NOT) (= left expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $left.e) }) (ALT (= op SUB) (= left expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e,  $op.text, nil)}) (ALT PARIZQ expr PARDER { $e = $expr.e }) (ALT NUMBER {   
        
        if (strings.Contains($NUMBER.text,".")){
           
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,$NUMBER.text,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.INTEGER)
        }
    }) (ALT STRING {
        str := $STRING.text
        $e = expressions.NewPrimitive($STRING.line, $STRING.pos, str[1:len(str)-1],environment.STRING)
    }) (ALT TRUE { $e = expressions.NewPrimitive($TRUE.line, $TRUE.pos, true, environment.BOOLEAN) }) (ALT FALSE { $e = expressions.NewPrimitive($FALSE.line, $FALSE.pos, false, environment.BOOLEAN) }) (ALT NIL { $e = expressions.NewPrimitive($NIL.line, $NIL.pos, nil, environment.NULL) }) (ALT accessstmt {$e = $accessstmt.access}) (ALT emptvecstmt {$e = $emptvecstmt.emptyvec}) (ALT countvecstmt {$e = $countvecstmt.count}) (ALT accessvecstmt {$e = $accessvecstmt.accessvec}) (ALT intfunctionstmt {$e = $intfunctionstmt.intfunc}) (ALT floatfunctionstmt {$e = $floatfunctionstmt.floatfunc}) (ALT stringfunctionstmt {$e = $stringfunctionstmt.stringfunc}) (ALT accessfuncstmt {$e = $accessfuncstmt.funcexp}) (ALT ID (BLOCK (ALT LLAVEIZQ) (ALT PARIZQ)) listStructExp (BLOCK (ALT LLAVEDER) (ALT PARDER)) { $e = expressions.NewStructExp($ID.line, $ID.pos, $ID.text, $listStructExp.l ) }) (ALT accessstructstmt {$e = $accessstructstmt.accessstruct}))) (RULE accessstructstmt (returns interfaces.Expression accessstruct) (BLOCK (ALT (= list ID) POINT ID { $accessstruct = expressions.NewAccessStruct($list.line, $list.pos, $list.text, $ID.text, "nil")  }) (ALT (= list ID) POINT ID POINT (= sec ID) { $accessstruct = expressions.NewAccessStruct($list.line, $list.pos, $list.text, $ID.text, $sec.text)  }))) (RULE accessfuncstmt (returns interfaces.Expression funcexp) (BLOCK (ALT ID PARIZQ listParams PARDER {$funcexp = expressions.NewAccessFunction($ID.line, $ID.pos, $ID.text, $listParams.l, 1)}) (ALT ID PARIZQ PARDER))) (RULE intfunctionstmt (returns interfaces.Expression intfunc) (BLOCK (ALT INTS PARIZQ expr PARDER {$intfunc = expressions.NewFunctionInt($INTS.line, $INTS.pos, $expr.e)}))) (RULE floatfunctionstmt (returns interfaces.Expression floatfunc) (BLOCK (ALT FLOATS PARIZQ expr PARDER {$floatfunc = expressions.NewFunctionFloat($FLOATS.line, $FLOATS.pos, $expr.e)}))) (RULE stringfunctionstmt (returns interfaces.Expression stringfunc) (BLOCK (ALT STRINGS PARIZQ expr PARDER {$stringfunc = expressions.NewFunctionString($STRINGS.line, $STRINGS.pos, $expr.e)}))) (RULE accessstmt (returns interfaces.Expression access) (BLOCK (ALT (= op ID) {$access = expressions.NewAccess($op.line, $op.pos, $op.text)}))) (RULE increaseanddecreasestmt (returns interfaces.Instruction increasedecrease) (BLOCK (ALT ID IG_ADD expr (? (BLOCK (ALT PTCOMA))) {$increasedecrease = instructions.NewIncreaseDecrease($ID.line, $ID.pos, $ID.text, $IG_ADD.text, $expr.e)}) (ALT ID IG_SUB expr (? (BLOCK (ALT PTCOMA))) {$increasedecrease = instructions.NewIncreaseDecrease($ID.line, $ID.pos, $ID.text, $IG_SUB.text, $expr.e)}))) (RULE type (returns environment.TipoExpresion t) (BLOCK (ALT STRINGS {$t = environment.STRING}) (ALT INTS {$t = environment.INTEGER}) (ALT FLOATS {$t = environment.FLOAT}) (ALT BOOLS {$t = environment.BOOLEAN }) (ALT CHARACTERS {$t = environment.CHARACTER}) (ALT ID { $t = environment.STRUCT  }))) (RULE listParams (returns []interface{} l) (BLOCK (ALT (= list listParams) COMA (? (BLOCK (ALT AND_SIMPLE) (ALT ID DOUBLEPTS))) expr {
                                var arr []interface{}
                                arr = append($list.l, $expr.e)
                                $l = arr
                            }) (ALT (? (BLOCK (ALT AND_SIMPLE) (ALT ID DOUBLEPTS))) expr {
            $l = []interface{}{}
            $l = append($l, $expr.e)
        }))) (RULE listStructExp (returns []interface{} l) (BLOCK (ALT (= list listStructExp) (? (BLOCK (ALT COMA))) ID DOUBLEPTS expr {
                                            var arr []interface{}
                                            StrExp := environment.NewStructContent($ID.text, $expr.e)
                                            arr = append($list.l, StrExp)
                                            $l = arr
                                        }) (ALT ID DOUBLEPTS expr {
                    var arr []interface{}
                    StrExp := environment.NewStructContent($ID.text, $expr.e)
                    arr = append(arr, StrExp)
                    $l = arr
                }) (ALT {
        $l = []interface{}{}
    })))))
2023-10-12 21:57:40:283 grammar LogManager.java:25 after: (COMBINED_GRAMMAR Grammar (OPTIONS (= tokenVocab Lex)) (@ header {
    import "Server/Interfaces"
    import "Server/Environment"
    import "Server/Expression"
    import "Server/Instruction"
    import "strings"
}) (RULES (RULE s (returns []interface{} code) (BLOCK (ALT block EOF {$code = $block.blk}))) (RULE block (returns []interface{} blk) (@ init {
$blk = []interface{}{}
    var listInt []IInstructionContext
  }) (BLOCK (ALT (+ (BLOCK (ALT (+= ins instruction)))) {
        listInt = localctx.(*BlockContext).GetIns()
        for _, e := range listInt {
            $blk = append($blk, e.GetInst())
            
        }
    }))) (RULE instruction (returns interfaces.Instruction inst) (BLOCK (ALT printstmt { $inst = $printstmt.prnt}) (ALT declarestmt {$inst = $declarestmt.dec}) (ALT constantstmt {$inst = $constantstmt.const}) (ALT assignationstmt {$inst = $assignationstmt.assign}) (ALT increaseanddecreasestmt {$inst = $increaseanddecreasestmt.increasedecrease}) (ALT ifstmt { $inst = $ifstmt.ift }) (ALT whilestmt {$inst = $whilestmt.while}) (ALT forstmt {$inst = $forstmt.for}) (ALT switchstmt {$inst = $switchstmt.switch}) (ALT guardstmt {$inst = $guardstmt.gua}) (ALT transferstmt {$inst = $transferstmt.tran}) (ALT declarevectorstmt {$inst = $declarevectorstmt.decvec}) (ALT appendstmt {$inst = $appendstmt.app}) (ALT removelaststmt {$inst = $removelaststmt.removl}) (ALT removestmt {$inst = $removestmt.remov}) (ALT assignationvecstmt {$inst = $assignationvecstmt.assignvec}) (ALT declarefuncstmt {$inst = $declarefuncstmt.decfunc}) (ALT accessfuncinstruction {$inst = $accessfuncinstruction.accessfuncin}) (ALT declarestructstmt {$inst = $declarestructstmt.decstruct }) (ALT assignationstructstmt {$inst = $assignationstructstmt.assignstruct}))) (RULE printstmt (returns interfaces.Instruction prnt) (BLOCK (ALT PRINT PARIZQ listParams PARDER (? (BLOCK (ALT PTCOMA))) { $prnt = instructions.NewPrint($PRINT.line, $PRINT.pos, $listParams.l)}))) (RULE declarestmt (returns interfaces.Instruction dec) (BLOCK (ALT VAR ID DOUBLEPTS type IG expr (? (BLOCK (ALT PTCOMA))) {$dec = instructions.NewTodeclare($VAR.line, $VAR.pos, $ID.text, $type.t, $expr.e, false)}) (ALT VAR ID IG expr (? (BLOCK (ALT PTCOMA))) {$dec = instructions.NewTodeclare($VAR.line, $VAR.pos, $ID.text, environment.NULL, $expr.e, false)}) (ALT VAR ID DOUBLEPTS type QUESTION (? (BLOCK (ALT PTCOMA))) {$dec = instructions.NewTodeclare($VAR.line, $VAR.pos, $ID.text, $type.t, nil, false)}))) (RULE constantstmt (returns interfaces.Instruction const) (BLOCK (ALT LET ID DOUBLEPTS type IG expr (? (BLOCK (ALT PTCOMA))) {$const = instructions.NewTodeclare($LET.line, $LET.pos, $ID.text, $type.t, $expr.e, true)}) (ALT LET ID IG expr (? (BLOCK (ALT PTCOMA))) {$const = instructions.NewTodeclare($LET.line, $LET.pos, $ID.text, environment.NULL, $expr.e, true)}))) (RULE ifstmt (returns interfaces.Instruction ift) (BLOCK (ALT IF expr LLAVEIZQ block LLAVEDER (* (BLOCK (ALT (+= e elseifstmt)))) elsestmt {
    elif  := []interface{}
    listelif = localctx.(*IfstmtContext).GetE()
    for _, a := range listelif {
            elif = append(elif, a.GetElif())
            
    }
    $ift = instructions.NewIf($IF.line, $IF.pos, $expr.e, $block.blk, elif, $elsestmt.blkelse); 
}))) (RULE elseifstmt (returns interfaces.Instruction elif) (BLOCK (ALT ELSE IF expr LLAVEIZQ block LLAVEDER {
    elif := []interface{}
    condelse := []interface{}
    $elif = instructions.NewIf($ELSE.line, $ELSE.pos, $expr.e, $block.blk, elif, $elsestmt.blkelse); 

}))) (RULE elsestmt (returns interfaces.Instruction blkelse) (BLOCK (ALT ELSE LLAVEIZQ block LLAVEDER {$blkelse = $block.blk}) (ALT {$blkelse = []interface{}}))) (RULE switchstmt (returns interfaces.Instruction switch) (BLOCK (ALT SWITCH expr LLAVEIZQ DEFAULT DOUBLEPTS block LLAVEDER { $switch = instructions.NewSwitch($SWITCH.line, $SWITCH.pos, $expr.e, nil,  nil, $block.blk);}) (ALT SWITCH expr LLAVEIZQ casestmt LLAVEDER {$switch = instructions.NewSwitch($SWITCH.line, $SWITCH.pos, $expr.e, nil, $casestmt.cas, nil);}))) (RULE casestmt (returns interfaces.Instruction cas) (BLOCK (ALT CASE expr DOUBLEPTS block blockcases { $cas = instructions.NewCase($CASE.line,$CASE.pos, $expr.e,$block.blk, $blockcases.blkcase)
                                }) (ALT CASE expr DOUBLEPTS (= sen block) DEFAULT DOUBLEPTS (= def block) { $cas = instructions.NewCase($CASE.line,$CASE.pos, $expr.e,$sen.blk, $def.blk)}))) (RULE blockcases (returns []interface{} blkcase) (@ init {
    $blkcase = []interface{}{}
    var listcases []ICasestmtContext
  }) (BLOCK (ALT (+ (BLOCK (ALT (+= casedef casestmt)))) {
        listcases = localctx.(*BlockcasesContext).GetCasedef()
        for _, a := range listcases {
            $blkcase = append($blkcase, a.GetCas())
      
        }
    }))) (RULE assignationstmt (returns interfaces.Instruction assign) (BLOCK (ALT ID IG expr (? (BLOCK (ALT PTCOMA))) {$assign = instructions.NewAssignation($ID.line, $ID.pos,  $ID.text, $expr.e)}))) (RULE assignationstructstmt (returns interfaces.Instruction assignstruct) (BLOCK (ALT ID POINT (= second ID) IG expr (? (BLOCK (ALT PTCOMA))) {$assignstruct = instructions.NewAssignationStruct($ID.line, $ID.pos, $ID.text, $second.text, $expr.e)}))) (RULE whilestmt (returns interfaces.Instruction while) (BLOCK (ALT WHILE expr LLAVEIZQ block LLAVEDER {$while = instructions.NewWhile($WHILE.line, $WHILE.pos,  $expr.e, $block.blk)}))) (RULE forstmt (returns interfaces.Instruction for) (BLOCK (ALT FOR ID IN expr LLAVEIZQ block LLAVEDER {$for = instructions.NewFor($FOR.line, $FOR.pos, $ID.text, $expr.e, nil, $block.blk)}) (ALT FOR ID IN (= first expr) POINT POINT (= second expr) LLAVEIZQ block LLAVEDER {$for = instructions.NewFor($FOR.line, $FOR.pos, $ID.text, $first.e, $second.e, $block.blk)}))) (RULE guardstmt (returns interfaces.Instruction gua) (BLOCK (ALT GUARD expr ELSE LLAVEIZQ block (= r (SET CONTINUE RETURN BREAK)) LLAVEDER {$gua = instructions.NewGuard($GUARD.line, $GUARD.pos, $expr.e, $block.blk, $r.text)}))) (RULE transferstmt (returns interfaces.Instruction tran) (BLOCK (ALT RETURN (? (BLOCK (ALT PTCOMA))) {$tran = instructions.NewReturnIn($RETURN.line, $RETURN.pos, nil)}) (ALT RETURN expr (? (BLOCK (ALT PTCOMA))) {$tran = instructions.NewReturnIn($RETURN.line, $RETURN.pos, $expr.e)}) (ALT CONTINUE (? (BLOCK (ALT PTCOMA))) {$tran = instructions.NewContinue($CONTINUE.line, $CONTINUE.pos)}) (ALT BREAK (? (BLOCK (ALT PTCOMA))) {$tran = instructions.NewBreak($BREAK.line, $BREAK.pos)}))) (RULE declarevectorstmt (returns interfaces.Instruction decvec) (BLOCK (ALT VAR ID DOUBLEPTS CORCHETEIZQ type CORCHETEDER IG CORCHETEIZQ listParams CORCHETEDER (? (BLOCK (ALT PTCOMA))) {$decvec = instructions.NewToDeclareVector($VAR.line, $VAR.pos, $ID.text, $type.t, $listParams.l, "")}) (ALT VAR ID DOUBLEPTS CORCHETEIZQ type CORCHETEDER IG CORCHETEIZQ CORCHETEDER (? (BLOCK (ALT PTCOMA))) {$decvec = instructions.NewToDeclareVector($VAR.line, $VAR.pos, $ID.text, $type.t, nil, "")}) (ALT VAR ID IG CORCHETEIZQ type CORCHETEDER PARIZQ PARDER (? (BLOCK (ALT PTCOMA)))) (ALT VAR (= F ID) DOUBLEPTS CORCHETEIZQ type CORCHETEDER IG (= S ID) (? (BLOCK (ALT PTCOMA))) {$decvec = instructions.NewToDeclareVector($VAR.line, $VAR.pos, $F.text, $type.t, nil, $S.text)}))) (RULE accessfuncinstruction (returns interfaces.Instruction accessfuncin) (BLOCK (ALT ID PARIZQ listParams PARDER PTCOMA {$accessfuncin = instructions.NewCallFunction($ID.line, $ID.pos, $ID.text, $listParams.l, 1)}))) (RULE appendstmt (returns interfaces.Instruction app) (BLOCK (ALT ID POINT APPEND PARIZQ expr PARDER (? (BLOCK (ALT PTCOMA))) {$app = instructions.NewAppend($ID.line, $ID.pos, $ID.text, $expr.e)}))) (RULE removelaststmt (returns interfaces.Instruction removl) (BLOCK (ALT ID POINT REMOVELAST PARIZQ PARDER (? (BLOCK (ALT PTCOMA))) {$removl = instructions.NewRemoveLast($ID.line, $ID.pos, $ID.text)}))) (RULE removestmt (returns interfaces.Instruction remov) (BLOCK (ALT ID POINT REMOVE PARIZQ AT DOUBLEPTS expr PARDER (? (BLOCK (ALT PTCOMA))) {$remov = instructions.NewRemove($ID.line, $ID.pos, $ID.text, $expr.e)}))) (RULE emptvecstmt (returns interfaces.Expression emptyvec) (BLOCK (ALT ID POINT ISEMPTY {$emptyvec = expressions.NewEmptyVector($ID.line, $ID.pos, $ID.text)}))) (RULE countvecstmt (returns interfaces.Expression count) (BLOCK (ALT ID POINT COUNT {$count = expressions.NewCount($ID.line, $ID.pos, $ID.text)}))) (RULE accessvecstmt (returns interfaces.Expression accessvec) (BLOCK (ALT ID CORCHETEIZQ expr CORCHETEDER {$accessvec = expressions.NewAccessVector($ID.line, $ID.pos, $ID.text, $expr.e)}))) (RULE assignationvecstmt (returns interfaces.Instruction assignvec) (BLOCK (ALT ID CORCHETEIZQ (= expprim expr) CORCHETEDER IG (= expsegundo expr) (? (BLOCK (ALT PTCOMA))) {$assignvec = instructions.NewAssignationVector($ID.line, $ID.pos, $ID.text, $expprim.e, $expsegundo.e)}))) (RULE declarematrixstmt (returns interfaces.Instruction decmatrix) (BLOCK (ALT VAR ID PARIZQ DOUBLEPTS type PARDER IG (? (BLOCK (ALT PTCOMA)))))) (RULE declarefuncstmt (returns interfaces.Instruction decfunc) (BLOCK (ALT FUNC ID PARIZQ listParamsFunc PARDER SUB MAYOR type LLAVEIZQ block LLAVEDER {$decfunc = instructions.NewToDeclareFunction($ID.line, $ID.pos, $ID.text, $listParamsFunc.lf, $type.t, $block.blk, 1)}) (ALT FUNC ID PARIZQ listParamsFunc PARDER LLAVEIZQ block LLAVEDER {
    
    $decfunc = instructions.NewToDeclareFunction($ID.line, $ID.pos, $ID.text, $listParamsFunc.lf, environment.NULL, $block.blk, 2);}) (ALT FUNC ID PARIZQ PARDER SUB MAYOR type LLAVEIZQ block LLAVEDER {$decfunc = instructions.NewToDeclareFunction($ID.line, $ID.pos, $ID.text, nil, $type.t, $block.blk, 3)}) (ALT FUNC ID PARIZQ PARDER LLAVEIZQ block LLAVEDER {
    if($block.blk!=nil){ 
         $decfunc = instructions.NewToDeclareFunction($ID.line, $ID.pos, $ID.text, nil, environment.NULL, $block.blk, 4)
    }
}))) (RULE listParamsFunc (returns []interface{} lf) (BLOCK (ALT (= listf listParamsFunc) COMA parameterfuncstmt {
                    
                                var arrf []interface{}
                                arrf = append($listf.lf, $parameterfuncstmt.parameterfunc)
                                $lf = arrf
                            }) (ALT parameterfuncstmt {
    
            $lf = []interface{}{}
            $lf = append($lf, $parameterfuncstmt.parameterfunc)
        }))) (RULE parameterfuncstmt (returns interfaces.Expression parameterfunc) (BLOCK (ALT (= exte (SET ID GUION_BAJO)) ID DOUBLEPTS type {$parameterfunc = expressions.NewParameters($exte.line, $exte.pos, $type.t, $exte.text,  $ID.text, 1)}) (ALT (= exte (SET ID GUION_BAJO)) ID DOUBLEPTS (? (BLOCK (ALT INOUT))) CORCHETEIZQ type CORCHETEDER {$parameterfunc = expressions.NewParameters($exte.line, $exte.pos, $type.t, $exte.text,  $ID.text,2);}) (ALT ID DOUBLEPTS type {$parameterfunc = expressions.NewParameters($ID.line, $ID.pos, $type.t, "_",  $ID.text, 1)}))) (RULE declarestructstmt (returns interfaces.Instruction decstruct) (BLOCK (ALT STRUCT ID LLAVEIZQ listStruct LLAVEDER { $decstruct = instructions.NewToDeclareStruct($STRUCT.line, $STRUCT.pos, $ID.text, $listStruct.l) }))) (RULE listStruct (returns []interface{} l) (BLOCK (ALT (= list listStruct) VAR ID DOUBLEPTS type {
                            var arr []interface{}
                            newParams := environment.NewStructType($ID.text, $type.t)
                            arr = append($list.l, newParams)
                            $l = arr

}) (ALT VAR ID DOUBLEPTS type {
                        var arr []interface{}
                        newParams := environment.NewStructType($ID.text, $type.t)
                        arr = append(arr, newParams)
                        $l = arr
}) (ALT { $l = []interface{}{} }))) (RULE expr (returns interfaces.Expression e) (BLOCK (ALT (= left expr) (= op (SET MUL DIV)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET ADD SUB PERCENT)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET MAY_IG MAYOR)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET MEN_IG MENOR)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET IG_IG DIF)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op AND) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op OR) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= op NOT) (= left expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $left.e) }) (ALT (= op SUB) (= left expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e,  $op.text, nil)}) (ALT PARIZQ expr PARDER { $e = $expr.e }) (ALT NUMBER {   
        
        if (strings.Contains($NUMBER.text,".")){
           
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,$NUMBER.text,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.INTEGER)
        }
    }) (ALT STRING {
        str := $STRING.text
        $e = expressions.NewPrimitive($STRING.line, $STRING.pos, str[1:len(str)-1],environment.STRING)
    }) (ALT TRUE { $e = expressions.NewPrimitive($TRUE.line, $TRUE.pos, true, environment.BOOLEAN) }) (ALT FALSE { $e = expressions.NewPrimitive($FALSE.line, $FALSE.pos, false, environment.BOOLEAN) }) (ALT NIL { $e = expressions.NewPrimitive($NIL.line, $NIL.pos, nil, environment.NULL) }) (ALT accessstmt {$e = $accessstmt.access}) (ALT emptvecstmt {$e = $emptvecstmt.emptyvec}) (ALT countvecstmt {$e = $countvecstmt.count}) (ALT accessvecstmt {$e = $accessvecstmt.accessvec}) (ALT intfunctionstmt {$e = $intfunctionstmt.intfunc}) (ALT floatfunctionstmt {$e = $floatfunctionstmt.floatfunc}) (ALT stringfunctionstmt {$e = $stringfunctionstmt.stringfunc}) (ALT accessfuncstmt {$e = $accessfuncstmt.funcexp}) (ALT ID (SET LLAVEIZQ PARIZQ) listStructExp (SET LLAVEDER PARDER) { $e = expressions.NewStructExp($ID.line, $ID.pos, $ID.text, $listStructExp.l ) }) (ALT accessstructstmt {$e = $accessstructstmt.accessstruct}))) (RULE accessstructstmt (returns interfaces.Expression accessstruct) (BLOCK (ALT (= list ID) POINT ID { $accessstruct = expressions.NewAccessStruct($list.line, $list.pos, $list.text, $ID.text, "nil")  }) (ALT (= list ID) POINT ID POINT (= sec ID) { $accessstruct = expressions.NewAccessStruct($list.line, $list.pos, $list.text, $ID.text, $sec.text)  }))) (RULE accessfuncstmt (returns interfaces.Expression funcexp) (BLOCK (ALT ID PARIZQ listParams PARDER {$funcexp = expressions.NewAccessFunction($ID.line, $ID.pos, $ID.text, $listParams.l, 1)}) (ALT ID PARIZQ PARDER))) (RULE intfunctionstmt (returns interfaces.Expression intfunc) (BLOCK (ALT INTS PARIZQ expr PARDER {$intfunc = expressions.NewFunctionInt($INTS.line, $INTS.pos, $expr.e)}))) (RULE floatfunctionstmt (returns interfaces.Expression floatfunc) (BLOCK (ALT FLOATS PARIZQ expr PARDER {$floatfunc = expressions.NewFunctionFloat($FLOATS.line, $FLOATS.pos, $expr.e)}))) (RULE stringfunctionstmt (returns interfaces.Expression stringfunc) (BLOCK (ALT STRINGS PARIZQ expr PARDER {$stringfunc = expressions.NewFunctionString($STRINGS.line, $STRINGS.pos, $expr.e)}))) (RULE accessstmt (returns interfaces.Expression access) (BLOCK (ALT (= op ID) {$access = expressions.NewAccess($op.line, $op.pos, $op.text)}))) (RULE increaseanddecreasestmt (returns interfaces.Instruction increasedecrease) (BLOCK (ALT ID IG_ADD expr (? (BLOCK (ALT PTCOMA))) {$increasedecrease = instructions.NewIncreaseDecrease($ID.line, $ID.pos, $ID.text, $IG_ADD.text, $expr.e)}) (ALT ID IG_SUB expr (? (BLOCK (ALT PTCOMA))) {$increasedecrease = instructions.NewIncreaseDecrease($ID.line, $ID.pos, $ID.text, $IG_SUB.text, $expr.e)}))) (RULE type (returns environment.TipoExpresion t) (BLOCK (ALT STRINGS {$t = environment.STRING}) (ALT INTS {$t = environment.INTEGER}) (ALT FLOATS {$t = environment.FLOAT}) (ALT BOOLS {$t = environment.BOOLEAN }) (ALT CHARACTERS {$t = environment.CHARACTER}) (ALT ID { $t = environment.STRUCT  }))) (RULE listParams (returns []interface{} l) (BLOCK (ALT (= list listParams) COMA (? (BLOCK (ALT AND_SIMPLE) (ALT ID DOUBLEPTS))) expr {
                                var arr []interface{}
                                arr = append($list.l, $expr.e)
                                $l = arr
                            }) (ALT (? (BLOCK (ALT AND_SIMPLE) (ALT ID DOUBLEPTS))) expr {
            $l = []interface{}{}
            $l = append($l, $expr.e)
        }))) (RULE listStructExp (returns []interface{} l) (BLOCK (ALT (= list listStructExp) (? (BLOCK (ALT COMA))) ID DOUBLEPTS expr {
                                            var arr []interface{}
                                            StrExp := environment.NewStructContent($ID.text, $expr.e)
                                            arr = append($list.l, StrExp)
                                            $l = arr
                                        }) (ALT ID DOUBLEPTS expr {
                    var arr []interface{}
                    StrExp := environment.NewStructContent($ID.text, $expr.e)
                    arr = append(arr, StrExp)
                    $l = arr
                }) (ALT {
        $l = []interface{}{}
    })))))
2023-10-12 21:57:40:291 grammar LogManager.java:25 after extract implicit lexer =(COMBINED_GRAMMAR Grammar (OPTIONS (= tokenVocab Lex)) (@ header {
    import "Server/Interfaces"
    import "Server/Environment"
    import "Server/Expression"
    import "Server/Instruction"
    import "strings"
}) (RULES (RULE s (returns []interface{} code) (BLOCK (ALT block EOF {$code = $block.blk}))) (RULE block (returns []interface{} blk) (@ init {
$blk = []interface{}{}
    var listInt []IInstructionContext
  }) (BLOCK (ALT (+ (BLOCK (ALT (+= ins instruction)))) {
        listInt = localctx.(*BlockContext).GetIns()
        for _, e := range listInt {
            $blk = append($blk, e.GetInst())
            
        }
    }))) (RULE instruction (returns interfaces.Instruction inst) (BLOCK (ALT printstmt { $inst = $printstmt.prnt}) (ALT declarestmt {$inst = $declarestmt.dec}) (ALT constantstmt {$inst = $constantstmt.const}) (ALT assignationstmt {$inst = $assignationstmt.assign}) (ALT increaseanddecreasestmt {$inst = $increaseanddecreasestmt.increasedecrease}) (ALT ifstmt { $inst = $ifstmt.ift }) (ALT whilestmt {$inst = $whilestmt.while}) (ALT forstmt {$inst = $forstmt.for}) (ALT switchstmt {$inst = $switchstmt.switch}) (ALT guardstmt {$inst = $guardstmt.gua}) (ALT transferstmt {$inst = $transferstmt.tran}) (ALT declarevectorstmt {$inst = $declarevectorstmt.decvec}) (ALT appendstmt {$inst = $appendstmt.app}) (ALT removelaststmt {$inst = $removelaststmt.removl}) (ALT removestmt {$inst = $removestmt.remov}) (ALT assignationvecstmt {$inst = $assignationvecstmt.assignvec}) (ALT declarefuncstmt {$inst = $declarefuncstmt.decfunc}) (ALT accessfuncinstruction {$inst = $accessfuncinstruction.accessfuncin}) (ALT declarestructstmt {$inst = $declarestructstmt.decstruct }) (ALT assignationstructstmt {$inst = $assignationstructstmt.assignstruct}))) (RULE printstmt (returns interfaces.Instruction prnt) (BLOCK (ALT PRINT PARIZQ listParams PARDER (? (BLOCK (ALT PTCOMA))) { $prnt = instructions.NewPrint($PRINT.line, $PRINT.pos, $listParams.l)}))) (RULE declarestmt (returns interfaces.Instruction dec) (BLOCK (ALT VAR ID DOUBLEPTS type IG expr (? (BLOCK (ALT PTCOMA))) {$dec = instructions.NewTodeclare($VAR.line, $VAR.pos, $ID.text, $type.t, $expr.e, false)}) (ALT VAR ID IG expr (? (BLOCK (ALT PTCOMA))) {$dec = instructions.NewTodeclare($VAR.line, $VAR.pos, $ID.text, environment.NULL, $expr.e, false)}) (ALT VAR ID DOUBLEPTS type QUESTION (? (BLOCK (ALT PTCOMA))) {$dec = instructions.NewTodeclare($VAR.line, $VAR.pos, $ID.text, $type.t, nil, false)}))) (RULE constantstmt (returns interfaces.Instruction const) (BLOCK (ALT LET ID DOUBLEPTS type IG expr (? (BLOCK (ALT PTCOMA))) {$const = instructions.NewTodeclare($LET.line, $LET.pos, $ID.text, $type.t, $expr.e, true)}) (ALT LET ID IG expr (? (BLOCK (ALT PTCOMA))) {$const = instructions.NewTodeclare($LET.line, $LET.pos, $ID.text, environment.NULL, $expr.e, true)}))) (RULE ifstmt (returns interfaces.Instruction ift) (BLOCK (ALT IF expr LLAVEIZQ block LLAVEDER (* (BLOCK (ALT (+= e elseifstmt)))) elsestmt {
    elif  := []interface{}
    listelif = localctx.(*IfstmtContext).GetE()
    for _, a := range listelif {
            elif = append(elif, a.GetElif())
            
    }
    $ift = instructions.NewIf($IF.line, $IF.pos, $expr.e, $block.blk, elif, $elsestmt.blkelse); 
}))) (RULE elseifstmt (returns interfaces.Instruction elif) (BLOCK (ALT ELSE IF expr LLAVEIZQ block LLAVEDER {
    elif := []interface{}
    condelse := []interface{}
    $elif = instructions.NewIf($ELSE.line, $ELSE.pos, $expr.e, $block.blk, elif, $elsestmt.blkelse); 

}))) (RULE elsestmt (returns interfaces.Instruction blkelse) (BLOCK (ALT ELSE LLAVEIZQ block LLAVEDER {$blkelse = $block.blk}) (ALT {$blkelse = []interface{}}))) (RULE switchstmt (returns interfaces.Instruction switch) (BLOCK (ALT SWITCH expr LLAVEIZQ DEFAULT DOUBLEPTS block LLAVEDER { $switch = instructions.NewSwitch($SWITCH.line, $SWITCH.pos, $expr.e, nil,  nil, $block.blk);}) (ALT SWITCH expr LLAVEIZQ casestmt LLAVEDER {$switch = instructions.NewSwitch($SWITCH.line, $SWITCH.pos, $expr.e, nil, $casestmt.cas, nil);}))) (RULE casestmt (returns interfaces.Instruction cas) (BLOCK (ALT CASE expr DOUBLEPTS block blockcases { $cas = instructions.NewCase($CASE.line,$CASE.pos, $expr.e,$block.blk, $blockcases.blkcase)
                                }) (ALT CASE expr DOUBLEPTS (= sen block) DEFAULT DOUBLEPTS (= def block) { $cas = instructions.NewCase($CASE.line,$CASE.pos, $expr.e,$sen.blk, $def.blk)}))) (RULE blockcases (returns []interface{} blkcase) (@ init {
    $blkcase = []interface{}{}
    var listcases []ICasestmtContext
  }) (BLOCK (ALT (+ (BLOCK (ALT (+= casedef casestmt)))) {
        listcases = localctx.(*BlockcasesContext).GetCasedef()
        for _, a := range listcases {
            $blkcase = append($blkcase, a.GetCas())
      
        }
    }))) (RULE assignationstmt (returns interfaces.Instruction assign) (BLOCK (ALT ID IG expr (? (BLOCK (ALT PTCOMA))) {$assign = instructions.NewAssignation($ID.line, $ID.pos,  $ID.text, $expr.e)}))) (RULE assignationstructstmt (returns interfaces.Instruction assignstruct) (BLOCK (ALT ID POINT (= second ID) IG expr (? (BLOCK (ALT PTCOMA))) {$assignstruct = instructions.NewAssignationStruct($ID.line, $ID.pos, $ID.text, $second.text, $expr.e)}))) (RULE whilestmt (returns interfaces.Instruction while) (BLOCK (ALT WHILE expr LLAVEIZQ block LLAVEDER {$while = instructions.NewWhile($WHILE.line, $WHILE.pos,  $expr.e, $block.blk)}))) (RULE forstmt (returns interfaces.Instruction for) (BLOCK (ALT FOR ID IN expr LLAVEIZQ block LLAVEDER {$for = instructions.NewFor($FOR.line, $FOR.pos, $ID.text, $expr.e, nil, $block.blk)}) (ALT FOR ID IN (= first expr) POINT POINT (= second expr) LLAVEIZQ block LLAVEDER {$for = instructions.NewFor($FOR.line, $FOR.pos, $ID.text, $first.e, $second.e, $block.blk)}))) (RULE guardstmt (returns interfaces.Instruction gua) (BLOCK (ALT GUARD expr ELSE LLAVEIZQ block (= r (SET CONTINUE RETURN BREAK)) LLAVEDER {$gua = instructions.NewGuard($GUARD.line, $GUARD.pos, $expr.e, $block.blk, $r.text)}))) (RULE transferstmt (returns interfaces.Instruction tran) (BLOCK (ALT RETURN (? (BLOCK (ALT PTCOMA))) {$tran = instructions.NewReturnIn($RETURN.line, $RETURN.pos, nil)}) (ALT RETURN expr (? (BLOCK (ALT PTCOMA))) {$tran = instructions.NewReturnIn($RETURN.line, $RETURN.pos, $expr.e)}) (ALT CONTINUE (? (BLOCK (ALT PTCOMA))) {$tran = instructions.NewContinue($CONTINUE.line, $CONTINUE.pos)}) (ALT BREAK (? (BLOCK (ALT PTCOMA))) {$tran = instructions.NewBreak($BREAK.line, $BREAK.pos)}))) (RULE declarevectorstmt (returns interfaces.Instruction decvec) (BLOCK (ALT VAR ID DOUBLEPTS CORCHETEIZQ type CORCHETEDER IG CORCHETEIZQ listParams CORCHETEDER (? (BLOCK (ALT PTCOMA))) {$decvec = instructions.NewToDeclareVector($VAR.line, $VAR.pos, $ID.text, $type.t, $listParams.l, "")}) (ALT VAR ID DOUBLEPTS CORCHETEIZQ type CORCHETEDER IG CORCHETEIZQ CORCHETEDER (? (BLOCK (ALT PTCOMA))) {$decvec = instructions.NewToDeclareVector($VAR.line, $VAR.pos, $ID.text, $type.t, nil, "")}) (ALT VAR ID IG CORCHETEIZQ type CORCHETEDER PARIZQ PARDER (? (BLOCK (ALT PTCOMA)))) (ALT VAR (= F ID) DOUBLEPTS CORCHETEIZQ type CORCHETEDER IG (= S ID) (? (BLOCK (ALT PTCOMA))) {$decvec = instructions.NewToDeclareVector($VAR.line, $VAR.pos, $F.text, $type.t, nil, $S.text)}))) (RULE accessfuncinstruction (returns interfaces.Instruction accessfuncin) (BLOCK (ALT ID PARIZQ listParams PARDER PTCOMA {$accessfuncin = instructions.NewCallFunction($ID.line, $ID.pos, $ID.text, $listParams.l, 1)}))) (RULE appendstmt (returns interfaces.Instruction app) (BLOCK (ALT ID POINT APPEND PARIZQ expr PARDER (? (BLOCK (ALT PTCOMA))) {$app = instructions.NewAppend($ID.line, $ID.pos, $ID.text, $expr.e)}))) (RULE removelaststmt (returns interfaces.Instruction removl) (BLOCK (ALT ID POINT REMOVELAST PARIZQ PARDER (? (BLOCK (ALT PTCOMA))) {$removl = instructions.NewRemoveLast($ID.line, $ID.pos, $ID.text)}))) (RULE removestmt (returns interfaces.Instruction remov) (BLOCK (ALT ID POINT REMOVE PARIZQ AT DOUBLEPTS expr PARDER (? (BLOCK (ALT PTCOMA))) {$remov = instructions.NewRemove($ID.line, $ID.pos, $ID.text, $expr.e)}))) (RULE emptvecstmt (returns interfaces.Expression emptyvec) (BLOCK (ALT ID POINT ISEMPTY {$emptyvec = expressions.NewEmptyVector($ID.line, $ID.pos, $ID.text)}))) (RULE countvecstmt (returns interfaces.Expression count) (BLOCK (ALT ID POINT COUNT {$count = expressions.NewCount($ID.line, $ID.pos, $ID.text)}))) (RULE accessvecstmt (returns interfaces.Expression accessvec) (BLOCK (ALT ID CORCHETEIZQ expr CORCHETEDER {$accessvec = expressions.NewAccessVector($ID.line, $ID.pos, $ID.text, $expr.e)}))) (RULE assignationvecstmt (returns interfaces.Instruction assignvec) (BLOCK (ALT ID CORCHETEIZQ (= expprim expr) CORCHETEDER IG (= expsegundo expr) (? (BLOCK (ALT PTCOMA))) {$assignvec = instructions.NewAssignationVector($ID.line, $ID.pos, $ID.text, $expprim.e, $expsegundo.e)}))) (RULE declarematrixstmt (returns interfaces.Instruction decmatrix) (BLOCK (ALT VAR ID PARIZQ DOUBLEPTS type PARDER IG (? (BLOCK (ALT PTCOMA)))))) (RULE declarefuncstmt (returns interfaces.Instruction decfunc) (BLOCK (ALT FUNC ID PARIZQ listParamsFunc PARDER SUB MAYOR type LLAVEIZQ block LLAVEDER {$decfunc = instructions.NewToDeclareFunction($ID.line, $ID.pos, $ID.text, $listParamsFunc.lf, $type.t, $block.blk, 1)}) (ALT FUNC ID PARIZQ listParamsFunc PARDER LLAVEIZQ block LLAVEDER {
    
    $decfunc = instructions.NewToDeclareFunction($ID.line, $ID.pos, $ID.text, $listParamsFunc.lf, environment.NULL, $block.blk, 2);}) (ALT FUNC ID PARIZQ PARDER SUB MAYOR type LLAVEIZQ block LLAVEDER {$decfunc = instructions.NewToDeclareFunction($ID.line, $ID.pos, $ID.text, nil, $type.t, $block.blk, 3)}) (ALT FUNC ID PARIZQ PARDER LLAVEIZQ block LLAVEDER {
    if($block.blk!=nil){ 
         $decfunc = instructions.NewToDeclareFunction($ID.line, $ID.pos, $ID.text, nil, environment.NULL, $block.blk, 4)
    }
}))) (RULE listParamsFunc (returns []interface{} lf) (BLOCK (ALT (= listf listParamsFunc) COMA parameterfuncstmt {
                    
                                var arrf []interface{}
                                arrf = append($listf.lf, $parameterfuncstmt.parameterfunc)
                                $lf = arrf
                            }) (ALT parameterfuncstmt {
    
            $lf = []interface{}{}
            $lf = append($lf, $parameterfuncstmt.parameterfunc)
        }))) (RULE parameterfuncstmt (returns interfaces.Expression parameterfunc) (BLOCK (ALT (= exte (SET ID GUION_BAJO)) ID DOUBLEPTS type {$parameterfunc = expressions.NewParameters($exte.line, $exte.pos, $type.t, $exte.text,  $ID.text, 1)}) (ALT (= exte (SET ID GUION_BAJO)) ID DOUBLEPTS (? (BLOCK (ALT INOUT))) CORCHETEIZQ type CORCHETEDER {$parameterfunc = expressions.NewParameters($exte.line, $exte.pos, $type.t, $exte.text,  $ID.text,2);}) (ALT ID DOUBLEPTS type {$parameterfunc = expressions.NewParameters($ID.line, $ID.pos, $type.t, "_",  $ID.text, 1)}))) (RULE declarestructstmt (returns interfaces.Instruction decstruct) (BLOCK (ALT STRUCT ID LLAVEIZQ listStruct LLAVEDER { $decstruct = instructions.NewToDeclareStruct($STRUCT.line, $STRUCT.pos, $ID.text, $listStruct.l) }))) (RULE listStruct (returns []interface{} l) (BLOCK (ALT (= list listStruct) VAR ID DOUBLEPTS type {
                            var arr []interface{}
                            newParams := environment.NewStructType($ID.text, $type.t)
                            arr = append($list.l, newParams)
                            $l = arr

}) (ALT VAR ID DOUBLEPTS type {
                        var arr []interface{}
                        newParams := environment.NewStructType($ID.text, $type.t)
                        arr = append(arr, newParams)
                        $l = arr
}) (ALT { $l = []interface{}{} }))) (RULE expr (returns interfaces.Expression e) (BLOCK (ALT (= left expr) (= op (SET MUL DIV)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET ADD SUB PERCENT)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET MAY_IG MAYOR)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET MEN_IG MENOR)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET IG_IG DIF)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op AND) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op OR) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= op NOT) (= left expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $left.e) }) (ALT (= op SUB) (= left expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e,  $op.text, nil)}) (ALT PARIZQ expr PARDER { $e = $expr.e }) (ALT NUMBER {   
        
        if (strings.Contains($NUMBER.text,".")){
           
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,$NUMBER.text,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.INTEGER)
        }
    }) (ALT STRING {
        str := $STRING.text
        $e = expressions.NewPrimitive($STRING.line, $STRING.pos, str[1:len(str)-1],environment.STRING)
    }) (ALT TRUE { $e = expressions.NewPrimitive($TRUE.line, $TRUE.pos, true, environment.BOOLEAN) }) (ALT FALSE { $e = expressions.NewPrimitive($FALSE.line, $FALSE.pos, false, environment.BOOLEAN) }) (ALT NIL { $e = expressions.NewPrimitive($NIL.line, $NIL.pos, nil, environment.NULL) }) (ALT accessstmt {$e = $accessstmt.access}) (ALT emptvecstmt {$e = $emptvecstmt.emptyvec}) (ALT countvecstmt {$e = $countvecstmt.count}) (ALT accessvecstmt {$e = $accessvecstmt.accessvec}) (ALT intfunctionstmt {$e = $intfunctionstmt.intfunc}) (ALT floatfunctionstmt {$e = $floatfunctionstmt.floatfunc}) (ALT stringfunctionstmt {$e = $stringfunctionstmt.stringfunc}) (ALT accessfuncstmt {$e = $accessfuncstmt.funcexp}) (ALT ID (SET LLAVEIZQ PARIZQ) listStructExp (SET LLAVEDER PARDER) { $e = expressions.NewStructExp($ID.line, $ID.pos, $ID.text, $listStructExp.l ) }) (ALT accessstructstmt {$e = $accessstructstmt.accessstruct}))) (RULE accessstructstmt (returns interfaces.Expression accessstruct) (BLOCK (ALT (= list ID) POINT ID { $accessstruct = expressions.NewAccessStruct($list.line, $list.pos, $list.text, $ID.text, "nil")  }) (ALT (= list ID) POINT ID POINT (= sec ID) { $accessstruct = expressions.NewAccessStruct($list.line, $list.pos, $list.text, $ID.text, $sec.text)  }))) (RULE accessfuncstmt (returns interfaces.Expression funcexp) (BLOCK (ALT ID PARIZQ listParams PARDER {$funcexp = expressions.NewAccessFunction($ID.line, $ID.pos, $ID.text, $listParams.l, 1)}) (ALT ID PARIZQ PARDER))) (RULE intfunctionstmt (returns interfaces.Expression intfunc) (BLOCK (ALT INTS PARIZQ expr PARDER {$intfunc = expressions.NewFunctionInt($INTS.line, $INTS.pos, $expr.e)}))) (RULE floatfunctionstmt (returns interfaces.Expression floatfunc) (BLOCK (ALT FLOATS PARIZQ expr PARDER {$floatfunc = expressions.NewFunctionFloat($FLOATS.line, $FLOATS.pos, $expr.e)}))) (RULE stringfunctionstmt (returns interfaces.Expression stringfunc) (BLOCK (ALT STRINGS PARIZQ expr PARDER {$stringfunc = expressions.NewFunctionString($STRINGS.line, $STRINGS.pos, $expr.e)}))) (RULE accessstmt (returns interfaces.Expression access) (BLOCK (ALT (= op ID) {$access = expressions.NewAccess($op.line, $op.pos, $op.text)}))) (RULE increaseanddecreasestmt (returns interfaces.Instruction increasedecrease) (BLOCK (ALT ID IG_ADD expr (? (BLOCK (ALT PTCOMA))) {$increasedecrease = instructions.NewIncreaseDecrease($ID.line, $ID.pos, $ID.text, $IG_ADD.text, $expr.e)}) (ALT ID IG_SUB expr (? (BLOCK (ALT PTCOMA))) {$increasedecrease = instructions.NewIncreaseDecrease($ID.line, $ID.pos, $ID.text, $IG_SUB.text, $expr.e)}))) (RULE type (returns environment.TipoExpresion t) (BLOCK (ALT STRINGS {$t = environment.STRING}) (ALT INTS {$t = environment.INTEGER}) (ALT FLOATS {$t = environment.FLOAT}) (ALT BOOLS {$t = environment.BOOLEAN }) (ALT CHARACTERS {$t = environment.CHARACTER}) (ALT ID { $t = environment.STRUCT  }))) (RULE listParams (returns []interface{} l) (BLOCK (ALT (= list listParams) COMA (? (BLOCK (ALT AND_SIMPLE) (ALT ID DOUBLEPTS))) expr {
                                var arr []interface{}
                                arr = append($list.l, $expr.e)
                                $l = arr
                            }) (ALT (? (BLOCK (ALT AND_SIMPLE) (ALT ID DOUBLEPTS))) expr {
            $l = []interface{}{}
            $l = append($l, $expr.e)
        }))) (RULE listStructExp (returns []interface{} l) (BLOCK (ALT (= list listStructExp) (? (BLOCK (ALT COMA))) ID DOUBLEPTS expr {
                                            var arr []interface{}
                                            StrExp := environment.NewStructContent($ID.text, $expr.e)
                                            arr = append($list.l, StrExp)
                                            $l = arr
                                        }) (ALT ID DOUBLEPTS expr {
                    var arr []interface{}
                    StrExp := environment.NewStructContent($ID.text, $expr.e)
                    arr = append(arr, StrExp)
                    $l = arr
                }) (ALT {
        $l = []interface{}{}
    })))))
2023-10-12 21:57:40:291 grammar LogManager.java:25 lexer =(LEXER_GRAMMAR GrammarLexer OPTIONS (@ header {
    import "Server/Interfaces"
    import "Server/Environment"
    import "Server/Expression"
    import "Server/Instruction"
    import "strings"
}) RULES)
2023-10-12 21:57:40:328 left-recursion LogManager.java:25 listParamsFunc returns [[]interface{} lf]
    :   ( {} parameterfuncstmt<tokenIndex=1168> {
    
            $lf = []interface{}{}
            $lf = append($lf, $parameterfuncstmt.parameterfunc)
        } 
        )
        (
          {p.Precpred(p.GetParserRuleContext(), 2)}?<p=2> COMA<tokenIndex=1160> parameterfuncstmt<tokenIndex=1162>  {
                              
                                          var arrf []interface{}
                                          arrf = append($listf.lf, $parameterfuncstmt.parameterfunc)
                                          $lf = arrf
                                      }
        )*
    ;
2023-10-12 21:57:40:336 grammar LogManager.java:25 added: (RULE listParamsFunc (returns []interface{} lf) (BLOCK (ALT (BLOCK (ALT {} (parameterfuncstmt (ELEMENT_OPTIONS (= tokenIndex 1168))) {
    
            $lf = []interface{}{}
            $lf = append($lf, $parameterfuncstmt.parameterfunc)
        })) (* (BLOCK (ALT ({p.Precpred(p.GetParserRuleContext(), 2)}? (ELEMENT_OPTIONS (= p 2))) (COMA (ELEMENT_OPTIONS (= tokenIndex 1160))) (parameterfuncstmt (ELEMENT_OPTIONS (= tokenIndex 1162))) {
                              
                                          var arrf []interface{}
                                          arrf = append($listf.lf, $parameterfuncstmt.parameterfunc)
                                          $lf = arrf
                                      }))))))
2023-10-12 21:57:40:336 left-recursion LogManager.java:25 listStruct returns [[]interface{} l]
    :   ( {} VAR<tokenIndex=1284> ID<tokenIndex=1286> DOUBLEPTS<tokenIndex=1288> type<tokenIndex=1290> {
                        var arr []interface{}
                        newParams := environment.NewStructType($ID.text, $type.t)
                        arr = append(arr, newParams)
                        $l = arr
} 
        | { $l = []interface{}{} } 
        )
        (
          {p.Precpred(p.GetParserRuleContext(), 3)}?<p=3> VAR<tokenIndex=1272> ID<tokenIndex=1274> DOUBLEPTS<tokenIndex=1276> type<tokenIndex=1278> {
                                      var arr []interface{}
                                      newParams := environment.NewStructType($ID.text, $type.t)
                                      arr = append($list.l, newParams)
                                      $l = arr

          }
        )*
    ;
2023-10-12 21:57:40:336 grammar LogManager.java:25 added: (RULE listStruct (returns []interface{} l) (BLOCK (ALT (BLOCK (ALT {} (VAR (ELEMENT_OPTIONS (= tokenIndex 1284))) (ID (ELEMENT_OPTIONS (= tokenIndex 1286))) (DOUBLEPTS (ELEMENT_OPTIONS (= tokenIndex 1288))) (type (ELEMENT_OPTIONS (= tokenIndex 1290))) {
                        var arr []interface{}
                        newParams := environment.NewStructType($ID.text, $type.t)
                        arr = append(arr, newParams)
                        $l = arr
}) (ALT { $l = []interface{}{} })) (* (BLOCK (ALT ({p.Precpred(p.GetParserRuleContext(), 3)}? (ELEMENT_OPTIONS (= p 3))) (VAR (ELEMENT_OPTIONS (= tokenIndex 1272))) (ID (ELEMENT_OPTIONS (= tokenIndex 1274))) (DOUBLEPTS (ELEMENT_OPTIONS (= tokenIndex 1276))) (type (ELEMENT_OPTIONS (= tokenIndex 1278))) {
                                      var arr []interface{}
                                      newParams := environment.NewStructType($ID.text, $type.t)
                                      arr = append($list.l, newParams)
                                      $l = arr

          }))))))
2023-10-12 21:57:40:336 left-recursion LogManager.java:25 expr returns [interfaces.Expression e]
    :   ( {} op= NOT<tokenIndex=1447>   left=expr<tokenIndex=1451,p=18> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $left.e) } 
        | op = SUB<tokenIndex=1461>  left=expr<tokenIndex=1465,p=17> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e,  $op.text, nil)} 
        | PARIZQ<tokenIndex=1471> expr<tokenIndex=1473> PARDER<tokenIndex=1475> { $e = $expr.e } 
        | NUMBER<tokenIndex=1481>                             
    {   
        
        if (strings.Contains($NUMBER.text,".")){
           
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,$NUMBER.text,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.INTEGER)
        }
    } 
        | STRING<tokenIndex=1487>
    {
        str := $STRING.text
        $e = expressions.NewPrimitive($STRING.line, $STRING.pos, str[1:len(str)-1],environment.STRING)
    } 
        | TRUE<tokenIndex=1493> { $e = expressions.NewPrimitive($TRUE.line, $TRUE.pos, true, environment.BOOLEAN) } 
        | FALSE<tokenIndex=1499> { $e = expressions.NewPrimitive($FALSE.line, $FALSE.pos, false, environment.BOOLEAN) } 
        | NIL<tokenIndex=1505> { $e = expressions.NewPrimitive($NIL.line, $NIL.pos, nil, environment.NULL) } 
        | accessstmt<tokenIndex=1511> {$e = $accessstmt.access} 
        | emptvecstmt<tokenIndex=1517> {$e = $emptvecstmt.emptyvec} 
        | countvecstmt<tokenIndex=1523> {$e = $countvecstmt.count} 
        | accessvecstmt<tokenIndex=1529> {$e = $accessvecstmt.accessvec} 
        | intfunctionstmt<tokenIndex=1535> {$e = $intfunctionstmt.intfunc} 
        | floatfunctionstmt<tokenIndex=1541> {$e = $floatfunctionstmt.floatfunc} 
        | stringfunctionstmt<tokenIndex=1547> {$e = $stringfunctionstmt.stringfunc} 
        | accessfuncstmt<tokenIndex=1553>     {$e = $accessfuncstmt.funcexp} 
        | ID<tokenIndex=1559> (LLAVEIZQ<tokenIndex=1562>|PARIZQ<tokenIndex=1564>) listStructExp<tokenIndex=1567> (LLAVEDER<tokenIndex=1570>|PARDER<tokenIndex=1572>) { $e = expressions.NewStructExp($ID.line, $ID.pos, $ID.text, $listStructExp.l ) } 
        | accessstructstmt<tokenIndex=1579> {$e = $accessstructstmt.accessstruct} 
        )
        (
          {p.Precpred(p.GetParserRuleContext(), 25)}?<p=25> op=(MUL<tokenIndex=1317>|DIV<tokenIndex=1319>) right=expr<tokenIndex=1324,p=26> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 24)}?<p=24> op=(ADD<tokenIndex=1337>|SUB<tokenIndex=1339>|PERCENT<tokenIndex=1341>) right=expr<tokenIndex=1346,p=25> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 23)}?<p=23> op=(MAY_IG<tokenIndex=1359>|MAYOR<tokenIndex=1361>) right=expr<tokenIndex=1366,p=24> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 22)}?<p=22> op=(MEN_IG<tokenIndex=1379>|MENOR<tokenIndex=1381>) right=expr<tokenIndex=1386,p=23> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 21)}?<p=21> op=(IG_IG<tokenIndex=1399>|DIF<tokenIndex=1401>) right=expr<tokenIndex=1406,p=22> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 20)}?<p=20> op=AND<tokenIndex=1418> right=expr<tokenIndex=1422,p=21> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 19)}?<p=19> op=OR<tokenIndex=1434> right=expr<tokenIndex=1438,p=20> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
        )*
    ;
2023-10-12 21:57:40:357 grammar LogManager.java:25 added: (RULE expr (returns interfaces.Expression e) (BLOCK (ALT (BLOCK (ALT {} (= op (NOT (ELEMENT_OPTIONS (= tokenIndex 1447)))) (= left (expr (ELEMENT_OPTIONS (= tokenIndex 1451) (= p 18)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $left.e) }) (ALT (= op (SUB (ELEMENT_OPTIONS (= tokenIndex 1461)))) (= left (expr (ELEMENT_OPTIONS (= tokenIndex 1465) (= p 17)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e,  $op.text, nil)}) (ALT (PARIZQ (ELEMENT_OPTIONS (= tokenIndex 1471))) (expr (ELEMENT_OPTIONS (= tokenIndex 1473))) (PARDER (ELEMENT_OPTIONS (= tokenIndex 1475))) { $e = $expr.e }) (ALT (NUMBER (ELEMENT_OPTIONS (= tokenIndex 1481))) {   
        
        if (strings.Contains($NUMBER.text,".")){
           
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,$NUMBER.text,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.INTEGER)
        }
    }) (ALT (STRING (ELEMENT_OPTIONS (= tokenIndex 1487))) {
        str := $STRING.text
        $e = expressions.NewPrimitive($STRING.line, $STRING.pos, str[1:len(str)-1],environment.STRING)
    }) (ALT (TRUE (ELEMENT_OPTIONS (= tokenIndex 1493))) { $e = expressions.NewPrimitive($TRUE.line, $TRUE.pos, true, environment.BOOLEAN) }) (ALT (FALSE (ELEMENT_OPTIONS (= tokenIndex 1499))) { $e = expressions.NewPrimitive($FALSE.line, $FALSE.pos, false, environment.BOOLEAN) }) (ALT (NIL (ELEMENT_OPTIONS (= tokenIndex 1505))) { $e = expressions.NewPrimitive($NIL.line, $NIL.pos, nil, environment.NULL) }) (ALT (accessstmt (ELEMENT_OPTIONS (= tokenIndex 1511))) {$e = $accessstmt.access}) (ALT (emptvecstmt (ELEMENT_OPTIONS (= tokenIndex 1517))) {$e = $emptvecstmt.emptyvec}) (ALT (countvecstmt (ELEMENT_OPTIONS (= tokenIndex 1523))) {$e = $countvecstmt.count}) (ALT (accessvecstmt (ELEMENT_OPTIONS (= tokenIndex 1529))) {$e = $accessvecstmt.accessvec}) (ALT (intfunctionstmt (ELEMENT_OPTIONS (= tokenIndex 1535))) {$e = $intfunctionstmt.intfunc}) (ALT (floatfunctionstmt (ELEMENT_OPTIONS (= tokenIndex 1541))) {$e = $floatfunctionstmt.floatfunc}) (ALT (stringfunctionstmt (ELEMENT_OPTIONS (= tokenIndex 1547))) {$e = $stringfunctionstmt.stringfunc}) (ALT (accessfuncstmt (ELEMENT_OPTIONS (= tokenIndex 1553))) {$e = $accessfuncstmt.funcexp}) (ALT (ID (ELEMENT_OPTIONS (= tokenIndex 1559))) (SET (LLAVEIZQ (ELEMENT_OPTIONS (= tokenIndex 1562))) (PARIZQ (ELEMENT_OPTIONS (= tokenIndex 1564)))) (listStructExp (ELEMENT_OPTIONS (= tokenIndex 1567))) (SET (LLAVEDER (ELEMENT_OPTIONS (= tokenIndex 1570))) (PARDER (ELEMENT_OPTIONS (= tokenIndex 1572)))) { $e = expressions.NewStructExp($ID.line, $ID.pos, $ID.text, $listStructExp.l ) }) (ALT (accessstructstmt (ELEMENT_OPTIONS (= tokenIndex 1579))) {$e = $accessstructstmt.accessstruct})) (* (BLOCK (ALT ({p.Precpred(p.GetParserRuleContext(), 25)}? (ELEMENT_OPTIONS (= p 25))) (= op (SET (MUL (ELEMENT_OPTIONS (= tokenIndex 1317))) (DIV (ELEMENT_OPTIONS (= tokenIndex 1319))))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 1324) (= p 26)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 24)}? (ELEMENT_OPTIONS (= p 24))) (= op (SET (ADD (ELEMENT_OPTIONS (= tokenIndex 1337))) (SUB (ELEMENT_OPTIONS (= tokenIndex 1339))) (PERCENT (ELEMENT_OPTIONS (= tokenIndex 1341))))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 1346) (= p 25)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 23)}? (ELEMENT_OPTIONS (= p 23))) (= op (SET (MAY_IG (ELEMENT_OPTIONS (= tokenIndex 1359))) (MAYOR (ELEMENT_OPTIONS (= tokenIndex 1361))))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 1366) (= p 24)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 22)}? (ELEMENT_OPTIONS (= p 22))) (= op (SET (MEN_IG (ELEMENT_OPTIONS (= tokenIndex 1379))) (MENOR (ELEMENT_OPTIONS (= tokenIndex 1381))))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 1386) (= p 23)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 21)}? (ELEMENT_OPTIONS (= p 21))) (= op (SET (IG_IG (ELEMENT_OPTIONS (= tokenIndex 1399))) (DIF (ELEMENT_OPTIONS (= tokenIndex 1401))))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 1406) (= p 22)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 20)}? (ELEMENT_OPTIONS (= p 20))) (= op (AND (ELEMENT_OPTIONS (= tokenIndex 1418)))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 1422) (= p 21)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 19)}? (ELEMENT_OPTIONS (= p 19))) (= op (OR (ELEMENT_OPTIONS (= tokenIndex 1434)))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 1438) (= p 20)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }))))))
2023-10-12 21:57:40:358 left-recursion LogManager.java:25 listParams returns [[]interface{} l]
    :   ( {} (AND_SIMPLE<tokenIndex=1833>| ID<tokenIndex=1836> DOUBLEPTS<tokenIndex=1838>)? expr<tokenIndex=1842> {
            $l = []interface{}{}
            $l = append($l, $expr.e)
        } 
        )
        (
          {p.Precpred(p.GetParserRuleContext(), 2)}?<p=2> COMA<tokenIndex=1814> (AND_SIMPLE<tokenIndex=1817>| ID<tokenIndex=1820> DOUBLEPTS<tokenIndex=1822>)? expr<tokenIndex=1826> {
                                          var arr []interface{}
                                          arr = append($list.l, $expr.e)
                                          $l = arr
                                      }
        )*
    ;
2023-10-12 21:57:40:361 grammar LogManager.java:25 added: (RULE listParams (returns []interface{} l) (BLOCK (ALT (BLOCK (ALT {} (? (BLOCK (ALT (AND_SIMPLE (ELEMENT_OPTIONS (= tokenIndex 1833)))) (ALT (ID (ELEMENT_OPTIONS (= tokenIndex 1836))) (DOUBLEPTS (ELEMENT_OPTIONS (= tokenIndex 1838)))))) (expr (ELEMENT_OPTIONS (= tokenIndex 1842))) {
            $l = []interface{}{}
            $l = append($l, $expr.e)
        })) (* (BLOCK (ALT ({p.Precpred(p.GetParserRuleContext(), 2)}? (ELEMENT_OPTIONS (= p 2))) (COMA (ELEMENT_OPTIONS (= tokenIndex 1814))) (? (BLOCK (ALT (AND_SIMPLE (ELEMENT_OPTIONS (= tokenIndex 1817)))) (ALT (ID (ELEMENT_OPTIONS (= tokenIndex 1820))) (DOUBLEPTS (ELEMENT_OPTIONS (= tokenIndex 1822)))))) (expr (ELEMENT_OPTIONS (= tokenIndex 1826))) {
                                          var arr []interface{}
                                          arr = append($list.l, $expr.e)
                                          $l = arr
                                      }))))))
2023-10-12 21:57:40:362 left-recursion LogManager.java:25 listStructExp returns [[]interface{} l]
    :   ( {} ID<tokenIndex=1872> DOUBLEPTS<tokenIndex=1874> expr<tokenIndex=1876>{
                    var arr []interface{}
                    StrExp := environment.NewStructContent($ID.text, $expr.e)
                    arr = append(arr, StrExp)
                    $l = arr
                } 
        | {
        $l = []interface{}{}
    } 
        )
        (
          {p.Precpred(p.GetParserRuleContext(), 3)}?<p=3> COMA<tokenIndex=1859>?  ID<tokenIndex=1862> DOUBLEPTS<tokenIndex=1864> expr<tokenIndex=1866> {
                                                      var arr []interface{}
                                                      StrExp := environment.NewStructContent($ID.text, $expr.e)
                                                      arr = append($list.l, StrExp)
                                                      $l = arr
                                                  }
        )*
    ;
2023-10-12 21:57:40:365 grammar LogManager.java:25 added: (RULE listStructExp (returns []interface{} l) (BLOCK (ALT (BLOCK (ALT {} (ID (ELEMENT_OPTIONS (= tokenIndex 1872))) (DOUBLEPTS (ELEMENT_OPTIONS (= tokenIndex 1874))) (expr (ELEMENT_OPTIONS (= tokenIndex 1876))) {
                    var arr []interface{}
                    StrExp := environment.NewStructContent($ID.text, $expr.e)
                    arr = append(arr, StrExp)
                    $l = arr
                }) (ALT {
        $l = []interface{}{}
    })) (* (BLOCK (ALT ({p.Precpred(p.GetParserRuleContext(), 3)}? (ELEMENT_OPTIONS (= p 3))) (? (BLOCK (ALT (COMA (ELEMENT_OPTIONS (= tokenIndex 1859)))))) (ID (ELEMENT_OPTIONS (= tokenIndex 1862))) (DOUBLEPTS (ELEMENT_OPTIONS (= tokenIndex 1864))) (expr (ELEMENT_OPTIONS (= tokenIndex 1866))) {
                                                      var arr []interface{}
                                                      StrExp := environment.NewStructContent($ID.text, $expr.e)
                                                      arr = append($list.l, StrExp)
                                                      $l = arr
                                                  }))))))
2023-10-12 21:57:40:382 grammar LogManager.java:25 import STRINGS=1
2023-10-12 21:57:40:382 grammar LogManager.java:25 import INTS=2
2023-10-12 21:57:40:382 grammar LogManager.java:25 import FLOATS=3
2023-10-12 21:57:40:382 grammar LogManager.java:25 import BOOLS=4
2023-10-12 21:57:40:382 grammar LogManager.java:25 import CHARACTERS=5
2023-10-12 21:57:40:382 grammar LogManager.java:25 import VAR=6
2023-10-12 21:57:40:382 grammar LogManager.java:25 import NIL=7
2023-10-12 21:57:40:382 grammar LogManager.java:25 import TRUE=8
2023-10-12 21:57:40:382 grammar LogManager.java:25 import FALSE=9
2023-10-12 21:57:40:382 grammar LogManager.java:25 import PRINT=10
2023-10-12 21:57:40:382 grammar LogManager.java:25 import IF=11
2023-10-12 21:57:40:382 grammar LogManager.java:25 import ELSE=12
2023-10-12 21:57:40:382 grammar LogManager.java:25 import WHILE=13
2023-10-12 21:57:40:382 grammar LogManager.java:25 import LET=14
2023-10-12 21:57:40:382 grammar LogManager.java:25 import FOR=15
2023-10-12 21:57:40:382 grammar LogManager.java:25 import IN=16
2023-10-12 21:57:40:382 grammar LogManager.java:25 import SWITCH=17
2023-10-12 21:57:40:385 grammar LogManager.java:25 import CASE=18
2023-10-12 21:57:40:385 grammar LogManager.java:25 import DEFAULT=19
2023-10-12 21:57:40:385 grammar LogManager.java:25 import GUARD=20
2023-10-12 21:57:40:385 grammar LogManager.java:25 import CONTINUE=21
2023-10-12 21:57:40:385 grammar LogManager.java:25 import RETURN=22
2023-10-12 21:57:40:385 grammar LogManager.java:25 import BREAK=23
2023-10-12 21:57:40:385 grammar LogManager.java:25 import APPEND=24
2023-10-12 21:57:40:385 grammar LogManager.java:25 import REMOVELAST=25
2023-10-12 21:57:40:385 grammar LogManager.java:25 import REMOVE=26
2023-10-12 21:57:40:385 grammar LogManager.java:25 import AT=27
2023-10-12 21:57:40:385 grammar LogManager.java:25 import ISEMPTY=28
2023-10-12 21:57:40:385 grammar LogManager.java:25 import COUNT=29
2023-10-12 21:57:40:385 grammar LogManager.java:25 import FUNC=30
2023-10-12 21:57:40:385 grammar LogManager.java:25 import INOUT=31
2023-10-12 21:57:40:385 grammar LogManager.java:25 import STRUCT=32
2023-10-12 21:57:40:385 grammar LogManager.java:25 import NUMBER=33
2023-10-12 21:57:40:385 grammar LogManager.java:25 import STRING=34
2023-10-12 21:57:40:385 grammar LogManager.java:25 import ID=35
2023-10-12 21:57:40:385 grammar LogManager.java:25 import DIF=36
2023-10-12 21:57:40:385 grammar LogManager.java:25 import IG_IG=37
2023-10-12 21:57:40:385 grammar LogManager.java:25 import NOT=38
2023-10-12 21:57:40:385 grammar LogManager.java:25 import OR=39
2023-10-12 21:57:40:385 grammar LogManager.java:25 import AND=40
2023-10-12 21:57:40:385 grammar LogManager.java:25 import IG=41
2023-10-12 21:57:40:385 grammar LogManager.java:25 import IG_ADD=42
2023-10-12 21:57:40:385 grammar LogManager.java:25 import IG_SUB=43
2023-10-12 21:57:40:385 grammar LogManager.java:25 import MAY_IG=44
2023-10-12 21:57:40:385 grammar LogManager.java:25 import MEN_IG=45
2023-10-12 21:57:40:385 grammar LogManager.java:25 import MAYOR=46
2023-10-12 21:57:40:385 grammar LogManager.java:25 import MENOR=47
2023-10-12 21:57:40:385 grammar LogManager.java:25 import MUL=48
2023-10-12 21:57:40:385 grammar LogManager.java:25 import DIV=49
2023-10-12 21:57:40:385 grammar LogManager.java:25 import ADD=50
2023-10-12 21:57:40:385 grammar LogManager.java:25 import SUB=51
2023-10-12 21:57:40:385 grammar LogManager.java:25 import PERCENT=52
2023-10-12 21:57:40:385 grammar LogManager.java:25 import PARIZQ=53
2023-10-12 21:57:40:385 grammar LogManager.java:25 import PARDER=54
2023-10-12 21:57:40:385 grammar LogManager.java:25 import LLAVEIZQ=55
2023-10-12 21:57:40:385 grammar LogManager.java:25 import LLAVEDER=56
2023-10-12 21:57:40:385 grammar LogManager.java:25 import DOUBLEPTS=57
2023-10-12 21:57:40:385 grammar LogManager.java:25 import QUESTION=58
2023-10-12 21:57:40:385 grammar LogManager.java:25 import POINT=59
2023-10-12 21:57:40:385 grammar LogManager.java:25 import COMA=60
2023-10-12 21:57:40:385 grammar LogManager.java:25 import PTCOMA=61
2023-10-12 21:57:40:385 grammar LogManager.java:25 import CORCHETEIZQ=62
2023-10-12 21:57:40:385 grammar LogManager.java:25 import CORCHETEDER=63
2023-10-12 21:57:40:385 grammar LogManager.java:25 import GUION_BAJO=64
2023-10-12 21:57:40:385 grammar LogManager.java:25 import AND_SIMPLE=65
2023-10-12 21:57:40:385 grammar LogManager.java:25 import WHITESPACE=66
2023-10-12 21:57:40:385 grammar LogManager.java:25 import COMMENT=67
2023-10-12 21:57:40:385 grammar LogManager.java:25 import LINE_COMMENT=68
2023-10-12 21:57:40:385 grammar LogManager.java:25 import 'String'=1
2023-10-12 21:57:40:385 grammar LogManager.java:25 import 'Int'=2
2023-10-12 21:57:40:385 grammar LogManager.java:25 import 'Float'=3
2023-10-12 21:57:40:385 grammar LogManager.java:25 import 'Bool'=4
2023-10-12 21:57:40:385 grammar LogManager.java:25 import 'Character'=5
2023-10-12 21:57:40:385 grammar LogManager.java:25 import 'var'=6
2023-10-12 21:57:40:385 grammar LogManager.java:25 import 'nil'=7
2023-10-12 21:57:40:385 grammar LogManager.java:25 import 'true'=8
2023-10-12 21:57:40:385 grammar LogManager.java:25 import 'false'=9
2023-10-12 21:57:40:385 grammar LogManager.java:25 import 'print'=10
2023-10-12 21:57:40:385 grammar LogManager.java:25 import 'if'=11
2023-10-12 21:57:40:385 grammar LogManager.java:25 import 'else'=12
2023-10-12 21:57:40:385 grammar LogManager.java:25 import 'while'=13
2023-10-12 21:57:40:385 grammar LogManager.java:25 import 'let'=14
2023-10-12 21:57:40:385 grammar LogManager.java:25 import 'for'=15
2023-10-12 21:57:40:385 grammar LogManager.java:25 import 'in'=16
2023-10-12 21:57:40:385 grammar LogManager.java:25 import 'switch'=17
2023-10-12 21:57:40:385 grammar LogManager.java:25 import 'case'=18
2023-10-12 21:57:40:385 grammar LogManager.java:25 import 'default'=19
2023-10-12 21:57:40:385 grammar LogManager.java:25 import 'guard'=20
2023-10-12 21:57:40:385 grammar LogManager.java:25 import 'continue'=21
2023-10-12 21:57:40:385 grammar LogManager.java:25 import 'return'=22
2023-10-12 21:57:40:385 grammar LogManager.java:25 import 'break'=23
2023-10-12 21:57:40:385 grammar LogManager.java:25 import 'append'=24
2023-10-12 21:57:40:385 grammar LogManager.java:25 import 'removeLast'=25
2023-10-12 21:57:40:385 grammar LogManager.java:25 import 'remove'=26
2023-10-12 21:57:40:385 grammar LogManager.java:25 import 'at'=27
2023-10-12 21:57:40:385 grammar LogManager.java:25 import 'isEmpty'=28
2023-10-12 21:57:40:385 grammar LogManager.java:25 import 'count'=29
2023-10-12 21:57:40:385 grammar LogManager.java:25 import 'func'=30
2023-10-12 21:57:40:385 grammar LogManager.java:25 import 'inout'=31
2023-10-12 21:57:40:385 grammar LogManager.java:25 import 'struct'=32
2023-10-12 21:57:40:385 grammar LogManager.java:25 import '!='=36
2023-10-12 21:57:40:385 grammar LogManager.java:25 import '=='=37
2023-10-12 21:57:40:385 grammar LogManager.java:25 import '!'=38
2023-10-12 21:57:40:385 grammar LogManager.java:25 import '||'=39
2023-10-12 21:57:40:385 grammar LogManager.java:25 import '&&'=40
2023-10-12 21:57:40:385 grammar LogManager.java:25 import '='=41
2023-10-12 21:57:40:385 grammar LogManager.java:25 import '+='=42
2023-10-12 21:57:40:385 grammar LogManager.java:25 import '-='=43
2023-10-12 21:57:40:385 grammar LogManager.java:25 import '>='=44
2023-10-12 21:57:40:385 grammar LogManager.java:25 import '<='=45
2023-10-12 21:57:40:385 grammar LogManager.java:25 import '>'=46
2023-10-12 21:57:40:385 grammar LogManager.java:25 import '<'=47
2023-10-12 21:57:40:385 grammar LogManager.java:25 import '*'=48
2023-10-12 21:57:40:385 grammar LogManager.java:25 import '/'=49
2023-10-12 21:57:40:385 grammar LogManager.java:25 import '+'=50
2023-10-12 21:57:40:385 grammar LogManager.java:25 import '-'=51
2023-10-12 21:57:40:385 grammar LogManager.java:25 import '%'=52
2023-10-12 21:57:40:385 grammar LogManager.java:25 import '('=53
2023-10-12 21:57:40:385 grammar LogManager.java:25 import ')'=54
2023-10-12 21:57:40:385 grammar LogManager.java:25 import '{'=55
2023-10-12 21:57:40:385 grammar LogManager.java:25 import '}'=56
2023-10-12 21:57:40:385 grammar LogManager.java:25 import ':'=57
2023-10-12 21:57:40:385 grammar LogManager.java:25 import '?'=58
2023-10-12 21:57:40:385 grammar LogManager.java:25 import '.'=59
2023-10-12 21:57:40:385 grammar LogManager.java:25 import ','=60
2023-10-12 21:57:40:385 grammar LogManager.java:25 import ';'=61
2023-10-12 21:57:40:390 grammar LogManager.java:25 import '['=62
2023-10-12 21:57:40:390 grammar LogManager.java:25 import ']'=63
2023-10-12 21:57:40:390 grammar LogManager.java:25 import '_'=64
2023-10-12 21:57:40:390 grammar LogManager.java:25 import '&'=65
2023-10-12 21:57:40:390 grammar LogManager.java:25 tokens={STRINGS=1, INTS=2, FLOATS=3, BOOLS=4, CHARACTERS=5, VAR=6, NIL=7, TRUE=8, FALSE=9, PRINT=10, IF=11, ELSE=12, WHILE=13, LET=14, FOR=15, IN=16, SWITCH=17, CASE=18, DEFAULT=19, GUARD=20, CONTINUE=21, RETURN=22, BREAK=23, APPEND=24, REMOVELAST=25, REMOVE=26, AT=27, ISEMPTY=28, COUNT=29, FUNC=30, INOUT=31, STRUCT=32, NUMBER=33, STRING=34, ID=35, DIF=36, IG_IG=37, NOT=38, OR=39, AND=40, IG=41, IG_ADD=42, IG_SUB=43, MAY_IG=44, MEN_IG=45, MAYOR=46, MENOR=47, MUL=48, DIV=49, ADD=50, SUB=51, PERCENT=52, PARIZQ=53, PARDER=54, LLAVEIZQ=55, LLAVEDER=56, DOUBLEPTS=57, QUESTION=58, POINT=59, COMA=60, PTCOMA=61, CORCHETEIZQ=62, CORCHETEDER=63, GUION_BAJO=64, AND_SIMPLE=65, WHITESPACE=66, COMMENT=67, LINE_COMMENT=68, 'String'=1, 'Int'=2, 'Float'=3, 'Bool'=4, 'Character'=5, 'var'=6, 'nil'=7, 'true'=8, 'false'=9, 'print'=10, 'if'=11, 'else'=12, 'while'=13, 'let'=14, 'for'=15, 'in'=16, 'switch'=17, 'case'=18, 'default'=19, 'guard'=20, 'continue'=21, 'return'=22, 'break'=23, 'append'=24, 'removeLast'=25, 'remove'=26, 'at'=27, 'isEmpty'=28, 'count'=29, 'func'=30, 'inout'=31, 'struct'=32, '!='=36, '=='=37, '!'=38, '||'=39, '&&'=40, '='=41, '+='=42, '-='=43, '>='=44, '<='=45, '>'=46, '<'=47, '*'=48, '/'=49, '+'=50, '-'=51, '%'=52, '('=53, ')'=54, '{'=55, '}'=56, ':'=57, '?'=58, '.'=59, ','=60, ';'=61, '['=62, ']'=63, '_'=64, '&'=65}
2023-10-12 21:57:40:390 semantics LogManager.java:25 tokens={EOF=-1, STRINGS=1, INTS=2, FLOATS=3, BOOLS=4, CHARACTERS=5, VAR=6, NIL=7, TRUE=8, FALSE=9, PRINT=10, IF=11, ELSE=12, WHILE=13, LET=14, FOR=15, IN=16, SWITCH=17, CASE=18, DEFAULT=19, GUARD=20, CONTINUE=21, RETURN=22, BREAK=23, APPEND=24, REMOVELAST=25, REMOVE=26, AT=27, ISEMPTY=28, COUNT=29, FUNC=30, INOUT=31, STRUCT=32, NUMBER=33, STRING=34, ID=35, DIF=36, IG_IG=37, NOT=38, OR=39, AND=40, IG=41, IG_ADD=42, IG_SUB=43, MAY_IG=44, MEN_IG=45, MAYOR=46, MENOR=47, MUL=48, DIV=49, ADD=50, SUB=51, PERCENT=52, PARIZQ=53, PARDER=54, LLAVEIZQ=55, LLAVEDER=56, DOUBLEPTS=57, QUESTION=58, POINT=59, COMA=60, PTCOMA=61, CORCHETEIZQ=62, CORCHETEDER=63, GUION_BAJO=64, AND_SIMPLE=65, WHITESPACE=66, COMMENT=67, LINE_COMMENT=68}
2023-10-12 21:57:40:390 semantics LogManager.java:25 strings={'String'=1, 'Int'=2, 'Float'=3, 'Bool'=4, 'Character'=5, 'var'=6, 'nil'=7, 'true'=8, 'false'=9, 'print'=10, 'if'=11, 'else'=12, 'while'=13, 'let'=14, 'for'=15, 'in'=16, 'switch'=17, 'case'=18, 'default'=19, 'guard'=20, 'continue'=21, 'return'=22, 'break'=23, 'append'=24, 'removeLast'=25, 'remove'=26, 'at'=27, 'isEmpty'=28, 'count'=29, 'func'=30, 'inout'=31, 'struct'=32, '!='=36, '=='=37, '!'=38, '||'=39, '&&'=40, '='=41, '+='=42, '-='=43, '>='=44, '<='=45, '>'=46, '<'=47, '*'=48, '/'=49, '+'=50, '-'=51, '%'=52, '('=53, ')'=54, '{'=55, '}'=56, ':'=57, '?'=58, '.'=59, ','=60, ';'=61, '['=62, ']'=63, '_'=64, '&'=65}
