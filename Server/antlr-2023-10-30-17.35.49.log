2023-10-30 17:35:47:445 grammar LogManager.java:25 before: (LEXER_GRAMMAR Lex (RULES (RULE STRINGS (BLOCK (ALT 'String'))) (RULE INTS (BLOCK (ALT 'Int'))) (RULE FLOATS (BLOCK (ALT 'Float'))) (RULE BOOLS (BLOCK (ALT 'Bool'))) (RULE CHARACTERS (BLOCK (ALT 'Character'))) (RULE VAR (BLOCK (ALT 'var'))) (RULE NIL (BLOCK (ALT 'nil'))) (RULE TRUE (BLOCK (ALT 'true'))) (RULE FALSE (BLOCK (ALT 'false'))) (RULE PRINT (BLOCK (ALT 'print'))) (RULE IF (BLOCK (ALT 'if'))) (RULE ELSE (BLOCK (ALT 'else'))) (RULE WHILE (BLOCK (ALT 'while'))) (RULE LET (BLOCK (ALT 'let'))) (RULE FOR (BLOCK (ALT 'for'))) (RULE IN (BLOCK (ALT 'in'))) (RULE SWITCH (BLOCK (ALT 'switch'))) (RULE CASE (BLOCK (ALT 'case'))) (RULE DEFAULT (BLOCK (ALT 'default'))) (RULE GUARD (BLOCK (ALT 'guard'))) (RULE CONTINUE (BLOCK (ALT 'continue'))) (RULE RETURN (BLOCK (ALT 'return'))) (RULE BREAK (BLOCK (ALT 'break'))) (RULE APPEND (BLOCK (ALT 'append'))) (RULE REMOVELAST (BLOCK (ALT 'removeLast'))) (RULE REMOVE (BLOCK (ALT 'remove'))) (RULE AT (BLOCK (ALT 'at'))) (RULE ISEMPTY (BLOCK (ALT 'isEmpty'))) (RULE COUNT (BLOCK (ALT 'count'))) (RULE FUNC (BLOCK (ALT 'func'))) (RULE INOUT (BLOCK (ALT 'inout'))) (RULE STRUCT (BLOCK (ALT 'struct'))) (RULE NUMBER (BLOCK (ALT (+ (BLOCK (ALT [0-9]))) (? (BLOCK (ALT '.' (+ (BLOCK (ALT [0-9]))))))))) (RULE STRING (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["]))))) '"'))) (RULE ID (BLOCK (ALT (BLOCK (ALT [a-zA-Z_])) (* (BLOCK (ALT [a-zA-Z0-9_])))))) (RULE DIF (BLOCK (ALT '!='))) (RULE IG_IG (BLOCK (ALT '=='))) (RULE NOT (BLOCK (ALT '!'))) (RULE OR (BLOCK (ALT '||'))) (RULE AND (BLOCK (ALT '&&'))) (RULE IG (BLOCK (ALT '='))) (RULE IG_ADD (BLOCK (ALT '+='))) (RULE IG_SUB (BLOCK (ALT '-='))) (RULE MAY_IG (BLOCK (ALT '>='))) (RULE MEN_IG (BLOCK (ALT '<='))) (RULE MAYOR (BLOCK (ALT '>'))) (RULE MENOR (BLOCK (ALT '<'))) (RULE MUL (BLOCK (ALT '*'))) (RULE DIV (BLOCK (ALT '/'))) (RULE ADD (BLOCK (ALT '+'))) (RULE SUB (BLOCK (ALT '-'))) (RULE PERCENT (BLOCK (ALT '%'))) (RULE PARIZQ (BLOCK (ALT '('))) (RULE PARDER (BLOCK (ALT ')'))) (RULE LLAVEIZQ (BLOCK (ALT '{'))) (RULE LLAVEDER (BLOCK (ALT '}'))) (RULE DOUBLEPTS (BLOCK (ALT ':'))) (RULE QUESTION (BLOCK (ALT '?'))) (RULE POINT (BLOCK (ALT '.'))) (RULE COMA (BLOCK (ALT ','))) (RULE PTCOMA (BLOCK (ALT ';'))) (RULE CORCHETEIZQ (BLOCK (ALT '['))) (RULE CORCHETEDER (BLOCK (ALT ']'))) (RULE GUION_BAJO (BLOCK (ALT '_'))) (RULE AND_SIMPLE (BLOCK (ALT '&'))) (RULE WHITESPACE (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \\\r\n\t])))) skip))) (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '/*' (* (BLOCK (ALT .))) '*/') skip))) (RULE LINE_COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '//' (* (BLOCK (ALT (~ (SET [\r\n])))))) skip))) (RULE ESC_SEQ (RULEMODIFIERS fragment) (BLOCK (ALT '\\' (BLOCK (ALT '\\') (ALT '@') (ALT '[') (ALT ']') (ALT '.') (ALT '#') (ALT '+') (ALT '-') (ALT '!') (ALT ':') (ALT ' ')))))))
2023-10-30 17:35:47:469 grammar LogManager.java:25 after: (LEXER_GRAMMAR Lex (RULES (RULE STRINGS (BLOCK (ALT 'String'))) (RULE INTS (BLOCK (ALT 'Int'))) (RULE FLOATS (BLOCK (ALT 'Float'))) (RULE BOOLS (BLOCK (ALT 'Bool'))) (RULE CHARACTERS (BLOCK (ALT 'Character'))) (RULE VAR (BLOCK (ALT 'var'))) (RULE NIL (BLOCK (ALT 'nil'))) (RULE TRUE (BLOCK (ALT 'true'))) (RULE FALSE (BLOCK (ALT 'false'))) (RULE PRINT (BLOCK (ALT 'print'))) (RULE IF (BLOCK (ALT 'if'))) (RULE ELSE (BLOCK (ALT 'else'))) (RULE WHILE (BLOCK (ALT 'while'))) (RULE LET (BLOCK (ALT 'let'))) (RULE FOR (BLOCK (ALT 'for'))) (RULE IN (BLOCK (ALT 'in'))) (RULE SWITCH (BLOCK (ALT 'switch'))) (RULE CASE (BLOCK (ALT 'case'))) (RULE DEFAULT (BLOCK (ALT 'default'))) (RULE GUARD (BLOCK (ALT 'guard'))) (RULE CONTINUE (BLOCK (ALT 'continue'))) (RULE RETURN (BLOCK (ALT 'return'))) (RULE BREAK (BLOCK (ALT 'break'))) (RULE APPEND (BLOCK (ALT 'append'))) (RULE REMOVELAST (BLOCK (ALT 'removeLast'))) (RULE REMOVE (BLOCK (ALT 'remove'))) (RULE AT (BLOCK (ALT 'at'))) (RULE ISEMPTY (BLOCK (ALT 'isEmpty'))) (RULE COUNT (BLOCK (ALT 'count'))) (RULE FUNC (BLOCK (ALT 'func'))) (RULE INOUT (BLOCK (ALT 'inout'))) (RULE STRUCT (BLOCK (ALT 'struct'))) (RULE NUMBER (BLOCK (ALT (+ (BLOCK (ALT [0-9]))) (? (BLOCK (ALT '.' (+ (BLOCK (ALT [0-9]))))))))) (RULE STRING (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["]))))) '"'))) (RULE ID (BLOCK (ALT (BLOCK (ALT [a-zA-Z_])) (* (BLOCK (ALT [a-zA-Z0-9_])))))) (RULE DIF (BLOCK (ALT '!='))) (RULE IG_IG (BLOCK (ALT '=='))) (RULE NOT (BLOCK (ALT '!'))) (RULE OR (BLOCK (ALT '||'))) (RULE AND (BLOCK (ALT '&&'))) (RULE IG (BLOCK (ALT '='))) (RULE IG_ADD (BLOCK (ALT '+='))) (RULE IG_SUB (BLOCK (ALT '-='))) (RULE MAY_IG (BLOCK (ALT '>='))) (RULE MEN_IG (BLOCK (ALT '<='))) (RULE MAYOR (BLOCK (ALT '>'))) (RULE MENOR (BLOCK (ALT '<'))) (RULE MUL (BLOCK (ALT '*'))) (RULE DIV (BLOCK (ALT '/'))) (RULE ADD (BLOCK (ALT '+'))) (RULE SUB (BLOCK (ALT '-'))) (RULE PERCENT (BLOCK (ALT '%'))) (RULE PARIZQ (BLOCK (ALT '('))) (RULE PARDER (BLOCK (ALT ')'))) (RULE LLAVEIZQ (BLOCK (ALT '{'))) (RULE LLAVEDER (BLOCK (ALT '}'))) (RULE DOUBLEPTS (BLOCK (ALT ':'))) (RULE QUESTION (BLOCK (ALT '?'))) (RULE POINT (BLOCK (ALT '.'))) (RULE COMA (BLOCK (ALT ','))) (RULE PTCOMA (BLOCK (ALT ';'))) (RULE CORCHETEIZQ (BLOCK (ALT '['))) (RULE CORCHETEDER (BLOCK (ALT ']'))) (RULE GUION_BAJO (BLOCK (ALT '_'))) (RULE AND_SIMPLE (BLOCK (ALT '&'))) (RULE WHITESPACE (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \\\r\n\t])))) skip))) (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '/*' (* (BLOCK (ALT .))) '*/') skip))) (RULE LINE_COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '//' (* (BLOCK (ALT (~ (SET [\r\n])))))) skip))) (RULE ESC_SEQ (RULEMODIFIERS fragment) (BLOCK (ALT '\\' (SET '\\' '@' '[' ']' '.' '#' '+' '-' '!' ':' ' '))))))
2023-10-30 17:35:48:187 grammar LogManager.java:25 before: (COMBINED_GRAMMAR Grammar (OPTIONS (= tokenVocab Lex)) (@ header {
    import "Server/Interfaces"
    import "Server/Environment"
    import "Server/Expression"
    import "Server/Instruction"
    import "strings"
}) (RULES (RULE s (returns []interface{} code) (BLOCK (ALT block EOF {$code = $block.blk}))) (RULE block (returns []interface{} blk) (@ init {
$blk = []interface{}{}
    var listInt []IInstructionContext
  }) (BLOCK (ALT (+ (BLOCK (ALT (+= ins instruction)))) {
        listInt = localctx.(*BlockContext).GetIns()
        for _, e := range listInt {
            $blk = append($blk, e.GetInst())
            
        }
    }))) (RULE instruction (returns interfaces.Instruction inst) (BLOCK (ALT printstmt { $inst = $printstmt.prnt}) (ALT declarestmt {$inst = $declarestmt.dec}) (ALT constantstmt {$inst = $constantstmt.const}) (ALT assignationstmt {$inst = $assignationstmt.assign}) (ALT increaseanddecreasestmt {$inst = $increaseanddecreasestmt.increasedecrease}) (ALT ifstmt { $inst = $ifstmt.ift }) (ALT whilestmt {$inst = $whilestmt.while}) (ALT forstmt {$inst = $forstmt.for}) (ALT switchstmt {$inst = $switchstmt.switch}) (ALT guardstmt {$inst = $guardstmt.gua}) (ALT transferstmt {$inst = $transferstmt.tran}) (ALT declarevectorstmt {$inst = $declarevectorstmt.decvec}) (ALT appendstmt {$inst = $appendstmt.app}) (ALT removelaststmt {$inst = $removelaststmt.removl}) (ALT removestmt {$inst = $removestmt.remov}) (ALT assignationvecstmt {$inst = $assignationvecstmt.assignvec}) (ALT declarefuncstmt {$inst = $declarefuncstmt.decfunc}) (ALT accessfuncinstruction {$inst = $accessfuncinstruction.accessfuncin}) (ALT declarestructstmt {$inst = $declarestructstmt.decstruct }) (ALT assignationstructstmt {$inst = $assignationstructstmt.assignstruct}))) (RULE printstmt (returns interfaces.Instruction prnt) (BLOCK (ALT PRINT PARIZQ listParams PARDER (? (BLOCK (ALT PTCOMA))) { $prnt = instructions.NewPrint($PRINT.line, $PRINT.pos, $listParams.l)}))) (RULE declarestmt (returns interfaces.Instruction dec) (BLOCK (ALT VAR ID DOUBLEPTS type IG expr (? (BLOCK (ALT PTCOMA))) {$dec = instructions.NewTodeclare($VAR.line, $VAR.pos, $ID.text, $type.t, $expr.e, false)}) (ALT VAR ID IG expr (? (BLOCK (ALT PTCOMA))) {$dec = instructions.NewTodeclare($VAR.line, $VAR.pos, $ID.text, environment.NULL, $expr.e, false)}) (ALT VAR ID DOUBLEPTS type QUESTION (? (BLOCK (ALT PTCOMA))) {$dec = instructions.NewTodeclare($VAR.line, $VAR.pos, $ID.text, $type.t, nil, false)}))) (RULE constantstmt (returns interfaces.Instruction const) (BLOCK (ALT LET ID DOUBLEPTS type IG expr (? (BLOCK (ALT PTCOMA))) {$const = instructions.NewTodeclare($LET.line, $LET.pos, $ID.text, $type.t, $expr.e, true)}) (ALT LET ID IG expr (? (BLOCK (ALT PTCOMA))) {$const = instructions.NewTodeclare($LET.line, $LET.pos, $ID.text, environment.NULL, $expr.e, true)}))) (RULE blockelifs (returns []interface{} blkef) (@ init {
$blkef = []interface{}{}
    var listifs []IIfstmtContext
    
  }) (BLOCK (ALT (+ (BLOCK (ALT (+= elif ifstmt)))) {   
        listifs = localctx.(*BlockelifsContext).GetElif()
        for _, a := range listifs {
            $blkef = append($blkef, a.GetIft())
            
        }
    }))) (RULE ifstmt (returns interfaces.Instruction ift, []interface{} el, interfaces.Instruction else) (BLOCK (ALT IF expr LLAVEIZQ (= ifb block) LLAVEDER { $ift = instructions.NewIf($IF.line, $IF.pos, $expr.e, $ifb.blk, nil); 
                                        $el = $ifb.blk}) (ALT IF expr LLAVEIZQ (= ifelseblck block) LLAVEDER ELSE LLAVEIZQ (= elseifblck block) LLAVEDER { $ift = instructions.NewIf($IF.line, $IF.pos, $expr.e, $ifelseblck.blk, $elseifblck.blk); 
                                                                                        $el = $ifelseblck.blk;
                                                                                        
                                                                                        }) (ALT IF expr LLAVEIZQ (= elif block) LLAVEDER ELSE blockelifs { $ift = instructions.NewIf($IF.line, $IF.pos, $expr.e, $elif.blk, $blockelifs.blkef); }))) (RULE switchstmt (returns interfaces.Instruction switch) (BLOCK (ALT SWITCH expr LLAVEIZQ DEFAULT DOUBLEPTS block LLAVEDER { $switch = instructions.NewSwitch($SWITCH.line, $SWITCH.pos, $expr.e, nil,  nil, $block.blk);}) (ALT SWITCH expr LLAVEIZQ casestmt LLAVEDER {$switch = instructions.NewSwitch($SWITCH.line, $SWITCH.pos, $expr.e, nil, $casestmt.cas, nil);}))) (RULE casestmt (returns interfaces.Instruction cas) (BLOCK (ALT CASE expr DOUBLEPTS block blockcases { $cas = instructions.NewCase($CASE.line,$CASE.pos, $expr.e,$block.blk, $blockcases.blkcase)
                                }) (ALT CASE expr DOUBLEPTS (= sen block) DEFAULT DOUBLEPTS (= def block) { $cas = instructions.NewCase($CASE.line,$CASE.pos, $expr.e,$sen.blk, $def.blk)}))) (RULE blockcases (returns []interface{} blkcase) (@ init {
    $blkcase = []interface{}{}
    var listcases []ICasestmtContext
  }) (BLOCK (ALT (+ (BLOCK (ALT (+= casedef casestmt)))) {
        listcases = localctx.(*BlockcasesContext).GetCasedef()
        for _, a := range listcases {
            $blkcase = append($blkcase, a.GetCas())
      
        }
    }))) (RULE assignationstmt (returns interfaces.Instruction assign) (BLOCK (ALT ID IG expr (? (BLOCK (ALT PTCOMA))) {$assign = instructions.NewAssignation($ID.line, $ID.pos,  $ID.text, $expr.e)}))) (RULE assignationstructstmt (returns interfaces.Instruction assignstruct) (BLOCK (ALT ID POINT (= second ID) IG expr (? (BLOCK (ALT PTCOMA))) {$assignstruct = instructions.NewAssignationStruct($ID.line, $ID.pos, $ID.text, $second.text, $expr.e)}))) (RULE whilestmt (returns interfaces.Instruction while) (BLOCK (ALT WHILE expr LLAVEIZQ block LLAVEDER {$while = instructions.NewWhile($WHILE.line, $WHILE.pos,  $expr.e, $block.blk)}))) (RULE forstmt (returns interfaces.Instruction for) (BLOCK (ALT FOR ID IN expr LLAVEIZQ block LLAVEDER {$for = instructions.NewFor($FOR.line, $FOR.pos, $ID.text, $expr.e, nil, $block.blk)}) (ALT FOR ID IN (= first expr) POINT POINT (= second expr) LLAVEIZQ block LLAVEDER {$for = instructions.NewFor($FOR.line, $FOR.pos, $ID.text, $first.e, $second.e, $block.blk)}))) (RULE guardstmt (returns interfaces.Instruction gua) (BLOCK (ALT GUARD expr ELSE LLAVEIZQ block LLAVEDER {$gua = instructions.NewGuard($GUARD.line, $GUARD.pos, $expr.e, $block.blk)}))) (RULE transferstmt (returns interfaces.Instruction tran) (BLOCK (ALT RETURN (? (BLOCK (ALT PTCOMA))) {$tran = instructions.NewReturnIn($RETURN.line, $RETURN.pos, nil)}) (ALT RETURN expr (? (BLOCK (ALT PTCOMA))) {$tran = instructions.NewReturnIn($RETURN.line, $RETURN.pos, $expr.e)}) (ALT CONTINUE (? (BLOCK (ALT PTCOMA))) {$tran = instructions.NewContinue($CONTINUE.line, $CONTINUE.pos)}) (ALT BREAK (? (BLOCK (ALT PTCOMA))) {$tran = instructions.NewBreak($BREAK.line, $BREAK.pos)}))) (RULE declarevectorstmt (returns interfaces.Instruction decvec) (BLOCK (ALT VAR ID DOUBLEPTS CORCHETEIZQ type CORCHETEDER IG CORCHETEIZQ listParams CORCHETEDER (? (BLOCK (ALT PTCOMA))) {$decvec = instructions.NewToDeclareVector($VAR.line, $VAR.pos, $ID.text, $type.t, $listParams.l, "")}) (ALT VAR ID DOUBLEPTS CORCHETEIZQ type CORCHETEDER IG CORCHETEIZQ CORCHETEDER (? (BLOCK (ALT PTCOMA))) {$decvec = instructions.NewToDeclareVector($VAR.line, $VAR.pos, $ID.text, $type.t, nil, "")}) (ALT VAR ID IG CORCHETEIZQ type CORCHETEDER PARIZQ PARDER (? (BLOCK (ALT PTCOMA)))) (ALT VAR (= F ID) DOUBLEPTS CORCHETEIZQ type CORCHETEDER IG (= S ID) (? (BLOCK (ALT PTCOMA))) {$decvec = instructions.NewToDeclareVector($VAR.line, $VAR.pos, $F.text, $type.t, nil, $S.text)}))) (RULE accessfuncinstruction (returns interfaces.Instruction accessfuncin) (BLOCK (ALT ID PARIZQ listParams PARDER PTCOMA {$accessfuncin = instructions.NewCallFunction($ID.line, $ID.pos, $ID.text, $listParams.l, 1)}))) (RULE appendstmt (returns interfaces.Instruction app) (BLOCK (ALT ID POINT APPEND PARIZQ expr PARDER (? (BLOCK (ALT PTCOMA))) {$app = instructions.NewAppend($ID.line, $ID.pos, $ID.text, $expr.e)}))) (RULE removelaststmt (returns interfaces.Instruction removl) (BLOCK (ALT ID POINT REMOVELAST PARIZQ PARDER (? (BLOCK (ALT PTCOMA))) {$removl = instructions.NewRemoveLast($ID.line, $ID.pos, $ID.text)}))) (RULE removestmt (returns interfaces.Instruction remov) (BLOCK (ALT ID POINT REMOVE PARIZQ AT DOUBLEPTS expr PARDER (? (BLOCK (ALT PTCOMA))) {$remov = instructions.NewRemove($ID.line, $ID.pos, $ID.text, $expr.e)}))) (RULE emptvecstmt (returns interfaces.Expression emptyvec) (BLOCK (ALT ID POINT ISEMPTY {$emptyvec = expressions.NewEmptyVector($ID.line, $ID.pos, $ID.text)}))) (RULE countvecstmt (returns interfaces.Expression count) (BLOCK (ALT ID POINT COUNT {$count = expressions.NewCount($ID.line, $ID.pos, $ID.text)}))) (RULE accessvecstmt (returns interfaces.Expression accessvec) (BLOCK (ALT ID CORCHETEIZQ expr CORCHETEDER {$accessvec = expressions.NewAccessVector($ID.line, $ID.pos, $ID.text, $expr.e)}))) (RULE assignationvecstmt (returns interfaces.Instruction assignvec) (BLOCK (ALT ID CORCHETEIZQ (= expprim expr) CORCHETEDER IG (= expsegundo expr) (? (BLOCK (ALT PTCOMA))) {$assignvec = instructions.NewAssignationVector($ID.line, $ID.pos, $ID.text, $expprim.e, $expsegundo.e)}))) (RULE declarematrixstmt (returns interfaces.Instruction decmatrix) (BLOCK (ALT VAR ID PARIZQ DOUBLEPTS type PARDER IG (? (BLOCK (ALT PTCOMA)))))) (RULE declarefuncstmt (returns interfaces.Instruction decfunc) (BLOCK (ALT FUNC ID PARIZQ listParamsFunc PARDER SUB MAYOR type LLAVEIZQ block LLAVEDER {$decfunc = instructions.NewToDeclareFunction($ID.line, $ID.pos, $ID.text, $listParamsFunc.lf, $type.t, $block.blk, 1)}) (ALT FUNC ID PARIZQ listParamsFunc PARDER LLAVEIZQ block LLAVEDER {
    
    $decfunc = instructions.NewToDeclareFunction($ID.line, $ID.pos, $ID.text, $listParamsFunc.lf, environment.NULL, $block.blk, 2);}) (ALT FUNC ID PARIZQ PARDER SUB MAYOR type LLAVEIZQ block LLAVEDER {$decfunc = instructions.NewToDeclareFunction($ID.line, $ID.pos, $ID.text, nil, $type.t, $block.blk, 3)}) (ALT FUNC ID PARIZQ PARDER LLAVEIZQ block LLAVEDER {
    if($block.blk!=nil){ 
         $decfunc = instructions.NewToDeclareFunction($ID.line, $ID.pos, $ID.text, nil, environment.NULL, $block.blk, 4)
    }
}))) (RULE listParamsFunc (returns []interface{} lf) (BLOCK (ALT (= listf listParamsFunc) COMA parameterfuncstmt {
                    
                                var arrf []interface{}
                                arrf = append($listf.lf, $parameterfuncstmt.parameterfunc)
                                $lf = arrf
                            }) (ALT parameterfuncstmt {
    
            $lf = []interface{}{}
            $lf = append($lf, $parameterfuncstmt.parameterfunc)
        }))) (RULE parameterfuncstmt (returns interfaces.Expression parameterfunc) (BLOCK (ALT (= exte (BLOCK (ALT ID) (ALT GUION_BAJO))) ID DOUBLEPTS type {$parameterfunc = expressions.NewParameters($exte.line, $exte.pos, $type.t, $exte.text,  $ID.text, 1)}) (ALT (= exte (BLOCK (ALT ID) (ALT GUION_BAJO))) ID DOUBLEPTS (? (BLOCK (ALT INOUT))) CORCHETEIZQ type CORCHETEDER {$parameterfunc = expressions.NewParameters($exte.line, $exte.pos, $type.t, $exte.text,  $ID.text,2);}) (ALT ID DOUBLEPTS type {$parameterfunc = expressions.NewParameters($ID.line, $ID.pos, $type.t, "_",  $ID.text, 1)}))) (RULE declarestructstmt (returns interfaces.Instruction decstruct) (BLOCK (ALT STRUCT ID LLAVEIZQ listStruct LLAVEDER { $decstruct = instructions.NewToDeclareStruct($STRUCT.line, $STRUCT.pos, $ID.text, $listStruct.l) }))) (RULE listStruct (returns []interface{} l) (BLOCK (ALT (= list listStruct) VAR ID DOUBLEPTS type {
                            var arr []interface{}
                            newParams := environment.NewStructType($ID.text, $type.t)
                            arr = append($list.l, newParams)
                            $l = arr

}) (ALT VAR ID DOUBLEPTS type {
                        var arr []interface{}
                        newParams := environment.NewStructType($ID.text, $type.t)
                        arr = append(arr, newParams)
                        $l = arr
}) (ALT { $l = []interface{}{} }))) (RULE expr (returns interfaces.Expression e) (BLOCK (ALT (= left expr) (= op (BLOCK (ALT MUL) (ALT DIV))) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (BLOCK (ALT ADD) (ALT SUB) (ALT PERCENT))) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (BLOCK (ALT MAY_IG) (ALT MAYOR))) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (BLOCK (ALT MEN_IG) (ALT MENOR))) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (BLOCK (ALT IG_IG) (ALT DIF))) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op AND) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op OR) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= op NOT) (= left expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $left.e) }) (ALT (= op SUB) (= left expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e,  $op.text, nil)}) (ALT PARIZQ expr PARDER { $e = $expr.e }) (ALT NUMBER {   
        
        if (strings.Contains($NUMBER.text,".")){
           
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,$NUMBER.text,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.INTEGER)
        }
    }) (ALT STRING {
        str := $STRING.text
        $e = expressions.NewPrimitive($STRING.line, $STRING.pos, str[1:len(str)-1],environment.STRING)
    }) (ALT TRUE { $e = expressions.NewPrimitive($TRUE.line, $TRUE.pos, true, environment.BOOLEAN) }) (ALT FALSE { $e = expressions.NewPrimitive($FALSE.line, $FALSE.pos, false, environment.BOOLEAN) }) (ALT NIL { $e = expressions.NewPrimitive($NIL.line, $NIL.pos, nil, environment.NULL) }) (ALT accessstmt {$e = $accessstmt.access}) (ALT emptvecstmt {$e = $emptvecstmt.emptyvec}) (ALT countvecstmt {$e = $countvecstmt.count}) (ALT accessvecstmt {$e = $accessvecstmt.accessvec}) (ALT intfunctionstmt {$e = $intfunctionstmt.intfunc}) (ALT floatfunctionstmt {$e = $floatfunctionstmt.floatfunc}) (ALT stringfunctionstmt {$e = $stringfunctionstmt.stringfunc}) (ALT accessfuncstmt {$e = $accessfuncstmt.funcexp}) (ALT ID (BLOCK (ALT LLAVEIZQ) (ALT PARIZQ)) listStructExp (BLOCK (ALT LLAVEDER) (ALT PARDER)) { $e = expressions.NewStructExp($ID.line, $ID.pos, $ID.text, $listStructExp.l ) }) (ALT accessstructstmt {$e = $accessstructstmt.accessstruct}))) (RULE accessstructstmt (returns interfaces.Expression accessstruct) (BLOCK (ALT (= list ID) POINT ID { $accessstruct = expressions.NewAccessStruct($list.line, $list.pos, $list.text, $ID.text, "nil")  }) (ALT (= list ID) POINT ID POINT (= sec ID) { $accessstruct = expressions.NewAccessStruct($list.line, $list.pos, $list.text, $ID.text, $sec.text)  }))) (RULE accessfuncstmt (returns interfaces.Expression funcexp) (BLOCK (ALT ID PARIZQ listParams PARDER {$funcexp = expressions.NewAccessFunction($ID.line, $ID.pos, $ID.text, $listParams.l, 1)}) (ALT ID PARIZQ PARDER))) (RULE intfunctionstmt (returns interfaces.Expression intfunc) (BLOCK (ALT INTS PARIZQ expr PARDER {$intfunc = expressions.NewFunctionInt($INTS.line, $INTS.pos, $expr.e)}))) (RULE floatfunctionstmt (returns interfaces.Expression floatfunc) (BLOCK (ALT FLOATS PARIZQ expr PARDER {$floatfunc = expressions.NewFunctionFloat($FLOATS.line, $FLOATS.pos, $expr.e)}))) (RULE stringfunctionstmt (returns interfaces.Expression stringfunc) (BLOCK (ALT STRINGS PARIZQ expr PARDER {$stringfunc = expressions.NewFunctionString($STRINGS.line, $STRINGS.pos, $expr.e)}))) (RULE accessstmt (returns interfaces.Expression access) (BLOCK (ALT (= op ID) {$access = expressions.NewAccess($op.line, $op.pos, $op.text)}))) (RULE increaseanddecreasestmt (returns interfaces.Instruction increasedecrease) (BLOCK (ALT ID IG_ADD expr (? (BLOCK (ALT PTCOMA))) {$increasedecrease = instructions.NewIncreaseDecrease($ID.line, $ID.pos, $ID.text, $IG_ADD.text, $expr.e)}) (ALT ID IG_SUB expr (? (BLOCK (ALT PTCOMA))) {$increasedecrease = instructions.NewIncreaseDecrease($ID.line, $ID.pos, $ID.text, $IG_SUB.text, $expr.e)}))) (RULE type (returns environment.TipoExpresion t) (BLOCK (ALT STRINGS {$t = environment.STRING}) (ALT INTS {$t = environment.INTEGER}) (ALT FLOATS {$t = environment.FLOAT}) (ALT BOOLS {$t = environment.BOOLEAN }) (ALT CHARACTERS {$t = environment.CHARACTER}) (ALT ID { $t = environment.STRUCT  }))) (RULE listParams (returns []interface{} l) (BLOCK (ALT (= list listParams) COMA (? (BLOCK (ALT AND_SIMPLE) (ALT ID DOUBLEPTS))) expr {
                                var arr []interface{}
                                arr = append($list.l, $expr.e)
                                $l = arr
                            }) (ALT (? (BLOCK (ALT AND_SIMPLE) (ALT ID DOUBLEPTS))) expr {
            $l = []interface{}{}
            $l = append($l, $expr.e)
        }))) (RULE listStructExp (returns []interface{} l) (BLOCK (ALT (= list listStructExp) (? (BLOCK (ALT COMA))) ID DOUBLEPTS expr {
                                            var arr []interface{}
                                            StrExp := environment.NewStructContent($ID.text, $expr.e)
                                            arr = append($list.l, StrExp)
                                            $l = arr
                                        }) (ALT ID DOUBLEPTS expr {
                    var arr []interface{}
                    StrExp := environment.NewStructContent($ID.text, $expr.e)
                    arr = append(arr, StrExp)
                    $l = arr
                }) (ALT {
        $l = []interface{}{}
    })))))
2023-10-30 17:35:48:201 grammar LogManager.java:25 after: (COMBINED_GRAMMAR Grammar (OPTIONS (= tokenVocab Lex)) (@ header {
    import "Server/Interfaces"
    import "Server/Environment"
    import "Server/Expression"
    import "Server/Instruction"
    import "strings"
}) (RULES (RULE s (returns []interface{} code) (BLOCK (ALT block EOF {$code = $block.blk}))) (RULE block (returns []interface{} blk) (@ init {
$blk = []interface{}{}
    var listInt []IInstructionContext
  }) (BLOCK (ALT (+ (BLOCK (ALT (+= ins instruction)))) {
        listInt = localctx.(*BlockContext).GetIns()
        for _, e := range listInt {
            $blk = append($blk, e.GetInst())
            
        }
    }))) (RULE instruction (returns interfaces.Instruction inst) (BLOCK (ALT printstmt { $inst = $printstmt.prnt}) (ALT declarestmt {$inst = $declarestmt.dec}) (ALT constantstmt {$inst = $constantstmt.const}) (ALT assignationstmt {$inst = $assignationstmt.assign}) (ALT increaseanddecreasestmt {$inst = $increaseanddecreasestmt.increasedecrease}) (ALT ifstmt { $inst = $ifstmt.ift }) (ALT whilestmt {$inst = $whilestmt.while}) (ALT forstmt {$inst = $forstmt.for}) (ALT switchstmt {$inst = $switchstmt.switch}) (ALT guardstmt {$inst = $guardstmt.gua}) (ALT transferstmt {$inst = $transferstmt.tran}) (ALT declarevectorstmt {$inst = $declarevectorstmt.decvec}) (ALT appendstmt {$inst = $appendstmt.app}) (ALT removelaststmt {$inst = $removelaststmt.removl}) (ALT removestmt {$inst = $removestmt.remov}) (ALT assignationvecstmt {$inst = $assignationvecstmt.assignvec}) (ALT declarefuncstmt {$inst = $declarefuncstmt.decfunc}) (ALT accessfuncinstruction {$inst = $accessfuncinstruction.accessfuncin}) (ALT declarestructstmt {$inst = $declarestructstmt.decstruct }) (ALT assignationstructstmt {$inst = $assignationstructstmt.assignstruct}))) (RULE printstmt (returns interfaces.Instruction prnt) (BLOCK (ALT PRINT PARIZQ listParams PARDER (? (BLOCK (ALT PTCOMA))) { $prnt = instructions.NewPrint($PRINT.line, $PRINT.pos, $listParams.l)}))) (RULE declarestmt (returns interfaces.Instruction dec) (BLOCK (ALT VAR ID DOUBLEPTS type IG expr (? (BLOCK (ALT PTCOMA))) {$dec = instructions.NewTodeclare($VAR.line, $VAR.pos, $ID.text, $type.t, $expr.e, false)}) (ALT VAR ID IG expr (? (BLOCK (ALT PTCOMA))) {$dec = instructions.NewTodeclare($VAR.line, $VAR.pos, $ID.text, environment.NULL, $expr.e, false)}) (ALT VAR ID DOUBLEPTS type QUESTION (? (BLOCK (ALT PTCOMA))) {$dec = instructions.NewTodeclare($VAR.line, $VAR.pos, $ID.text, $type.t, nil, false)}))) (RULE constantstmt (returns interfaces.Instruction const) (BLOCK (ALT LET ID DOUBLEPTS type IG expr (? (BLOCK (ALT PTCOMA))) {$const = instructions.NewTodeclare($LET.line, $LET.pos, $ID.text, $type.t, $expr.e, true)}) (ALT LET ID IG expr (? (BLOCK (ALT PTCOMA))) {$const = instructions.NewTodeclare($LET.line, $LET.pos, $ID.text, environment.NULL, $expr.e, true)}))) (RULE blockelifs (returns []interface{} blkef) (@ init {
$blkef = []interface{}{}
    var listifs []IIfstmtContext
    
  }) (BLOCK (ALT (+ (BLOCK (ALT (+= elif ifstmt)))) {   
        listifs = localctx.(*BlockelifsContext).GetElif()
        for _, a := range listifs {
            $blkef = append($blkef, a.GetIft())
            
        }
    }))) (RULE ifstmt (returns interfaces.Instruction ift, []interface{} el, interfaces.Instruction else) (BLOCK (ALT IF expr LLAVEIZQ (= ifb block) LLAVEDER { $ift = instructions.NewIf($IF.line, $IF.pos, $expr.e, $ifb.blk, nil); 
                                        $el = $ifb.blk}) (ALT IF expr LLAVEIZQ (= ifelseblck block) LLAVEDER ELSE LLAVEIZQ (= elseifblck block) LLAVEDER { $ift = instructions.NewIf($IF.line, $IF.pos, $expr.e, $ifelseblck.blk, $elseifblck.blk); 
                                                                                        $el = $ifelseblck.blk;
                                                                                        
                                                                                        }) (ALT IF expr LLAVEIZQ (= elif block) LLAVEDER ELSE blockelifs { $ift = instructions.NewIf($IF.line, $IF.pos, $expr.e, $elif.blk, $blockelifs.blkef); }))) (RULE switchstmt (returns interfaces.Instruction switch) (BLOCK (ALT SWITCH expr LLAVEIZQ DEFAULT DOUBLEPTS block LLAVEDER { $switch = instructions.NewSwitch($SWITCH.line, $SWITCH.pos, $expr.e, nil,  nil, $block.blk);}) (ALT SWITCH expr LLAVEIZQ casestmt LLAVEDER {$switch = instructions.NewSwitch($SWITCH.line, $SWITCH.pos, $expr.e, nil, $casestmt.cas, nil);}))) (RULE casestmt (returns interfaces.Instruction cas) (BLOCK (ALT CASE expr DOUBLEPTS block blockcases { $cas = instructions.NewCase($CASE.line,$CASE.pos, $expr.e,$block.blk, $blockcases.blkcase)
                                }) (ALT CASE expr DOUBLEPTS (= sen block) DEFAULT DOUBLEPTS (= def block) { $cas = instructions.NewCase($CASE.line,$CASE.pos, $expr.e,$sen.blk, $def.blk)}))) (RULE blockcases (returns []interface{} blkcase) (@ init {
    $blkcase = []interface{}{}
    var listcases []ICasestmtContext
  }) (BLOCK (ALT (+ (BLOCK (ALT (+= casedef casestmt)))) {
        listcases = localctx.(*BlockcasesContext).GetCasedef()
        for _, a := range listcases {
            $blkcase = append($blkcase, a.GetCas())
      
        }
    }))) (RULE assignationstmt (returns interfaces.Instruction assign) (BLOCK (ALT ID IG expr (? (BLOCK (ALT PTCOMA))) {$assign = instructions.NewAssignation($ID.line, $ID.pos,  $ID.text, $expr.e)}))) (RULE assignationstructstmt (returns interfaces.Instruction assignstruct) (BLOCK (ALT ID POINT (= second ID) IG expr (? (BLOCK (ALT PTCOMA))) {$assignstruct = instructions.NewAssignationStruct($ID.line, $ID.pos, $ID.text, $second.text, $expr.e)}))) (RULE whilestmt (returns interfaces.Instruction while) (BLOCK (ALT WHILE expr LLAVEIZQ block LLAVEDER {$while = instructions.NewWhile($WHILE.line, $WHILE.pos,  $expr.e, $block.blk)}))) (RULE forstmt (returns interfaces.Instruction for) (BLOCK (ALT FOR ID IN expr LLAVEIZQ block LLAVEDER {$for = instructions.NewFor($FOR.line, $FOR.pos, $ID.text, $expr.e, nil, $block.blk)}) (ALT FOR ID IN (= first expr) POINT POINT (= second expr) LLAVEIZQ block LLAVEDER {$for = instructions.NewFor($FOR.line, $FOR.pos, $ID.text, $first.e, $second.e, $block.blk)}))) (RULE guardstmt (returns interfaces.Instruction gua) (BLOCK (ALT GUARD expr ELSE LLAVEIZQ block LLAVEDER {$gua = instructions.NewGuard($GUARD.line, $GUARD.pos, $expr.e, $block.blk)}))) (RULE transferstmt (returns interfaces.Instruction tran) (BLOCK (ALT RETURN (? (BLOCK (ALT PTCOMA))) {$tran = instructions.NewReturnIn($RETURN.line, $RETURN.pos, nil)}) (ALT RETURN expr (? (BLOCK (ALT PTCOMA))) {$tran = instructions.NewReturnIn($RETURN.line, $RETURN.pos, $expr.e)}) (ALT CONTINUE (? (BLOCK (ALT PTCOMA))) {$tran = instructions.NewContinue($CONTINUE.line, $CONTINUE.pos)}) (ALT BREAK (? (BLOCK (ALT PTCOMA))) {$tran = instructions.NewBreak($BREAK.line, $BREAK.pos)}))) (RULE declarevectorstmt (returns interfaces.Instruction decvec) (BLOCK (ALT VAR ID DOUBLEPTS CORCHETEIZQ type CORCHETEDER IG CORCHETEIZQ listParams CORCHETEDER (? (BLOCK (ALT PTCOMA))) {$decvec = instructions.NewToDeclareVector($VAR.line, $VAR.pos, $ID.text, $type.t, $listParams.l, "")}) (ALT VAR ID DOUBLEPTS CORCHETEIZQ type CORCHETEDER IG CORCHETEIZQ CORCHETEDER (? (BLOCK (ALT PTCOMA))) {$decvec = instructions.NewToDeclareVector($VAR.line, $VAR.pos, $ID.text, $type.t, nil, "")}) (ALT VAR ID IG CORCHETEIZQ type CORCHETEDER PARIZQ PARDER (? (BLOCK (ALT PTCOMA)))) (ALT VAR (= F ID) DOUBLEPTS CORCHETEIZQ type CORCHETEDER IG (= S ID) (? (BLOCK (ALT PTCOMA))) {$decvec = instructions.NewToDeclareVector($VAR.line, $VAR.pos, $F.text, $type.t, nil, $S.text)}))) (RULE accessfuncinstruction (returns interfaces.Instruction accessfuncin) (BLOCK (ALT ID PARIZQ listParams PARDER PTCOMA {$accessfuncin = instructions.NewCallFunction($ID.line, $ID.pos, $ID.text, $listParams.l, 1)}))) (RULE appendstmt (returns interfaces.Instruction app) (BLOCK (ALT ID POINT APPEND PARIZQ expr PARDER (? (BLOCK (ALT PTCOMA))) {$app = instructions.NewAppend($ID.line, $ID.pos, $ID.text, $expr.e)}))) (RULE removelaststmt (returns interfaces.Instruction removl) (BLOCK (ALT ID POINT REMOVELAST PARIZQ PARDER (? (BLOCK (ALT PTCOMA))) {$removl = instructions.NewRemoveLast($ID.line, $ID.pos, $ID.text)}))) (RULE removestmt (returns interfaces.Instruction remov) (BLOCK (ALT ID POINT REMOVE PARIZQ AT DOUBLEPTS expr PARDER (? (BLOCK (ALT PTCOMA))) {$remov = instructions.NewRemove($ID.line, $ID.pos, $ID.text, $expr.e)}))) (RULE emptvecstmt (returns interfaces.Expression emptyvec) (BLOCK (ALT ID POINT ISEMPTY {$emptyvec = expressions.NewEmptyVector($ID.line, $ID.pos, $ID.text)}))) (RULE countvecstmt (returns interfaces.Expression count) (BLOCK (ALT ID POINT COUNT {$count = expressions.NewCount($ID.line, $ID.pos, $ID.text)}))) (RULE accessvecstmt (returns interfaces.Expression accessvec) (BLOCK (ALT ID CORCHETEIZQ expr CORCHETEDER {$accessvec = expressions.NewAccessVector($ID.line, $ID.pos, $ID.text, $expr.e)}))) (RULE assignationvecstmt (returns interfaces.Instruction assignvec) (BLOCK (ALT ID CORCHETEIZQ (= expprim expr) CORCHETEDER IG (= expsegundo expr) (? (BLOCK (ALT PTCOMA))) {$assignvec = instructions.NewAssignationVector($ID.line, $ID.pos, $ID.text, $expprim.e, $expsegundo.e)}))) (RULE declarematrixstmt (returns interfaces.Instruction decmatrix) (BLOCK (ALT VAR ID PARIZQ DOUBLEPTS type PARDER IG (? (BLOCK (ALT PTCOMA)))))) (RULE declarefuncstmt (returns interfaces.Instruction decfunc) (BLOCK (ALT FUNC ID PARIZQ listParamsFunc PARDER SUB MAYOR type LLAVEIZQ block LLAVEDER {$decfunc = instructions.NewToDeclareFunction($ID.line, $ID.pos, $ID.text, $listParamsFunc.lf, $type.t, $block.blk, 1)}) (ALT FUNC ID PARIZQ listParamsFunc PARDER LLAVEIZQ block LLAVEDER {
    
    $decfunc = instructions.NewToDeclareFunction($ID.line, $ID.pos, $ID.text, $listParamsFunc.lf, environment.NULL, $block.blk, 2);}) (ALT FUNC ID PARIZQ PARDER SUB MAYOR type LLAVEIZQ block LLAVEDER {$decfunc = instructions.NewToDeclareFunction($ID.line, $ID.pos, $ID.text, nil, $type.t, $block.blk, 3)}) (ALT FUNC ID PARIZQ PARDER LLAVEIZQ block LLAVEDER {
    if($block.blk!=nil){ 
         $decfunc = instructions.NewToDeclareFunction($ID.line, $ID.pos, $ID.text, nil, environment.NULL, $block.blk, 4)
    }
}))) (RULE listParamsFunc (returns []interface{} lf) (BLOCK (ALT (= listf listParamsFunc) COMA parameterfuncstmt {
                    
                                var arrf []interface{}
                                arrf = append($listf.lf, $parameterfuncstmt.parameterfunc)
                                $lf = arrf
                            }) (ALT parameterfuncstmt {
    
            $lf = []interface{}{}
            $lf = append($lf, $parameterfuncstmt.parameterfunc)
        }))) (RULE parameterfuncstmt (returns interfaces.Expression parameterfunc) (BLOCK (ALT (= exte (SET ID GUION_BAJO)) ID DOUBLEPTS type {$parameterfunc = expressions.NewParameters($exte.line, $exte.pos, $type.t, $exte.text,  $ID.text, 1)}) (ALT (= exte (SET ID GUION_BAJO)) ID DOUBLEPTS (? (BLOCK (ALT INOUT))) CORCHETEIZQ type CORCHETEDER {$parameterfunc = expressions.NewParameters($exte.line, $exte.pos, $type.t, $exte.text,  $ID.text,2);}) (ALT ID DOUBLEPTS type {$parameterfunc = expressions.NewParameters($ID.line, $ID.pos, $type.t, "_",  $ID.text, 1)}))) (RULE declarestructstmt (returns interfaces.Instruction decstruct) (BLOCK (ALT STRUCT ID LLAVEIZQ listStruct LLAVEDER { $decstruct = instructions.NewToDeclareStruct($STRUCT.line, $STRUCT.pos, $ID.text, $listStruct.l) }))) (RULE listStruct (returns []interface{} l) (BLOCK (ALT (= list listStruct) VAR ID DOUBLEPTS type {
                            var arr []interface{}
                            newParams := environment.NewStructType($ID.text, $type.t)
                            arr = append($list.l, newParams)
                            $l = arr

}) (ALT VAR ID DOUBLEPTS type {
                        var arr []interface{}
                        newParams := environment.NewStructType($ID.text, $type.t)
                        arr = append(arr, newParams)
                        $l = arr
}) (ALT { $l = []interface{}{} }))) (RULE expr (returns interfaces.Expression e) (BLOCK (ALT (= left expr) (= op (SET MUL DIV)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET ADD SUB PERCENT)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET MAY_IG MAYOR)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET MEN_IG MENOR)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET IG_IG DIF)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op AND) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op OR) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= op NOT) (= left expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $left.e) }) (ALT (= op SUB) (= left expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e,  $op.text, nil)}) (ALT PARIZQ expr PARDER { $e = $expr.e }) (ALT NUMBER {   
        
        if (strings.Contains($NUMBER.text,".")){
           
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,$NUMBER.text,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.INTEGER)
        }
    }) (ALT STRING {
        str := $STRING.text
        $e = expressions.NewPrimitive($STRING.line, $STRING.pos, str[1:len(str)-1],environment.STRING)
    }) (ALT TRUE { $e = expressions.NewPrimitive($TRUE.line, $TRUE.pos, true, environment.BOOLEAN) }) (ALT FALSE { $e = expressions.NewPrimitive($FALSE.line, $FALSE.pos, false, environment.BOOLEAN) }) (ALT NIL { $e = expressions.NewPrimitive($NIL.line, $NIL.pos, nil, environment.NULL) }) (ALT accessstmt {$e = $accessstmt.access}) (ALT emptvecstmt {$e = $emptvecstmt.emptyvec}) (ALT countvecstmt {$e = $countvecstmt.count}) (ALT accessvecstmt {$e = $accessvecstmt.accessvec}) (ALT intfunctionstmt {$e = $intfunctionstmt.intfunc}) (ALT floatfunctionstmt {$e = $floatfunctionstmt.floatfunc}) (ALT stringfunctionstmt {$e = $stringfunctionstmt.stringfunc}) (ALT accessfuncstmt {$e = $accessfuncstmt.funcexp}) (ALT ID (SET LLAVEIZQ PARIZQ) listStructExp (SET LLAVEDER PARDER) { $e = expressions.NewStructExp($ID.line, $ID.pos, $ID.text, $listStructExp.l ) }) (ALT accessstructstmt {$e = $accessstructstmt.accessstruct}))) (RULE accessstructstmt (returns interfaces.Expression accessstruct) (BLOCK (ALT (= list ID) POINT ID { $accessstruct = expressions.NewAccessStruct($list.line, $list.pos, $list.text, $ID.text, "nil")  }) (ALT (= list ID) POINT ID POINT (= sec ID) { $accessstruct = expressions.NewAccessStruct($list.line, $list.pos, $list.text, $ID.text, $sec.text)  }))) (RULE accessfuncstmt (returns interfaces.Expression funcexp) (BLOCK (ALT ID PARIZQ listParams PARDER {$funcexp = expressions.NewAccessFunction($ID.line, $ID.pos, $ID.text, $listParams.l, 1)}) (ALT ID PARIZQ PARDER))) (RULE intfunctionstmt (returns interfaces.Expression intfunc) (BLOCK (ALT INTS PARIZQ expr PARDER {$intfunc = expressions.NewFunctionInt($INTS.line, $INTS.pos, $expr.e)}))) (RULE floatfunctionstmt (returns interfaces.Expression floatfunc) (BLOCK (ALT FLOATS PARIZQ expr PARDER {$floatfunc = expressions.NewFunctionFloat($FLOATS.line, $FLOATS.pos, $expr.e)}))) (RULE stringfunctionstmt (returns interfaces.Expression stringfunc) (BLOCK (ALT STRINGS PARIZQ expr PARDER {$stringfunc = expressions.NewFunctionString($STRINGS.line, $STRINGS.pos, $expr.e)}))) (RULE accessstmt (returns interfaces.Expression access) (BLOCK (ALT (= op ID) {$access = expressions.NewAccess($op.line, $op.pos, $op.text)}))) (RULE increaseanddecreasestmt (returns interfaces.Instruction increasedecrease) (BLOCK (ALT ID IG_ADD expr (? (BLOCK (ALT PTCOMA))) {$increasedecrease = instructions.NewIncreaseDecrease($ID.line, $ID.pos, $ID.text, $IG_ADD.text, $expr.e)}) (ALT ID IG_SUB expr (? (BLOCK (ALT PTCOMA))) {$increasedecrease = instructions.NewIncreaseDecrease($ID.line, $ID.pos, $ID.text, $IG_SUB.text, $expr.e)}))) (RULE type (returns environment.TipoExpresion t) (BLOCK (ALT STRINGS {$t = environment.STRING}) (ALT INTS {$t = environment.INTEGER}) (ALT FLOATS {$t = environment.FLOAT}) (ALT BOOLS {$t = environment.BOOLEAN }) (ALT CHARACTERS {$t = environment.CHARACTER}) (ALT ID { $t = environment.STRUCT  }))) (RULE listParams (returns []interface{} l) (BLOCK (ALT (= list listParams) COMA (? (BLOCK (ALT AND_SIMPLE) (ALT ID DOUBLEPTS))) expr {
                                var arr []interface{}
                                arr = append($list.l, $expr.e)
                                $l = arr
                            }) (ALT (? (BLOCK (ALT AND_SIMPLE) (ALT ID DOUBLEPTS))) expr {
            $l = []interface{}{}
            $l = append($l, $expr.e)
        }))) (RULE listStructExp (returns []interface{} l) (BLOCK (ALT (= list listStructExp) (? (BLOCK (ALT COMA))) ID DOUBLEPTS expr {
                                            var arr []interface{}
                                            StrExp := environment.NewStructContent($ID.text, $expr.e)
                                            arr = append($list.l, StrExp)
                                            $l = arr
                                        }) (ALT ID DOUBLEPTS expr {
                    var arr []interface{}
                    StrExp := environment.NewStructContent($ID.text, $expr.e)
                    arr = append(arr, StrExp)
                    $l = arr
                }) (ALT {
        $l = []interface{}{}
    })))))
2023-10-30 17:35:48:206 grammar LogManager.java:25 after extract implicit lexer =(COMBINED_GRAMMAR Grammar (OPTIONS (= tokenVocab Lex)) (@ header {
    import "Server/Interfaces"
    import "Server/Environment"
    import "Server/Expression"
    import "Server/Instruction"
    import "strings"
}) (RULES (RULE s (returns []interface{} code) (BLOCK (ALT block EOF {$code = $block.blk}))) (RULE block (returns []interface{} blk) (@ init {
$blk = []interface{}{}
    var listInt []IInstructionContext
  }) (BLOCK (ALT (+ (BLOCK (ALT (+= ins instruction)))) {
        listInt = localctx.(*BlockContext).GetIns()
        for _, e := range listInt {
            $blk = append($blk, e.GetInst())
            
        }
    }))) (RULE instruction (returns interfaces.Instruction inst) (BLOCK (ALT printstmt { $inst = $printstmt.prnt}) (ALT declarestmt {$inst = $declarestmt.dec}) (ALT constantstmt {$inst = $constantstmt.const}) (ALT assignationstmt {$inst = $assignationstmt.assign}) (ALT increaseanddecreasestmt {$inst = $increaseanddecreasestmt.increasedecrease}) (ALT ifstmt { $inst = $ifstmt.ift }) (ALT whilestmt {$inst = $whilestmt.while}) (ALT forstmt {$inst = $forstmt.for}) (ALT switchstmt {$inst = $switchstmt.switch}) (ALT guardstmt {$inst = $guardstmt.gua}) (ALT transferstmt {$inst = $transferstmt.tran}) (ALT declarevectorstmt {$inst = $declarevectorstmt.decvec}) (ALT appendstmt {$inst = $appendstmt.app}) (ALT removelaststmt {$inst = $removelaststmt.removl}) (ALT removestmt {$inst = $removestmt.remov}) (ALT assignationvecstmt {$inst = $assignationvecstmt.assignvec}) (ALT declarefuncstmt {$inst = $declarefuncstmt.decfunc}) (ALT accessfuncinstruction {$inst = $accessfuncinstruction.accessfuncin}) (ALT declarestructstmt {$inst = $declarestructstmt.decstruct }) (ALT assignationstructstmt {$inst = $assignationstructstmt.assignstruct}))) (RULE printstmt (returns interfaces.Instruction prnt) (BLOCK (ALT PRINT PARIZQ listParams PARDER (? (BLOCK (ALT PTCOMA))) { $prnt = instructions.NewPrint($PRINT.line, $PRINT.pos, $listParams.l)}))) (RULE declarestmt (returns interfaces.Instruction dec) (BLOCK (ALT VAR ID DOUBLEPTS type IG expr (? (BLOCK (ALT PTCOMA))) {$dec = instructions.NewTodeclare($VAR.line, $VAR.pos, $ID.text, $type.t, $expr.e, false)}) (ALT VAR ID IG expr (? (BLOCK (ALT PTCOMA))) {$dec = instructions.NewTodeclare($VAR.line, $VAR.pos, $ID.text, environment.NULL, $expr.e, false)}) (ALT VAR ID DOUBLEPTS type QUESTION (? (BLOCK (ALT PTCOMA))) {$dec = instructions.NewTodeclare($VAR.line, $VAR.pos, $ID.text, $type.t, nil, false)}))) (RULE constantstmt (returns interfaces.Instruction const) (BLOCK (ALT LET ID DOUBLEPTS type IG expr (? (BLOCK (ALT PTCOMA))) {$const = instructions.NewTodeclare($LET.line, $LET.pos, $ID.text, $type.t, $expr.e, true)}) (ALT LET ID IG expr (? (BLOCK (ALT PTCOMA))) {$const = instructions.NewTodeclare($LET.line, $LET.pos, $ID.text, environment.NULL, $expr.e, true)}))) (RULE blockelifs (returns []interface{} blkef) (@ init {
$blkef = []interface{}{}
    var listifs []IIfstmtContext
    
  }) (BLOCK (ALT (+ (BLOCK (ALT (+= elif ifstmt)))) {   
        listifs = localctx.(*BlockelifsContext).GetElif()
        for _, a := range listifs {
            $blkef = append($blkef, a.GetIft())
            
        }
    }))) (RULE ifstmt (returns interfaces.Instruction ift, []interface{} el, interfaces.Instruction else) (BLOCK (ALT IF expr LLAVEIZQ (= ifb block) LLAVEDER { $ift = instructions.NewIf($IF.line, $IF.pos, $expr.e, $ifb.blk, nil); 
                                        $el = $ifb.blk}) (ALT IF expr LLAVEIZQ (= ifelseblck block) LLAVEDER ELSE LLAVEIZQ (= elseifblck block) LLAVEDER { $ift = instructions.NewIf($IF.line, $IF.pos, $expr.e, $ifelseblck.blk, $elseifblck.blk); 
                                                                                        $el = $ifelseblck.blk;
                                                                                        
                                                                                        }) (ALT IF expr LLAVEIZQ (= elif block) LLAVEDER ELSE blockelifs { $ift = instructions.NewIf($IF.line, $IF.pos, $expr.e, $elif.blk, $blockelifs.blkef); }))) (RULE switchstmt (returns interfaces.Instruction switch) (BLOCK (ALT SWITCH expr LLAVEIZQ DEFAULT DOUBLEPTS block LLAVEDER { $switch = instructions.NewSwitch($SWITCH.line, $SWITCH.pos, $expr.e, nil,  nil, $block.blk);}) (ALT SWITCH expr LLAVEIZQ casestmt LLAVEDER {$switch = instructions.NewSwitch($SWITCH.line, $SWITCH.pos, $expr.e, nil, $casestmt.cas, nil);}))) (RULE casestmt (returns interfaces.Instruction cas) (BLOCK (ALT CASE expr DOUBLEPTS block blockcases { $cas = instructions.NewCase($CASE.line,$CASE.pos, $expr.e,$block.blk, $blockcases.blkcase)
                                }) (ALT CASE expr DOUBLEPTS (= sen block) DEFAULT DOUBLEPTS (= def block) { $cas = instructions.NewCase($CASE.line,$CASE.pos, $expr.e,$sen.blk, $def.blk)}))) (RULE blockcases (returns []interface{} blkcase) (@ init {
    $blkcase = []interface{}{}
    var listcases []ICasestmtContext
  }) (BLOCK (ALT (+ (BLOCK (ALT (+= casedef casestmt)))) {
        listcases = localctx.(*BlockcasesContext).GetCasedef()
        for _, a := range listcases {
            $blkcase = append($blkcase, a.GetCas())
      
        }
    }))) (RULE assignationstmt (returns interfaces.Instruction assign) (BLOCK (ALT ID IG expr (? (BLOCK (ALT PTCOMA))) {$assign = instructions.NewAssignation($ID.line, $ID.pos,  $ID.text, $expr.e)}))) (RULE assignationstructstmt (returns interfaces.Instruction assignstruct) (BLOCK (ALT ID POINT (= second ID) IG expr (? (BLOCK (ALT PTCOMA))) {$assignstruct = instructions.NewAssignationStruct($ID.line, $ID.pos, $ID.text, $second.text, $expr.e)}))) (RULE whilestmt (returns interfaces.Instruction while) (BLOCK (ALT WHILE expr LLAVEIZQ block LLAVEDER {$while = instructions.NewWhile($WHILE.line, $WHILE.pos,  $expr.e, $block.blk)}))) (RULE forstmt (returns interfaces.Instruction for) (BLOCK (ALT FOR ID IN expr LLAVEIZQ block LLAVEDER {$for = instructions.NewFor($FOR.line, $FOR.pos, $ID.text, $expr.e, nil, $block.blk)}) (ALT FOR ID IN (= first expr) POINT POINT (= second expr) LLAVEIZQ block LLAVEDER {$for = instructions.NewFor($FOR.line, $FOR.pos, $ID.text, $first.e, $second.e, $block.blk)}))) (RULE guardstmt (returns interfaces.Instruction gua) (BLOCK (ALT GUARD expr ELSE LLAVEIZQ block LLAVEDER {$gua = instructions.NewGuard($GUARD.line, $GUARD.pos, $expr.e, $block.blk)}))) (RULE transferstmt (returns interfaces.Instruction tran) (BLOCK (ALT RETURN (? (BLOCK (ALT PTCOMA))) {$tran = instructions.NewReturnIn($RETURN.line, $RETURN.pos, nil)}) (ALT RETURN expr (? (BLOCK (ALT PTCOMA))) {$tran = instructions.NewReturnIn($RETURN.line, $RETURN.pos, $expr.e)}) (ALT CONTINUE (? (BLOCK (ALT PTCOMA))) {$tran = instructions.NewContinue($CONTINUE.line, $CONTINUE.pos)}) (ALT BREAK (? (BLOCK (ALT PTCOMA))) {$tran = instructions.NewBreak($BREAK.line, $BREAK.pos)}))) (RULE declarevectorstmt (returns interfaces.Instruction decvec) (BLOCK (ALT VAR ID DOUBLEPTS CORCHETEIZQ type CORCHETEDER IG CORCHETEIZQ listParams CORCHETEDER (? (BLOCK (ALT PTCOMA))) {$decvec = instructions.NewToDeclareVector($VAR.line, $VAR.pos, $ID.text, $type.t, $listParams.l, "")}) (ALT VAR ID DOUBLEPTS CORCHETEIZQ type CORCHETEDER IG CORCHETEIZQ CORCHETEDER (? (BLOCK (ALT PTCOMA))) {$decvec = instructions.NewToDeclareVector($VAR.line, $VAR.pos, $ID.text, $type.t, nil, "")}) (ALT VAR ID IG CORCHETEIZQ type CORCHETEDER PARIZQ PARDER (? (BLOCK (ALT PTCOMA)))) (ALT VAR (= F ID) DOUBLEPTS CORCHETEIZQ type CORCHETEDER IG (= S ID) (? (BLOCK (ALT PTCOMA))) {$decvec = instructions.NewToDeclareVector($VAR.line, $VAR.pos, $F.text, $type.t, nil, $S.text)}))) (RULE accessfuncinstruction (returns interfaces.Instruction accessfuncin) (BLOCK (ALT ID PARIZQ listParams PARDER PTCOMA {$accessfuncin = instructions.NewCallFunction($ID.line, $ID.pos, $ID.text, $listParams.l, 1)}))) (RULE appendstmt (returns interfaces.Instruction app) (BLOCK (ALT ID POINT APPEND PARIZQ expr PARDER (? (BLOCK (ALT PTCOMA))) {$app = instructions.NewAppend($ID.line, $ID.pos, $ID.text, $expr.e)}))) (RULE removelaststmt (returns interfaces.Instruction removl) (BLOCK (ALT ID POINT REMOVELAST PARIZQ PARDER (? (BLOCK (ALT PTCOMA))) {$removl = instructions.NewRemoveLast($ID.line, $ID.pos, $ID.text)}))) (RULE removestmt (returns interfaces.Instruction remov) (BLOCK (ALT ID POINT REMOVE PARIZQ AT DOUBLEPTS expr PARDER (? (BLOCK (ALT PTCOMA))) {$remov = instructions.NewRemove($ID.line, $ID.pos, $ID.text, $expr.e)}))) (RULE emptvecstmt (returns interfaces.Expression emptyvec) (BLOCK (ALT ID POINT ISEMPTY {$emptyvec = expressions.NewEmptyVector($ID.line, $ID.pos, $ID.text)}))) (RULE countvecstmt (returns interfaces.Expression count) (BLOCK (ALT ID POINT COUNT {$count = expressions.NewCount($ID.line, $ID.pos, $ID.text)}))) (RULE accessvecstmt (returns interfaces.Expression accessvec) (BLOCK (ALT ID CORCHETEIZQ expr CORCHETEDER {$accessvec = expressions.NewAccessVector($ID.line, $ID.pos, $ID.text, $expr.e)}))) (RULE assignationvecstmt (returns interfaces.Instruction assignvec) (BLOCK (ALT ID CORCHETEIZQ (= expprim expr) CORCHETEDER IG (= expsegundo expr) (? (BLOCK (ALT PTCOMA))) {$assignvec = instructions.NewAssignationVector($ID.line, $ID.pos, $ID.text, $expprim.e, $expsegundo.e)}))) (RULE declarematrixstmt (returns interfaces.Instruction decmatrix) (BLOCK (ALT VAR ID PARIZQ DOUBLEPTS type PARDER IG (? (BLOCK (ALT PTCOMA)))))) (RULE declarefuncstmt (returns interfaces.Instruction decfunc) (BLOCK (ALT FUNC ID PARIZQ listParamsFunc PARDER SUB MAYOR type LLAVEIZQ block LLAVEDER {$decfunc = instructions.NewToDeclareFunction($ID.line, $ID.pos, $ID.text, $listParamsFunc.lf, $type.t, $block.blk, 1)}) (ALT FUNC ID PARIZQ listParamsFunc PARDER LLAVEIZQ block LLAVEDER {
    
    $decfunc = instructions.NewToDeclareFunction($ID.line, $ID.pos, $ID.text, $listParamsFunc.lf, environment.NULL, $block.blk, 2);}) (ALT FUNC ID PARIZQ PARDER SUB MAYOR type LLAVEIZQ block LLAVEDER {$decfunc = instructions.NewToDeclareFunction($ID.line, $ID.pos, $ID.text, nil, $type.t, $block.blk, 3)}) (ALT FUNC ID PARIZQ PARDER LLAVEIZQ block LLAVEDER {
    if($block.blk!=nil){ 
         $decfunc = instructions.NewToDeclareFunction($ID.line, $ID.pos, $ID.text, nil, environment.NULL, $block.blk, 4)
    }
}))) (RULE listParamsFunc (returns []interface{} lf) (BLOCK (ALT (= listf listParamsFunc) COMA parameterfuncstmt {
                    
                                var arrf []interface{}
                                arrf = append($listf.lf, $parameterfuncstmt.parameterfunc)
                                $lf = arrf
                            }) (ALT parameterfuncstmt {
    
            $lf = []interface{}{}
            $lf = append($lf, $parameterfuncstmt.parameterfunc)
        }))) (RULE parameterfuncstmt (returns interfaces.Expression parameterfunc) (BLOCK (ALT (= exte (SET ID GUION_BAJO)) ID DOUBLEPTS type {$parameterfunc = expressions.NewParameters($exte.line, $exte.pos, $type.t, $exte.text,  $ID.text, 1)}) (ALT (= exte (SET ID GUION_BAJO)) ID DOUBLEPTS (? (BLOCK (ALT INOUT))) CORCHETEIZQ type CORCHETEDER {$parameterfunc = expressions.NewParameters($exte.line, $exte.pos, $type.t, $exte.text,  $ID.text,2);}) (ALT ID DOUBLEPTS type {$parameterfunc = expressions.NewParameters($ID.line, $ID.pos, $type.t, "_",  $ID.text, 1)}))) (RULE declarestructstmt (returns interfaces.Instruction decstruct) (BLOCK (ALT STRUCT ID LLAVEIZQ listStruct LLAVEDER { $decstruct = instructions.NewToDeclareStruct($STRUCT.line, $STRUCT.pos, $ID.text, $listStruct.l) }))) (RULE listStruct (returns []interface{} l) (BLOCK (ALT (= list listStruct) VAR ID DOUBLEPTS type {
                            var arr []interface{}
                            newParams := environment.NewStructType($ID.text, $type.t)
                            arr = append($list.l, newParams)
                            $l = arr

}) (ALT VAR ID DOUBLEPTS type {
                        var arr []interface{}
                        newParams := environment.NewStructType($ID.text, $type.t)
                        arr = append(arr, newParams)
                        $l = arr
}) (ALT { $l = []interface{}{} }))) (RULE expr (returns interfaces.Expression e) (BLOCK (ALT (= left expr) (= op (SET MUL DIV)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET ADD SUB PERCENT)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET MAY_IG MAYOR)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET MEN_IG MENOR)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET IG_IG DIF)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op AND) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op OR) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= op NOT) (= left expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $left.e) }) (ALT (= op SUB) (= left expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e,  $op.text, nil)}) (ALT PARIZQ expr PARDER { $e = $expr.e }) (ALT NUMBER {   
        
        if (strings.Contains($NUMBER.text,".")){
           
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,$NUMBER.text,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.INTEGER)
        }
    }) (ALT STRING {
        str := $STRING.text
        $e = expressions.NewPrimitive($STRING.line, $STRING.pos, str[1:len(str)-1],environment.STRING)
    }) (ALT TRUE { $e = expressions.NewPrimitive($TRUE.line, $TRUE.pos, true, environment.BOOLEAN) }) (ALT FALSE { $e = expressions.NewPrimitive($FALSE.line, $FALSE.pos, false, environment.BOOLEAN) }) (ALT NIL { $e = expressions.NewPrimitive($NIL.line, $NIL.pos, nil, environment.NULL) }) (ALT accessstmt {$e = $accessstmt.access}) (ALT emptvecstmt {$e = $emptvecstmt.emptyvec}) (ALT countvecstmt {$e = $countvecstmt.count}) (ALT accessvecstmt {$e = $accessvecstmt.accessvec}) (ALT intfunctionstmt {$e = $intfunctionstmt.intfunc}) (ALT floatfunctionstmt {$e = $floatfunctionstmt.floatfunc}) (ALT stringfunctionstmt {$e = $stringfunctionstmt.stringfunc}) (ALT accessfuncstmt {$e = $accessfuncstmt.funcexp}) (ALT ID (SET LLAVEIZQ PARIZQ) listStructExp (SET LLAVEDER PARDER) { $e = expressions.NewStructExp($ID.line, $ID.pos, $ID.text, $listStructExp.l ) }) (ALT accessstructstmt {$e = $accessstructstmt.accessstruct}))) (RULE accessstructstmt (returns interfaces.Expression accessstruct) (BLOCK (ALT (= list ID) POINT ID { $accessstruct = expressions.NewAccessStruct($list.line, $list.pos, $list.text, $ID.text, "nil")  }) (ALT (= list ID) POINT ID POINT (= sec ID) { $accessstruct = expressions.NewAccessStruct($list.line, $list.pos, $list.text, $ID.text, $sec.text)  }))) (RULE accessfuncstmt (returns interfaces.Expression funcexp) (BLOCK (ALT ID PARIZQ listParams PARDER {$funcexp = expressions.NewAccessFunction($ID.line, $ID.pos, $ID.text, $listParams.l, 1)}) (ALT ID PARIZQ PARDER))) (RULE intfunctionstmt (returns interfaces.Expression intfunc) (BLOCK (ALT INTS PARIZQ expr PARDER {$intfunc = expressions.NewFunctionInt($INTS.line, $INTS.pos, $expr.e)}))) (RULE floatfunctionstmt (returns interfaces.Expression floatfunc) (BLOCK (ALT FLOATS PARIZQ expr PARDER {$floatfunc = expressions.NewFunctionFloat($FLOATS.line, $FLOATS.pos, $expr.e)}))) (RULE stringfunctionstmt (returns interfaces.Expression stringfunc) (BLOCK (ALT STRINGS PARIZQ expr PARDER {$stringfunc = expressions.NewFunctionString($STRINGS.line, $STRINGS.pos, $expr.e)}))) (RULE accessstmt (returns interfaces.Expression access) (BLOCK (ALT (= op ID) {$access = expressions.NewAccess($op.line, $op.pos, $op.text)}))) (RULE increaseanddecreasestmt (returns interfaces.Instruction increasedecrease) (BLOCK (ALT ID IG_ADD expr (? (BLOCK (ALT PTCOMA))) {$increasedecrease = instructions.NewIncreaseDecrease($ID.line, $ID.pos, $ID.text, $IG_ADD.text, $expr.e)}) (ALT ID IG_SUB expr (? (BLOCK (ALT PTCOMA))) {$increasedecrease = instructions.NewIncreaseDecrease($ID.line, $ID.pos, $ID.text, $IG_SUB.text, $expr.e)}))) (RULE type (returns environment.TipoExpresion t) (BLOCK (ALT STRINGS {$t = environment.STRING}) (ALT INTS {$t = environment.INTEGER}) (ALT FLOATS {$t = environment.FLOAT}) (ALT BOOLS {$t = environment.BOOLEAN }) (ALT CHARACTERS {$t = environment.CHARACTER}) (ALT ID { $t = environment.STRUCT  }))) (RULE listParams (returns []interface{} l) (BLOCK (ALT (= list listParams) COMA (? (BLOCK (ALT AND_SIMPLE) (ALT ID DOUBLEPTS))) expr {
                                var arr []interface{}
                                arr = append($list.l, $expr.e)
                                $l = arr
                            }) (ALT (? (BLOCK (ALT AND_SIMPLE) (ALT ID DOUBLEPTS))) expr {
            $l = []interface{}{}
            $l = append($l, $expr.e)
        }))) (RULE listStructExp (returns []interface{} l) (BLOCK (ALT (= list listStructExp) (? (BLOCK (ALT COMA))) ID DOUBLEPTS expr {
                                            var arr []interface{}
                                            StrExp := environment.NewStructContent($ID.text, $expr.e)
                                            arr = append($list.l, StrExp)
                                            $l = arr
                                        }) (ALT ID DOUBLEPTS expr {
                    var arr []interface{}
                    StrExp := environment.NewStructContent($ID.text, $expr.e)
                    arr = append(arr, StrExp)
                    $l = arr
                }) (ALT {
        $l = []interface{}{}
    })))))
2023-10-30 17:35:48:207 grammar LogManager.java:25 lexer =(LEXER_GRAMMAR GrammarLexer OPTIONS (@ header {
    import "Server/Interfaces"
    import "Server/Environment"
    import "Server/Expression"
    import "Server/Instruction"
    import "strings"
}) RULES)
2023-10-30 17:35:48:237 left-recursion LogManager.java:25 listParamsFunc returns [[]interface{} lf]
    :   ( {} parameterfuncstmt<tokenIndex=1173> {
    
            $lf = []interface{}{}
            $lf = append($lf, $parameterfuncstmt.parameterfunc)
        } 
        )
        (
          {p.Precpred(p.GetParserRuleContext(), 2)}?<p=2> COMA<tokenIndex=1165> parameterfuncstmt<tokenIndex=1167>  {
                              
                                          var arrf []interface{}
                                          arrf = append($listf.lf, $parameterfuncstmt.parameterfunc)
                                          $lf = arrf
                                      }
        )*
    ;
2023-10-30 17:35:48:243 grammar LogManager.java:25 added: (RULE listParamsFunc (returns []interface{} lf) (BLOCK (ALT (BLOCK (ALT {} (parameterfuncstmt (ELEMENT_OPTIONS (= tokenIndex 1173))) {
    
            $lf = []interface{}{}
            $lf = append($lf, $parameterfuncstmt.parameterfunc)
        })) (* (BLOCK (ALT ({p.Precpred(p.GetParserRuleContext(), 2)}? (ELEMENT_OPTIONS (= p 2))) (COMA (ELEMENT_OPTIONS (= tokenIndex 1165))) (parameterfuncstmt (ELEMENT_OPTIONS (= tokenIndex 1167))) {
                              
                                          var arrf []interface{}
                                          arrf = append($listf.lf, $parameterfuncstmt.parameterfunc)
                                          $lf = arrf
                                      }))))))
2023-10-30 17:35:48:243 left-recursion LogManager.java:25 listStruct returns [[]interface{} l]
    :   ( {} VAR<tokenIndex=1289> ID<tokenIndex=1291> DOUBLEPTS<tokenIndex=1293> type<tokenIndex=1295> {
                        var arr []interface{}
                        newParams := environment.NewStructType($ID.text, $type.t)
                        arr = append(arr, newParams)
                        $l = arr
} 
        | { $l = []interface{}{} } 
        )
        (
          {p.Precpred(p.GetParserRuleContext(), 3)}?<p=3> VAR<tokenIndex=1277> ID<tokenIndex=1279> DOUBLEPTS<tokenIndex=1281> type<tokenIndex=1283> {
                                      var arr []interface{}
                                      newParams := environment.NewStructType($ID.text, $type.t)
                                      arr = append($list.l, newParams)
                                      $l = arr

          }
        )*
    ;
2023-10-30 17:35:48:250 grammar LogManager.java:25 added: (RULE listStruct (returns []interface{} l) (BLOCK (ALT (BLOCK (ALT {} (VAR (ELEMENT_OPTIONS (= tokenIndex 1289))) (ID (ELEMENT_OPTIONS (= tokenIndex 1291))) (DOUBLEPTS (ELEMENT_OPTIONS (= tokenIndex 1293))) (type (ELEMENT_OPTIONS (= tokenIndex 1295))) {
                        var arr []interface{}
                        newParams := environment.NewStructType($ID.text, $type.t)
                        arr = append(arr, newParams)
                        $l = arr
}) (ALT { $l = []interface{}{} })) (* (BLOCK (ALT ({p.Precpred(p.GetParserRuleContext(), 3)}? (ELEMENT_OPTIONS (= p 3))) (VAR (ELEMENT_OPTIONS (= tokenIndex 1277))) (ID (ELEMENT_OPTIONS (= tokenIndex 1279))) (DOUBLEPTS (ELEMENT_OPTIONS (= tokenIndex 1281))) (type (ELEMENT_OPTIONS (= tokenIndex 1283))) {
                                      var arr []interface{}
                                      newParams := environment.NewStructType($ID.text, $type.t)
                                      arr = append($list.l, newParams)
                                      $l = arr

          }))))))
2023-10-30 17:35:48:254 left-recursion LogManager.java:25 expr returns [interfaces.Expression e]
    :   ( {} op= NOT<tokenIndex=1452>   left=expr<tokenIndex=1456,p=18> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $left.e) } 
        | op = SUB<tokenIndex=1466>  left=expr<tokenIndex=1470,p=17> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e,  $op.text, nil)} 
        | PARIZQ<tokenIndex=1476> expr<tokenIndex=1478> PARDER<tokenIndex=1480> { $e = $expr.e } 
        | NUMBER<tokenIndex=1486>                             
    {   
        
        if (strings.Contains($NUMBER.text,".")){
           
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,$NUMBER.text,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.INTEGER)
        }
    } 
        | STRING<tokenIndex=1492>
    {
        str := $STRING.text
        $e = expressions.NewPrimitive($STRING.line, $STRING.pos, str[1:len(str)-1],environment.STRING)
    } 
        | TRUE<tokenIndex=1498> { $e = expressions.NewPrimitive($TRUE.line, $TRUE.pos, true, environment.BOOLEAN) } 
        | FALSE<tokenIndex=1504> { $e = expressions.NewPrimitive($FALSE.line, $FALSE.pos, false, environment.BOOLEAN) } 
        | NIL<tokenIndex=1510> { $e = expressions.NewPrimitive($NIL.line, $NIL.pos, nil, environment.NULL) } 
        | accessstmt<tokenIndex=1516> {$e = $accessstmt.access} 
        | emptvecstmt<tokenIndex=1522> {$e = $emptvecstmt.emptyvec} 
        | countvecstmt<tokenIndex=1528> {$e = $countvecstmt.count} 
        | accessvecstmt<tokenIndex=1534> {$e = $accessvecstmt.accessvec} 
        | intfunctionstmt<tokenIndex=1540> {$e = $intfunctionstmt.intfunc} 
        | floatfunctionstmt<tokenIndex=1546> {$e = $floatfunctionstmt.floatfunc} 
        | stringfunctionstmt<tokenIndex=1552> {$e = $stringfunctionstmt.stringfunc} 
        | accessfuncstmt<tokenIndex=1558>     {$e = $accessfuncstmt.funcexp} 
        | ID<tokenIndex=1564> (LLAVEIZQ<tokenIndex=1567>|PARIZQ<tokenIndex=1569>) listStructExp<tokenIndex=1572> (LLAVEDER<tokenIndex=1575>|PARDER<tokenIndex=1577>) { $e = expressions.NewStructExp($ID.line, $ID.pos, $ID.text, $listStructExp.l ) } 
        | accessstructstmt<tokenIndex=1584> {$e = $accessstructstmt.accessstruct} 
        )
        (
          {p.Precpred(p.GetParserRuleContext(), 25)}?<p=25> op=(MUL<tokenIndex=1322>|DIV<tokenIndex=1324>) right=expr<tokenIndex=1329,p=26> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 24)}?<p=24> op=(ADD<tokenIndex=1342>|SUB<tokenIndex=1344>|PERCENT<tokenIndex=1346>) right=expr<tokenIndex=1351,p=25> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 23)}?<p=23> op=(MAY_IG<tokenIndex=1364>|MAYOR<tokenIndex=1366>) right=expr<tokenIndex=1371,p=24> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 22)}?<p=22> op=(MEN_IG<tokenIndex=1384>|MENOR<tokenIndex=1386>) right=expr<tokenIndex=1391,p=23> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 21)}?<p=21> op=(IG_IG<tokenIndex=1404>|DIF<tokenIndex=1406>) right=expr<tokenIndex=1411,p=22> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 20)}?<p=20> op=AND<tokenIndex=1423> right=expr<tokenIndex=1427,p=21> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 19)}?<p=19> op=OR<tokenIndex=1439> right=expr<tokenIndex=1443,p=20> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
        )*
    ;
2023-10-30 17:35:48:270 grammar LogManager.java:25 added: (RULE expr (returns interfaces.Expression e) (BLOCK (ALT (BLOCK (ALT {} (= op (NOT (ELEMENT_OPTIONS (= tokenIndex 1452)))) (= left (expr (ELEMENT_OPTIONS (= tokenIndex 1456) (= p 18)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $left.e) }) (ALT (= op (SUB (ELEMENT_OPTIONS (= tokenIndex 1466)))) (= left (expr (ELEMENT_OPTIONS (= tokenIndex 1470) (= p 17)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e,  $op.text, nil)}) (ALT (PARIZQ (ELEMENT_OPTIONS (= tokenIndex 1476))) (expr (ELEMENT_OPTIONS (= tokenIndex 1478))) (PARDER (ELEMENT_OPTIONS (= tokenIndex 1480))) { $e = $expr.e }) (ALT (NUMBER (ELEMENT_OPTIONS (= tokenIndex 1486))) {   
        
        if (strings.Contains($NUMBER.text,".")){
           
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,$NUMBER.text,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.INTEGER)
        }
    }) (ALT (STRING (ELEMENT_OPTIONS (= tokenIndex 1492))) {
        str := $STRING.text
        $e = expressions.NewPrimitive($STRING.line, $STRING.pos, str[1:len(str)-1],environment.STRING)
    }) (ALT (TRUE (ELEMENT_OPTIONS (= tokenIndex 1498))) { $e = expressions.NewPrimitive($TRUE.line, $TRUE.pos, true, environment.BOOLEAN) }) (ALT (FALSE (ELEMENT_OPTIONS (= tokenIndex 1504))) { $e = expressions.NewPrimitive($FALSE.line, $FALSE.pos, false, environment.BOOLEAN) }) (ALT (NIL (ELEMENT_OPTIONS (= tokenIndex 1510))) { $e = expressions.NewPrimitive($NIL.line, $NIL.pos, nil, environment.NULL) }) (ALT (accessstmt (ELEMENT_OPTIONS (= tokenIndex 1516))) {$e = $accessstmt.access}) (ALT (emptvecstmt (ELEMENT_OPTIONS (= tokenIndex 1522))) {$e = $emptvecstmt.emptyvec}) (ALT (countvecstmt (ELEMENT_OPTIONS (= tokenIndex 1528))) {$e = $countvecstmt.count}) (ALT (accessvecstmt (ELEMENT_OPTIONS (= tokenIndex 1534))) {$e = $accessvecstmt.accessvec}) (ALT (intfunctionstmt (ELEMENT_OPTIONS (= tokenIndex 1540))) {$e = $intfunctionstmt.intfunc}) (ALT (floatfunctionstmt (ELEMENT_OPTIONS (= tokenIndex 1546))) {$e = $floatfunctionstmt.floatfunc}) (ALT (stringfunctionstmt (ELEMENT_OPTIONS (= tokenIndex 1552))) {$e = $stringfunctionstmt.stringfunc}) (ALT (accessfuncstmt (ELEMENT_OPTIONS (= tokenIndex 1558))) {$e = $accessfuncstmt.funcexp}) (ALT (ID (ELEMENT_OPTIONS (= tokenIndex 1564))) (SET (LLAVEIZQ (ELEMENT_OPTIONS (= tokenIndex 1567))) (PARIZQ (ELEMENT_OPTIONS (= tokenIndex 1569)))) (listStructExp (ELEMENT_OPTIONS (= tokenIndex 1572))) (SET (LLAVEDER (ELEMENT_OPTIONS (= tokenIndex 1575))) (PARDER (ELEMENT_OPTIONS (= tokenIndex 1577)))) { $e = expressions.NewStructExp($ID.line, $ID.pos, $ID.text, $listStructExp.l ) }) (ALT (accessstructstmt (ELEMENT_OPTIONS (= tokenIndex 1584))) {$e = $accessstructstmt.accessstruct})) (* (BLOCK (ALT ({p.Precpred(p.GetParserRuleContext(), 25)}? (ELEMENT_OPTIONS (= p 25))) (= op (SET (MUL (ELEMENT_OPTIONS (= tokenIndex 1322))) (DIV (ELEMENT_OPTIONS (= tokenIndex 1324))))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 1329) (= p 26)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 24)}? (ELEMENT_OPTIONS (= p 24))) (= op (SET (ADD (ELEMENT_OPTIONS (= tokenIndex 1342))) (SUB (ELEMENT_OPTIONS (= tokenIndex 1344))) (PERCENT (ELEMENT_OPTIONS (= tokenIndex 1346))))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 1351) (= p 25)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 23)}? (ELEMENT_OPTIONS (= p 23))) (= op (SET (MAY_IG (ELEMENT_OPTIONS (= tokenIndex 1364))) (MAYOR (ELEMENT_OPTIONS (= tokenIndex 1366))))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 1371) (= p 24)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 22)}? (ELEMENT_OPTIONS (= p 22))) (= op (SET (MEN_IG (ELEMENT_OPTIONS (= tokenIndex 1384))) (MENOR (ELEMENT_OPTIONS (= tokenIndex 1386))))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 1391) (= p 23)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 21)}? (ELEMENT_OPTIONS (= p 21))) (= op (SET (IG_IG (ELEMENT_OPTIONS (= tokenIndex 1404))) (DIF (ELEMENT_OPTIONS (= tokenIndex 1406))))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 1411) (= p 22)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 20)}? (ELEMENT_OPTIONS (= p 20))) (= op (AND (ELEMENT_OPTIONS (= tokenIndex 1423)))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 1427) (= p 21)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 19)}? (ELEMENT_OPTIONS (= p 19))) (= op (OR (ELEMENT_OPTIONS (= tokenIndex 1439)))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 1443) (= p 20)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }))))))
2023-10-30 17:35:48:272 left-recursion LogManager.java:25 listParams returns [[]interface{} l]
    :   ( {} (AND_SIMPLE<tokenIndex=1838>| ID<tokenIndex=1841> DOUBLEPTS<tokenIndex=1843>)? expr<tokenIndex=1847> {
            $l = []interface{}{}
            $l = append($l, $expr.e)
        } 
        )
        (
          {p.Precpred(p.GetParserRuleContext(), 2)}?<p=2> COMA<tokenIndex=1819> (AND_SIMPLE<tokenIndex=1822>| ID<tokenIndex=1825> DOUBLEPTS<tokenIndex=1827>)? expr<tokenIndex=1831> {
                                          var arr []interface{}
                                          arr = append($list.l, $expr.e)
                                          $l = arr
                                      }
        )*
    ;
2023-10-30 17:35:48:274 grammar LogManager.java:25 added: (RULE listParams (returns []interface{} l) (BLOCK (ALT (BLOCK (ALT {} (? (BLOCK (ALT (AND_SIMPLE (ELEMENT_OPTIONS (= tokenIndex 1838)))) (ALT (ID (ELEMENT_OPTIONS (= tokenIndex 1841))) (DOUBLEPTS (ELEMENT_OPTIONS (= tokenIndex 1843)))))) (expr (ELEMENT_OPTIONS (= tokenIndex 1847))) {
            $l = []interface{}{}
            $l = append($l, $expr.e)
        })) (* (BLOCK (ALT ({p.Precpred(p.GetParserRuleContext(), 2)}? (ELEMENT_OPTIONS (= p 2))) (COMA (ELEMENT_OPTIONS (= tokenIndex 1819))) (? (BLOCK (ALT (AND_SIMPLE (ELEMENT_OPTIONS (= tokenIndex 1822)))) (ALT (ID (ELEMENT_OPTIONS (= tokenIndex 1825))) (DOUBLEPTS (ELEMENT_OPTIONS (= tokenIndex 1827)))))) (expr (ELEMENT_OPTIONS (= tokenIndex 1831))) {
                                          var arr []interface{}
                                          arr = append($list.l, $expr.e)
                                          $l = arr
                                      }))))))
2023-10-30 17:35:48:275 left-recursion LogManager.java:25 listStructExp returns [[]interface{} l]
    :   ( {} ID<tokenIndex=1877> DOUBLEPTS<tokenIndex=1879> expr<tokenIndex=1881>{
                    var arr []interface{}
                    StrExp := environment.NewStructContent($ID.text, $expr.e)
                    arr = append(arr, StrExp)
                    $l = arr
                } 
        | {
        $l = []interface{}{}
    } 
        )
        (
          {p.Precpred(p.GetParserRuleContext(), 3)}?<p=3> COMA<tokenIndex=1864>?  ID<tokenIndex=1867> DOUBLEPTS<tokenIndex=1869> expr<tokenIndex=1871> {
                                                      var arr []interface{}
                                                      StrExp := environment.NewStructContent($ID.text, $expr.e)
                                                      arr = append($list.l, StrExp)
                                                      $l = arr
                                                  }
        )*
    ;
2023-10-30 17:35:48:278 grammar LogManager.java:25 added: (RULE listStructExp (returns []interface{} l) (BLOCK (ALT (BLOCK (ALT {} (ID (ELEMENT_OPTIONS (= tokenIndex 1877))) (DOUBLEPTS (ELEMENT_OPTIONS (= tokenIndex 1879))) (expr (ELEMENT_OPTIONS (= tokenIndex 1881))) {
                    var arr []interface{}
                    StrExp := environment.NewStructContent($ID.text, $expr.e)
                    arr = append(arr, StrExp)
                    $l = arr
                }) (ALT {
        $l = []interface{}{}
    })) (* (BLOCK (ALT ({p.Precpred(p.GetParserRuleContext(), 3)}? (ELEMENT_OPTIONS (= p 3))) (? (BLOCK (ALT (COMA (ELEMENT_OPTIONS (= tokenIndex 1864)))))) (ID (ELEMENT_OPTIONS (= tokenIndex 1867))) (DOUBLEPTS (ELEMENT_OPTIONS (= tokenIndex 1869))) (expr (ELEMENT_OPTIONS (= tokenIndex 1871))) {
                                                      var arr []interface{}
                                                      StrExp := environment.NewStructContent($ID.text, $expr.e)
                                                      arr = append($list.l, StrExp)
                                                      $l = arr
                                                  }))))))
2023-10-30 17:35:48:289 grammar LogManager.java:25 import STRINGS=1
2023-10-30 17:35:48:290 grammar LogManager.java:25 import INTS=2
2023-10-30 17:35:48:290 grammar LogManager.java:25 import FLOATS=3
2023-10-30 17:35:48:290 grammar LogManager.java:25 import BOOLS=4
2023-10-30 17:35:48:290 grammar LogManager.java:25 import CHARACTERS=5
2023-10-30 17:35:48:290 grammar LogManager.java:25 import VAR=6
2023-10-30 17:35:48:290 grammar LogManager.java:25 import NIL=7
2023-10-30 17:35:48:290 grammar LogManager.java:25 import TRUE=8
2023-10-30 17:35:48:290 grammar LogManager.java:25 import FALSE=9
2023-10-30 17:35:48:290 grammar LogManager.java:25 import PRINT=10
2023-10-30 17:35:48:290 grammar LogManager.java:25 import IF=11
2023-10-30 17:35:48:290 grammar LogManager.java:25 import ELSE=12
2023-10-30 17:35:48:290 grammar LogManager.java:25 import WHILE=13
2023-10-30 17:35:48:290 grammar LogManager.java:25 import LET=14
2023-10-30 17:35:48:290 grammar LogManager.java:25 import FOR=15
2023-10-30 17:35:48:290 grammar LogManager.java:25 import IN=16
2023-10-30 17:35:48:290 grammar LogManager.java:25 import SWITCH=17
2023-10-30 17:35:48:291 grammar LogManager.java:25 import CASE=18
2023-10-30 17:35:48:291 grammar LogManager.java:25 import DEFAULT=19
2023-10-30 17:35:48:291 grammar LogManager.java:25 import GUARD=20
2023-10-30 17:35:48:291 grammar LogManager.java:25 import CONTINUE=21
2023-10-30 17:35:48:291 grammar LogManager.java:25 import RETURN=22
2023-10-30 17:35:48:291 grammar LogManager.java:25 import BREAK=23
2023-10-30 17:35:48:291 grammar LogManager.java:25 import APPEND=24
2023-10-30 17:35:48:291 grammar LogManager.java:25 import REMOVELAST=25
2023-10-30 17:35:48:291 grammar LogManager.java:25 import REMOVE=26
2023-10-30 17:35:48:291 grammar LogManager.java:25 import AT=27
2023-10-30 17:35:48:292 grammar LogManager.java:25 import ISEMPTY=28
2023-10-30 17:35:48:292 grammar LogManager.java:25 import COUNT=29
2023-10-30 17:35:48:292 grammar LogManager.java:25 import FUNC=30
2023-10-30 17:35:48:292 grammar LogManager.java:25 import INOUT=31
2023-10-30 17:35:48:292 grammar LogManager.java:25 import STRUCT=32
2023-10-30 17:35:48:292 grammar LogManager.java:25 import NUMBER=33
2023-10-30 17:35:48:292 grammar LogManager.java:25 import STRING=34
2023-10-30 17:35:48:292 grammar LogManager.java:25 import ID=35
2023-10-30 17:35:48:292 grammar LogManager.java:25 import DIF=36
2023-10-30 17:35:48:292 grammar LogManager.java:25 import IG_IG=37
2023-10-30 17:35:48:293 grammar LogManager.java:25 import NOT=38
2023-10-30 17:35:48:294 grammar LogManager.java:25 import OR=39
2023-10-30 17:35:48:294 grammar LogManager.java:25 import AND=40
2023-10-30 17:35:48:294 grammar LogManager.java:25 import IG=41
2023-10-30 17:35:48:294 grammar LogManager.java:25 import IG_ADD=42
2023-10-30 17:35:48:294 grammar LogManager.java:25 import IG_SUB=43
2023-10-30 17:35:48:294 grammar LogManager.java:25 import MAY_IG=44
2023-10-30 17:35:48:294 grammar LogManager.java:25 import MEN_IG=45
2023-10-30 17:35:48:294 grammar LogManager.java:25 import MAYOR=46
2023-10-30 17:35:48:294 grammar LogManager.java:25 import MENOR=47
2023-10-30 17:35:48:294 grammar LogManager.java:25 import MUL=48
2023-10-30 17:35:48:294 grammar LogManager.java:25 import DIV=49
2023-10-30 17:35:48:294 grammar LogManager.java:25 import ADD=50
2023-10-30 17:35:48:295 grammar LogManager.java:25 import SUB=51
2023-10-30 17:35:48:295 grammar LogManager.java:25 import PERCENT=52
2023-10-30 17:35:48:295 grammar LogManager.java:25 import PARIZQ=53
2023-10-30 17:35:48:295 grammar LogManager.java:25 import PARDER=54
2023-10-30 17:35:48:295 grammar LogManager.java:25 import LLAVEIZQ=55
2023-10-30 17:35:48:295 grammar LogManager.java:25 import LLAVEDER=56
2023-10-30 17:35:48:295 grammar LogManager.java:25 import DOUBLEPTS=57
2023-10-30 17:35:48:295 grammar LogManager.java:25 import QUESTION=58
2023-10-30 17:35:48:295 grammar LogManager.java:25 import POINT=59
2023-10-30 17:35:48:295 grammar LogManager.java:25 import COMA=60
2023-10-30 17:35:48:295 grammar LogManager.java:25 import PTCOMA=61
2023-10-30 17:35:48:295 grammar LogManager.java:25 import CORCHETEIZQ=62
2023-10-30 17:35:48:295 grammar LogManager.java:25 import CORCHETEDER=63
2023-10-30 17:35:48:295 grammar LogManager.java:25 import GUION_BAJO=64
2023-10-30 17:35:48:295 grammar LogManager.java:25 import AND_SIMPLE=65
2023-10-30 17:35:48:295 grammar LogManager.java:25 import WHITESPACE=66
2023-10-30 17:35:48:295 grammar LogManager.java:25 import COMMENT=67
2023-10-30 17:35:48:296 grammar LogManager.java:25 import LINE_COMMENT=68
2023-10-30 17:35:48:296 grammar LogManager.java:25 import 'String'=1
2023-10-30 17:35:48:296 grammar LogManager.java:25 import 'Int'=2
2023-10-30 17:35:48:296 grammar LogManager.java:25 import 'Float'=3
2023-10-30 17:35:48:296 grammar LogManager.java:25 import 'Bool'=4
2023-10-30 17:35:48:296 grammar LogManager.java:25 import 'Character'=5
2023-10-30 17:35:48:296 grammar LogManager.java:25 import 'var'=6
2023-10-30 17:35:48:296 grammar LogManager.java:25 import 'nil'=7
2023-10-30 17:35:48:297 grammar LogManager.java:25 import 'true'=8
2023-10-30 17:35:48:297 grammar LogManager.java:25 import 'false'=9
2023-10-30 17:35:48:297 grammar LogManager.java:25 import 'print'=10
2023-10-30 17:35:48:297 grammar LogManager.java:25 import 'if'=11
2023-10-30 17:35:48:297 grammar LogManager.java:25 import 'else'=12
2023-10-30 17:35:48:297 grammar LogManager.java:25 import 'while'=13
2023-10-30 17:35:48:297 grammar LogManager.java:25 import 'let'=14
2023-10-30 17:35:48:298 grammar LogManager.java:25 import 'for'=15
2023-10-30 17:35:48:298 grammar LogManager.java:25 import 'in'=16
2023-10-30 17:35:48:298 grammar LogManager.java:25 import 'switch'=17
2023-10-30 17:35:48:298 grammar LogManager.java:25 import 'case'=18
2023-10-30 17:35:48:298 grammar LogManager.java:25 import 'default'=19
2023-10-30 17:35:48:298 grammar LogManager.java:25 import 'guard'=20
2023-10-30 17:35:48:299 grammar LogManager.java:25 import 'continue'=21
2023-10-30 17:35:48:299 grammar LogManager.java:25 import 'return'=22
2023-10-30 17:35:48:299 grammar LogManager.java:25 import 'break'=23
2023-10-30 17:35:48:299 grammar LogManager.java:25 import 'append'=24
2023-10-30 17:35:48:299 grammar LogManager.java:25 import 'removeLast'=25
2023-10-30 17:35:48:299 grammar LogManager.java:25 import 'remove'=26
2023-10-30 17:35:48:299 grammar LogManager.java:25 import 'at'=27
2023-10-30 17:35:48:299 grammar LogManager.java:25 import 'isEmpty'=28
2023-10-30 17:35:48:299 grammar LogManager.java:25 import 'count'=29
2023-10-30 17:35:48:299 grammar LogManager.java:25 import 'func'=30
2023-10-30 17:35:48:299 grammar LogManager.java:25 import 'inout'=31
2023-10-30 17:35:48:300 grammar LogManager.java:25 import 'struct'=32
2023-10-30 17:35:48:300 grammar LogManager.java:25 import '!='=36
2023-10-30 17:35:48:300 grammar LogManager.java:25 import '=='=37
2023-10-30 17:35:48:300 grammar LogManager.java:25 import '!'=38
2023-10-30 17:35:48:300 grammar LogManager.java:25 import '||'=39
2023-10-30 17:35:48:300 grammar LogManager.java:25 import '&&'=40
2023-10-30 17:35:48:300 grammar LogManager.java:25 import '='=41
2023-10-30 17:35:48:300 grammar LogManager.java:25 import '+='=42
2023-10-30 17:35:48:301 grammar LogManager.java:25 import '-='=43
2023-10-30 17:35:48:301 grammar LogManager.java:25 import '>='=44
2023-10-30 17:35:48:301 grammar LogManager.java:25 import '<='=45
2023-10-30 17:35:48:301 grammar LogManager.java:25 import '>'=46
2023-10-30 17:35:48:301 grammar LogManager.java:25 import '<'=47
2023-10-30 17:35:48:301 grammar LogManager.java:25 import '*'=48
2023-10-30 17:35:48:301 grammar LogManager.java:25 import '/'=49
2023-10-30 17:35:48:302 grammar LogManager.java:25 import '+'=50
2023-10-30 17:35:48:302 grammar LogManager.java:25 import '-'=51
2023-10-30 17:35:48:302 grammar LogManager.java:25 import '%'=52
2023-10-30 17:35:48:302 grammar LogManager.java:25 import '('=53
2023-10-30 17:35:48:302 grammar LogManager.java:25 import ')'=54
2023-10-30 17:35:48:302 grammar LogManager.java:25 import '{'=55
2023-10-30 17:35:48:302 grammar LogManager.java:25 import '}'=56
2023-10-30 17:35:48:302 grammar LogManager.java:25 import ':'=57
2023-10-30 17:35:48:302 grammar LogManager.java:25 import '?'=58
2023-10-30 17:35:48:303 grammar LogManager.java:25 import '.'=59
2023-10-30 17:35:48:303 grammar LogManager.java:25 import ','=60
2023-10-30 17:35:48:303 grammar LogManager.java:25 import ';'=61
2023-10-30 17:35:48:303 grammar LogManager.java:25 import '['=62
2023-10-30 17:35:48:303 grammar LogManager.java:25 import ']'=63
2023-10-30 17:35:48:303 grammar LogManager.java:25 import '_'=64
2023-10-30 17:35:48:303 grammar LogManager.java:25 import '&'=65
2023-10-30 17:35:48:304 grammar LogManager.java:25 tokens={STRINGS=1, INTS=2, FLOATS=3, BOOLS=4, CHARACTERS=5, VAR=6, NIL=7, TRUE=8, FALSE=9, PRINT=10, IF=11, ELSE=12, WHILE=13, LET=14, FOR=15, IN=16, SWITCH=17, CASE=18, DEFAULT=19, GUARD=20, CONTINUE=21, RETURN=22, BREAK=23, APPEND=24, REMOVELAST=25, REMOVE=26, AT=27, ISEMPTY=28, COUNT=29, FUNC=30, INOUT=31, STRUCT=32, NUMBER=33, STRING=34, ID=35, DIF=36, IG_IG=37, NOT=38, OR=39, AND=40, IG=41, IG_ADD=42, IG_SUB=43, MAY_IG=44, MEN_IG=45, MAYOR=46, MENOR=47, MUL=48, DIV=49, ADD=50, SUB=51, PERCENT=52, PARIZQ=53, PARDER=54, LLAVEIZQ=55, LLAVEDER=56, DOUBLEPTS=57, QUESTION=58, POINT=59, COMA=60, PTCOMA=61, CORCHETEIZQ=62, CORCHETEDER=63, GUION_BAJO=64, AND_SIMPLE=65, WHITESPACE=66, COMMENT=67, LINE_COMMENT=68, 'String'=1, 'Int'=2, 'Float'=3, 'Bool'=4, 'Character'=5, 'var'=6, 'nil'=7, 'true'=8, 'false'=9, 'print'=10, 'if'=11, 'else'=12, 'while'=13, 'let'=14, 'for'=15, 'in'=16, 'switch'=17, 'case'=18, 'default'=19, 'guard'=20, 'continue'=21, 'return'=22, 'break'=23, 'append'=24, 'removeLast'=25, 'remove'=26, 'at'=27, 'isEmpty'=28, 'count'=29, 'func'=30, 'inout'=31, 'struct'=32, '!='=36, '=='=37, '!'=38, '||'=39, '&&'=40, '='=41, '+='=42, '-='=43, '>='=44, '<='=45, '>'=46, '<'=47, '*'=48, '/'=49, '+'=50, '-'=51, '%'=52, '('=53, ')'=54, '{'=55, '}'=56, ':'=57, '?'=58, '.'=59, ','=60, ';'=61, '['=62, ']'=63, '_'=64, '&'=65}
2023-10-30 17:35:48:304 semantics LogManager.java:25 tokens={EOF=-1, STRINGS=1, INTS=2, FLOATS=3, BOOLS=4, CHARACTERS=5, VAR=6, NIL=7, TRUE=8, FALSE=9, PRINT=10, IF=11, ELSE=12, WHILE=13, LET=14, FOR=15, IN=16, SWITCH=17, CASE=18, DEFAULT=19, GUARD=20, CONTINUE=21, RETURN=22, BREAK=23, APPEND=24, REMOVELAST=25, REMOVE=26, AT=27, ISEMPTY=28, COUNT=29, FUNC=30, INOUT=31, STRUCT=32, NUMBER=33, STRING=34, ID=35, DIF=36, IG_IG=37, NOT=38, OR=39, AND=40, IG=41, IG_ADD=42, IG_SUB=43, MAY_IG=44, MEN_IG=45, MAYOR=46, MENOR=47, MUL=48, DIV=49, ADD=50, SUB=51, PERCENT=52, PARIZQ=53, PARDER=54, LLAVEIZQ=55, LLAVEDER=56, DOUBLEPTS=57, QUESTION=58, POINT=59, COMA=60, PTCOMA=61, CORCHETEIZQ=62, CORCHETEDER=63, GUION_BAJO=64, AND_SIMPLE=65, WHITESPACE=66, COMMENT=67, LINE_COMMENT=68}
2023-10-30 17:35:48:304 semantics LogManager.java:25 strings={'String'=1, 'Int'=2, 'Float'=3, 'Bool'=4, 'Character'=5, 'var'=6, 'nil'=7, 'true'=8, 'false'=9, 'print'=10, 'if'=11, 'else'=12, 'while'=13, 'let'=14, 'for'=15, 'in'=16, 'switch'=17, 'case'=18, 'default'=19, 'guard'=20, 'continue'=21, 'return'=22, 'break'=23, 'append'=24, 'removeLast'=25, 'remove'=26, 'at'=27, 'isEmpty'=28, 'count'=29, 'func'=30, 'inout'=31, 'struct'=32, '!='=36, '=='=37, '!'=38, '||'=39, '&&'=40, '='=41, '+='=42, '-='=43, '>='=44, '<='=45, '>'=46, '<'=47, '*'=48, '/'=49, '+'=50, '-'=51, '%'=52, '('=53, ')'=54, '{'=55, '}'=56, ':'=57, '?'=58, '.'=59, ','=60, ';'=61, '['=62, ']'=63, '_'=64, '&'=65}
2023-10-30 17:35:48:347 LL1 LogManager.java:25 
DECISION 0 in rule block
2023-10-30 17:35:48:348 LL1 LogManager.java:25 look=[{6, 10..11, 13..15, 17, 20..23, 30, 32, 35}, {<EOF>, 18..19, 56}]
2023-10-30 17:35:48:349 LL1 LogManager.java:25 LL(1)? true
2023-10-30 17:35:48:349 LL1 LogManager.java:25 
DECISION 1 in rule instruction
2023-10-30 17:35:48:349 LL1 LogManager.java:25 look=[10, 6, 14, 35, 35, 11, 13, 15, 17, 20, {21..23}, 6, 35, 35, 35, 35, 30, 35, 32, 35]
2023-10-30 17:35:48:349 LL1 LogManager.java:25 LL(1)? false
2023-10-30 17:35:48:349 LL1 LogManager.java:25 
DECISION 2 in rule printstmt
2023-10-30 17:35:48:350 LL1 LogManager.java:25 look=[61, {<EOF>, 6, 10..11, 13..15, 17..23, 30, 32, 35, 56}]
2023-10-30 17:35:48:350 LL1 LogManager.java:25 LL(1)? true
2023-10-30 17:35:48:350 LL1 LogManager.java:25 
DECISION 3 in rule declarestmt
2023-10-30 17:35:48:351 LL1 LogManager.java:25 look=[61, {<EOF>, 6, 10..11, 13..15, 17..23, 30, 32, 35, 56}]
2023-10-30 17:35:48:351 LL1 LogManager.java:25 LL(1)? true
2023-10-30 17:35:48:351 LL1 LogManager.java:25 
DECISION 4 in rule declarestmt
2023-10-30 17:35:48:351 LL1 LogManager.java:25 look=[61, {<EOF>, 6, 10..11, 13..15, 17..23, 30, 32, 35, 56}]
2023-10-30 17:35:48:351 LL1 LogManager.java:25 LL(1)? true
2023-10-30 17:35:48:351 LL1 LogManager.java:25 
DECISION 5 in rule declarestmt
2023-10-30 17:35:48:352 LL1 LogManager.java:25 look=[61, {<EOF>, 6, 10..11, 13..15, 17..23, 30, 32, 35, 56}]
2023-10-30 17:35:48:352 LL1 LogManager.java:25 LL(1)? true
2023-10-30 17:35:48:352 LL1 LogManager.java:25 
DECISION 6 in rule declarestmt
2023-10-30 17:35:48:352 LL1 LogManager.java:25 look=[6, 6, 6]
2023-10-30 17:35:48:352 LL1 LogManager.java:25 LL(1)? false
2023-10-30 17:35:48:352 LL1 LogManager.java:25 
DECISION 7 in rule constantstmt
2023-10-30 17:35:48:353 LL1 LogManager.java:25 look=[61, {<EOF>, 6, 10..11, 13..15, 17..23, 30, 32, 35, 56}]
2023-10-30 17:35:48:353 LL1 LogManager.java:25 LL(1)? true
2023-10-30 17:35:48:353 LL1 LogManager.java:25 
DECISION 8 in rule constantstmt
2023-10-30 17:35:48:353 LL1 LogManager.java:25 look=[61, {<EOF>, 6, 10..11, 13..15, 17..23, 30, 32, 35, 56}]
2023-10-30 17:35:48:353 LL1 LogManager.java:25 LL(1)? true
2023-10-30 17:35:48:353 LL1 LogManager.java:25 
DECISION 9 in rule constantstmt
2023-10-30 17:35:48:353 LL1 LogManager.java:25 look=[14, 14]
2023-10-30 17:35:48:353 LL1 LogManager.java:25 LL(1)? false
2023-10-30 17:35:48:353 LL1 LogManager.java:25 
DECISION 10 in rule blockelifs
2023-10-30 17:35:48:354 LL1 LogManager.java:25 look=[11, {<EOF>, 6, 10..11, 13..15, 17..23, 30, 32, 35, 56}]
2023-10-30 17:35:48:354 LL1 LogManager.java:25 LL(1)? false
2023-10-30 17:35:48:354 LL1 LogManager.java:25 
DECISION 11 in rule ifstmt
2023-10-30 17:35:48:354 LL1 LogManager.java:25 look=[11, 11, 11]
2023-10-30 17:35:48:354 LL1 LogManager.java:25 LL(1)? false
2023-10-30 17:35:48:354 LL1 LogManager.java:25 
DECISION 12 in rule switchstmt
2023-10-30 17:35:48:354 LL1 LogManager.java:25 look=[17, 17]
2023-10-30 17:35:48:354 LL1 LogManager.java:25 LL(1)? false
2023-10-30 17:35:48:354 LL1 LogManager.java:25 
DECISION 13 in rule casestmt
2023-10-30 17:35:48:354 LL1 LogManager.java:25 look=[18, 18]
2023-10-30 17:35:48:354 LL1 LogManager.java:25 LL(1)? false
2023-10-30 17:35:48:354 LL1 LogManager.java:25 
DECISION 14 in rule blockcases
2023-10-30 17:35:48:354 LL1 LogManager.java:25 look=[18, {18, 56}]
2023-10-30 17:35:48:354 LL1 LogManager.java:25 LL(1)? false
2023-10-30 17:35:48:355 LL1 LogManager.java:25 
DECISION 15 in rule assignationstmt
2023-10-30 17:35:48:355 LL1 LogManager.java:25 look=[61, {<EOF>, 6, 10..11, 13..15, 17..23, 30, 32, 35, 56}]
2023-10-30 17:35:48:355 LL1 LogManager.java:25 LL(1)? true
2023-10-30 17:35:48:355 LL1 LogManager.java:25 
DECISION 16 in rule assignationstructstmt
2023-10-30 17:35:48:355 LL1 LogManager.java:25 look=[61, {<EOF>, 6, 10..11, 13..15, 17..23, 30, 32, 35, 56}]
2023-10-30 17:35:48:355 LL1 LogManager.java:25 LL(1)? true
2023-10-30 17:35:48:355 LL1 LogManager.java:25 
DECISION 17 in rule forstmt
2023-10-30 17:35:48:355 LL1 LogManager.java:25 look=[15, 15]
2023-10-30 17:35:48:355 LL1 LogManager.java:25 LL(1)? false
2023-10-30 17:35:48:355 LL1 LogManager.java:25 
DECISION 18 in rule transferstmt
2023-10-30 17:35:48:355 LL1 LogManager.java:25 look=[61, {<EOF>, 6, 10..11, 13..15, 17..23, 30, 32, 35, 56}]
2023-10-30 17:35:48:355 LL1 LogManager.java:25 LL(1)? true
2023-10-30 17:35:48:355 LL1 LogManager.java:25 
DECISION 19 in rule transferstmt
2023-10-30 17:35:48:355 LL1 LogManager.java:25 look=[61, {<EOF>, 6, 10..11, 13..15, 17..23, 30, 32, 35, 56}]
2023-10-30 17:35:48:355 LL1 LogManager.java:25 LL(1)? true
2023-10-30 17:35:48:356 LL1 LogManager.java:25 
DECISION 20 in rule transferstmt
2023-10-30 17:35:48:356 LL1 LogManager.java:25 look=[61, {<EOF>, 6, 10..11, 13..15, 17..23, 30, 32, 35, 56}]
2023-10-30 17:35:48:356 LL1 LogManager.java:25 LL(1)? true
2023-10-30 17:35:48:356 LL1 LogManager.java:25 
DECISION 21 in rule transferstmt
2023-10-30 17:35:48:356 LL1 LogManager.java:25 look=[61, {<EOF>, 6, 10..11, 13..15, 17..23, 30, 32, 35, 56}]
2023-10-30 17:35:48:356 LL1 LogManager.java:25 LL(1)? true
2023-10-30 17:35:48:356 LL1 LogManager.java:25 
DECISION 22 in rule transferstmt
2023-10-30 17:35:48:356 LL1 LogManager.java:25 look=[22, 22, 21, 23]
2023-10-30 17:35:48:356 LL1 LogManager.java:25 LL(1)? false
2023-10-30 17:35:48:356 LL1 LogManager.java:25 
DECISION 23 in rule declarevectorstmt
2023-10-30 17:35:48:356 LL1 LogManager.java:25 look=[61, {<EOF>, 6, 10..11, 13..15, 17..23, 30, 32, 35, 56}]
2023-10-30 17:35:48:356 LL1 LogManager.java:25 LL(1)? true
2023-10-30 17:35:48:356 LL1 LogManager.java:25 
DECISION 24 in rule declarevectorstmt
2023-10-30 17:35:48:356 LL1 LogManager.java:25 look=[61, {<EOF>, 6, 10..11, 13..15, 17..23, 30, 32, 35, 56}]
2023-10-30 17:35:48:356 LL1 LogManager.java:25 LL(1)? true
2023-10-30 17:35:48:356 LL1 LogManager.java:25 
DECISION 25 in rule declarevectorstmt
2023-10-30 17:35:48:356 LL1 LogManager.java:25 look=[61, {<EOF>, 6, 10..11, 13..15, 17..23, 30, 32, 35, 56}]
2023-10-30 17:35:48:356 LL1 LogManager.java:25 LL(1)? true
2023-10-30 17:35:48:356 LL1 LogManager.java:25 
DECISION 26 in rule declarevectorstmt
2023-10-30 17:35:48:357 LL1 LogManager.java:25 look=[61, {<EOF>, 6, 10..11, 13..15, 17..23, 30, 32, 35, 56}]
2023-10-30 17:35:48:357 LL1 LogManager.java:25 LL(1)? true
2023-10-30 17:35:48:357 LL1 LogManager.java:25 
DECISION 27 in rule declarevectorstmt
2023-10-30 17:35:48:357 LL1 LogManager.java:25 look=[6, 6, 6, 6]
2023-10-30 17:35:48:357 LL1 LogManager.java:25 LL(1)? false
2023-10-30 17:35:48:357 LL1 LogManager.java:25 
DECISION 28 in rule appendstmt
2023-10-30 17:35:48:357 LL1 LogManager.java:25 look=[61, {<EOF>, 6, 10..11, 13..15, 17..23, 30, 32, 35, 56}]
2023-10-30 17:35:48:357 LL1 LogManager.java:25 LL(1)? true
2023-10-30 17:35:48:357 LL1 LogManager.java:25 
DECISION 29 in rule removelaststmt
2023-10-30 17:35:48:357 LL1 LogManager.java:25 look=[61, {<EOF>, 6, 10..11, 13..15, 17..23, 30, 32, 35, 56}]
2023-10-30 17:35:48:357 LL1 LogManager.java:25 LL(1)? true
2023-10-30 17:35:48:358 LL1 LogManager.java:25 
DECISION 30 in rule removestmt
2023-10-30 17:35:48:358 LL1 LogManager.java:25 look=[61, {<EOF>, 6, 10..11, 13..15, 17..23, 30, 32, 35, 56}]
2023-10-30 17:35:48:358 LL1 LogManager.java:25 LL(1)? true
2023-10-30 17:35:48:358 LL1 LogManager.java:25 
DECISION 31 in rule assignationvecstmt
2023-10-30 17:35:48:358 LL1 LogManager.java:25 look=[61, {<EOF>, 6, 10..11, 13..15, 17..23, 30, 32, 35, 56}]
2023-10-30 17:35:48:358 LL1 LogManager.java:25 LL(1)? true
2023-10-30 17:35:48:358 LL1 LogManager.java:25 
DECISION 32 in rule declarematrixstmt
2023-10-30 17:35:48:359 LL1 LogManager.java:25 look=[61, <EOF>]
2023-10-30 17:35:48:359 LL1 LogManager.java:25 LL(1)? true
2023-10-30 17:35:48:359 LL1 LogManager.java:25 
DECISION 33 in rule declarefuncstmt
2023-10-30 17:35:48:359 LL1 LogManager.java:25 look=[30, 30, 30, 30]
2023-10-30 17:35:48:359 LL1 LogManager.java:25 LL(1)? false
2023-10-30 17:35:48:359 LL1 LogManager.java:25 
DECISION 34 in rule listParamsFunc
2023-10-30 17:35:48:359 LL1 LogManager.java:25 look=[null, 54]
2023-10-30 17:35:48:359 LL1 LogManager.java:25 LL(1)? false
2023-10-30 17:35:48:359 LL1 LogManager.java:25 
DECISION 35 in rule parameterfuncstmt
2023-10-30 17:35:48:359 LL1 LogManager.java:25 look=[31, 62]
2023-10-30 17:35:48:359 LL1 LogManager.java:25 LL(1)? true
2023-10-30 17:35:48:359 LL1 LogManager.java:25 
DECISION 36 in rule parameterfuncstmt
2023-10-30 17:35:48:360 LL1 LogManager.java:25 look=[{35, 64}, {35, 64}, 35]
2023-10-30 17:35:48:360 LL1 LogManager.java:25 LL(1)? false
2023-10-30 17:35:48:360 LL1 LogManager.java:25 
DECISION 37 in rule listStruct
2023-10-30 17:35:48:360 LL1 LogManager.java:25 look=[6, null]
2023-10-30 17:35:48:360 LL1 LogManager.java:25 LL(1)? false
2023-10-30 17:35:48:360 LL1 LogManager.java:25 
DECISION 38 in rule listStruct
2023-10-30 17:35:48:360 LL1 LogManager.java:25 look=[null, 56]
2023-10-30 17:35:48:360 LL1 LogManager.java:25 LL(1)? false
2023-10-30 17:35:48:360 LL1 LogManager.java:25 
DECISION 39 in rule expr
2023-10-30 17:35:48:360 LL1 LogManager.java:25 look=[38, 51, 53, 33, 34, 8, 9, 7, 35, 35, 35, 35, 2, 3, 1, 35, 35, 35]
2023-10-30 17:35:48:360 LL1 LogManager.java:25 LL(1)? false
2023-10-30 17:35:48:360 LL1 LogManager.java:25 
DECISION 40 in rule expr
2023-10-30 17:35:48:360 LL1 LogManager.java:25 look=[null, null, null, null, null, null, null]
2023-10-30 17:35:48:360 LL1 LogManager.java:25 LL(1)? false
2023-10-30 17:35:48:360 LL1 LogManager.java:25 
DECISION 41 in rule expr
2023-10-30 17:35:48:360 LL1 LogManager.java:25 look=[null, null]
2023-10-30 17:35:48:360 LL1 LogManager.java:25 LL(1)? false
2023-10-30 17:35:48:360 LL1 LogManager.java:25 
DECISION 42 in rule accessstructstmt
2023-10-30 17:35:48:360 LL1 LogManager.java:25 look=[35, 35]
2023-10-30 17:35:48:360 LL1 LogManager.java:25 LL(1)? false
2023-10-30 17:35:48:360 LL1 LogManager.java:25 
DECISION 43 in rule accessfuncstmt
2023-10-30 17:35:48:360 LL1 LogManager.java:25 look=[35, 35]
2023-10-30 17:35:48:360 LL1 LogManager.java:25 LL(1)? false
2023-10-30 17:35:48:360 LL1 LogManager.java:25 
DECISION 44 in rule increaseanddecreasestmt
2023-10-30 17:35:48:361 LL1 LogManager.java:25 look=[61, {<EOF>, 6, 10..11, 13..15, 17..23, 30, 32, 35, 56}]
2023-10-30 17:35:48:361 LL1 LogManager.java:25 LL(1)? true
2023-10-30 17:35:48:361 LL1 LogManager.java:25 
DECISION 45 in rule increaseanddecreasestmt
2023-10-30 17:35:48:361 LL1 LogManager.java:25 look=[61, {<EOF>, 6, 10..11, 13..15, 17..23, 30, 32, 35, 56}]
2023-10-30 17:35:48:361 LL1 LogManager.java:25 LL(1)? true
2023-10-30 17:35:48:361 LL1 LogManager.java:25 
DECISION 46 in rule increaseanddecreasestmt
2023-10-30 17:35:48:361 LL1 LogManager.java:25 look=[35, 35]
2023-10-30 17:35:48:361 LL1 LogManager.java:25 LL(1)? false
2023-10-30 17:35:48:361 LL1 LogManager.java:25 
DECISION 47 in rule type
2023-10-30 17:35:48:362 LL1 LogManager.java:25 look=[1, 2, 3, 4, 5, 35]
2023-10-30 17:35:48:362 LL1 LogManager.java:25 LL(1)? true
2023-10-30 17:35:48:362 LL1 LogManager.java:25 
DECISION 48 in rule listParams
2023-10-30 17:35:48:362 LL1 LogManager.java:25 look=[65, 35, {1..3, 7..9, 33..35, 38, 51, 53}]
2023-10-30 17:35:48:362 LL1 LogManager.java:25 LL(1)? false
2023-10-30 17:35:48:362 LL1 LogManager.java:25 
DECISION 49 in rule listParams
2023-10-30 17:35:48:362 LL1 LogManager.java:25 look=[65, 35, {1..3, 7..9, 33..35, 38, 51, 53}]
2023-10-30 17:35:48:362 LL1 LogManager.java:25 LL(1)? false
2023-10-30 17:35:48:362 LL1 LogManager.java:25 
DECISION 50 in rule listParams
2023-10-30 17:35:48:362 LL1 LogManager.java:25 look=[null, {54, 63}]
2023-10-30 17:35:48:362 LL1 LogManager.java:25 LL(1)? false
2023-10-30 17:35:48:362 LL1 LogManager.java:25 
DECISION 51 in rule listStructExp
2023-10-30 17:35:48:362 LL1 LogManager.java:25 look=[35, null]
2023-10-30 17:35:48:362 LL1 LogManager.java:25 LL(1)? false
2023-10-30 17:35:48:362 LL1 LogManager.java:25 
DECISION 52 in rule listStructExp
2023-10-30 17:35:48:362 LL1 LogManager.java:25 look=[60, 35]
2023-10-30 17:35:48:362 LL1 LogManager.java:25 LL(1)? true
2023-10-30 17:35:48:362 LL1 LogManager.java:25 
DECISION 53 in rule listStructExp
2023-10-30 17:35:48:362 LL1 LogManager.java:25 look=[null, {54, 56}]
2023-10-30 17:35:48:362 LL1 LogManager.java:25 LL(1)? false
2023-10-30 17:35:48:368 action-translator LogManager.java:25 translate 
    import "Server/Interfaces"
    import "Server/Environment"
    import "Server/Expression"
    import "Server/Instruction"
    import "strings"

2023-10-30 17:35:48:379 action-translator LogManager.java:25 translate $code = $block.blk
2023-10-30 17:35:48:379 action-translator LogManager.java:25 attr [@-1,1:4='code',<0>,18:13]
2023-10-30 17:35:48:380 action-translator LogManager.java:25 qattr [@-1,9:13='block',<0>,18:21].[@-1,15:17='blk',<0>,18:27]
2023-10-30 17:35:48:381 action-translator LogManager.java:25 translate 
$blk = []interface{}{}
    var listInt []IInstructionContext
  
2023-10-30 17:35:48:381 action-translator LogManager.java:25 attr [@-1,3:5='blk',<0>,23:1]
2023-10-30 17:35:48:383 action-translator LogManager.java:25 translate 
        listInt = localctx.(*BlockContext).GetIns()
        for _, e := range listInt {
            $blk = append($blk, e.GetInst())
            
        }
    
2023-10-30 17:35:48:383 action-translator LogManager.java:25 attr [@-1,105:107='blk',<0>,30:13]
2023-10-30 17:35:48:383 action-translator LogManager.java:25 attr [@-1,119:121='blk',<0>,30:27]
2023-10-30 17:35:48:384 action-translator LogManager.java:25 translate  $inst = $printstmt.prnt
2023-10-30 17:35:48:384 action-translator LogManager.java:25 attr [@-1,2:5='inst',<0>,37:14]
2023-10-30 17:35:48:384 action-translator LogManager.java:25 qattr [@-1,10:18='printstmt',<0>,37:22].[@-1,20:23='prnt',<0>,37:32]
2023-10-30 17:35:48:384 action-translator LogManager.java:25 translate $inst = $declarestmt.dec
2023-10-30 17:35:48:384 action-translator LogManager.java:25 attr [@-1,1:4='inst',<0>,38:15]
2023-10-30 17:35:48:385 action-translator LogManager.java:25 qattr [@-1,9:19='declarestmt',<0>,38:23].[@-1,21:23='dec',<0>,38:35]
2023-10-30 17:35:48:385 action-translator LogManager.java:25 translate $inst = $constantstmt.const
2023-10-30 17:35:48:385 action-translator LogManager.java:25 attr [@-1,1:4='inst',<0>,39:16]
2023-10-30 17:35:48:385 action-translator LogManager.java:25 qattr [@-1,9:20='constantstmt',<0>,39:24].[@-1,22:26='const',<0>,39:37]
2023-10-30 17:35:48:385 action-translator LogManager.java:25 translate $inst = $assignationstmt.assign
2023-10-30 17:35:48:385 action-translator LogManager.java:25 attr [@-1,1:4='inst',<0>,40:19]
2023-10-30 17:35:48:386 action-translator LogManager.java:25 qattr [@-1,9:23='assignationstmt',<0>,40:27].[@-1,25:30='assign',<0>,40:43]
2023-10-30 17:35:48:386 action-translator LogManager.java:25 translate $inst = $increaseanddecreasestmt.increasedecrease
2023-10-30 17:35:48:386 action-translator LogManager.java:25 attr [@-1,1:4='inst',<0>,41:27]
2023-10-30 17:35:48:386 action-translator LogManager.java:25 qattr [@-1,9:31='increaseanddecreasestmt',<0>,41:35].[@-1,33:48='increasedecrease',<0>,41:59]
2023-10-30 17:35:48:386 action-translator LogManager.java:25 translate  $inst = $ifstmt.ift 
2023-10-30 17:35:48:387 action-translator LogManager.java:25 attr [@-1,2:5='inst',<0>,42:11]
2023-10-30 17:35:48:387 action-translator LogManager.java:25 qattr [@-1,10:15='ifstmt',<0>,42:19].[@-1,17:19='ift',<0>,42:26]
2023-10-30 17:35:48:387 action-translator LogManager.java:25 translate $inst = $whilestmt.while
2023-10-30 17:35:48:387 action-translator LogManager.java:25 attr [@-1,1:4='inst',<0>,43:13]
2023-10-30 17:35:48:387 action-translator LogManager.java:25 qattr [@-1,9:17='whilestmt',<0>,43:21].[@-1,19:23='while',<0>,43:31]
2023-10-30 17:35:48:387 action-translator LogManager.java:25 translate $inst = $forstmt.for
2023-10-30 17:35:48:387 action-translator LogManager.java:25 attr [@-1,1:4='inst',<0>,44:11]
2023-10-30 17:35:48:387 action-translator LogManager.java:25 qattr [@-1,9:15='forstmt',<0>,44:19].[@-1,17:19='for',<0>,44:27]
2023-10-30 17:35:48:388 action-translator LogManager.java:25 translate $inst = $switchstmt.switch
2023-10-30 17:35:48:388 action-translator LogManager.java:25 attr [@-1,1:4='inst',<0>,45:14]
2023-10-30 17:35:48:388 action-translator LogManager.java:25 qattr [@-1,9:18='switchstmt',<0>,45:22].[@-1,20:25='switch',<0>,45:33]
2023-10-30 17:35:48:388 action-translator LogManager.java:25 translate $inst = $guardstmt.gua
2023-10-30 17:35:48:388 action-translator LogManager.java:25 attr [@-1,1:4='inst',<0>,46:13]
2023-10-30 17:35:48:388 action-translator LogManager.java:25 qattr [@-1,9:17='guardstmt',<0>,46:21].[@-1,19:21='gua',<0>,46:31]
2023-10-30 17:35:48:389 action-translator LogManager.java:25 translate $inst = $transferstmt.tran
2023-10-30 17:35:48:389 action-translator LogManager.java:25 attr [@-1,1:4='inst',<0>,47:16]
2023-10-30 17:35:48:389 action-translator LogManager.java:25 qattr [@-1,9:20='transferstmt',<0>,47:24].[@-1,22:25='tran',<0>,47:37]
2023-10-30 17:35:48:389 action-translator LogManager.java:25 translate $inst = $declarevectorstmt.decvec
2023-10-30 17:35:48:390 action-translator LogManager.java:25 attr [@-1,1:4='inst',<0>,48:21]
2023-10-30 17:35:48:390 action-translator LogManager.java:25 qattr [@-1,9:25='declarevectorstmt',<0>,48:29].[@-1,27:32='decvec',<0>,48:47]
2023-10-30 17:35:48:390 action-translator LogManager.java:25 translate $inst = $appendstmt.app
2023-10-30 17:35:48:390 action-translator LogManager.java:25 attr [@-1,1:4='inst',<0>,49:17]
2023-10-30 17:35:48:391 action-translator LogManager.java:25 qattr [@-1,9:18='appendstmt',<0>,49:25].[@-1,20:22='app',<0>,49:36]
2023-10-30 17:35:48:391 action-translator LogManager.java:25 translate $inst = $removelaststmt.removl
2023-10-30 17:35:48:391 action-translator LogManager.java:25 attr [@-1,1:4='inst',<0>,50:18]
2023-10-30 17:35:48:391 action-translator LogManager.java:25 qattr [@-1,9:22='removelaststmt',<0>,50:26].[@-1,24:29='removl',<0>,50:41]
2023-10-30 17:35:48:391 action-translator LogManager.java:25 translate $inst = $removestmt.remov
2023-10-30 17:35:48:391 action-translator LogManager.java:25 attr [@-1,1:4='inst',<0>,51:14]
2023-10-30 17:35:48:391 action-translator LogManager.java:25 qattr [@-1,9:18='removestmt',<0>,51:22].[@-1,20:24='remov',<0>,51:33]
2023-10-30 17:35:48:392 action-translator LogManager.java:25 translate $inst = $assignationvecstmt.assignvec
2023-10-30 17:35:48:392 action-translator LogManager.java:25 attr [@-1,1:4='inst',<0>,52:22]
2023-10-30 17:35:48:392 action-translator LogManager.java:25 qattr [@-1,9:26='assignationvecstmt',<0>,52:30].[@-1,28:36='assignvec',<0>,52:49]
2023-10-30 17:35:48:392 action-translator LogManager.java:25 translate $inst = $declarefuncstmt.decfunc
2023-10-30 17:35:48:392 action-translator LogManager.java:25 attr [@-1,1:4='inst',<0>,53:19]
2023-10-30 17:35:48:392 action-translator LogManager.java:25 qattr [@-1,9:23='declarefuncstmt',<0>,53:27].[@-1,25:31='decfunc',<0>,53:43]
2023-10-30 17:35:48:392 action-translator LogManager.java:25 translate $inst = $accessfuncinstruction.accessfuncin
2023-10-30 17:35:48:393 action-translator LogManager.java:25 attr [@-1,1:4='inst',<0>,54:25]
2023-10-30 17:35:48:393 action-translator LogManager.java:25 qattr [@-1,9:29='accessfuncinstruction',<0>,54:33].[@-1,31:42='accessfuncin',<0>,54:55]
2023-10-30 17:35:48:394 action-translator LogManager.java:25 translate $inst = $declarestructstmt.decstruct 
2023-10-30 17:35:48:394 action-translator LogManager.java:25 attr [@-1,1:4='inst',<0>,55:25]
2023-10-30 17:35:48:394 action-translator LogManager.java:25 qattr [@-1,9:25='declarestructstmt',<0>,55:33].[@-1,27:35='decstruct',<0>,55:51]
2023-10-30 17:35:48:394 action-translator LogManager.java:25 translate $inst = $assignationstructstmt.assignstruct
2023-10-30 17:35:48:394 action-translator LogManager.java:25 attr [@-1,1:4='inst',<0>,56:25]
2023-10-30 17:35:48:394 action-translator LogManager.java:25 qattr [@-1,9:29='assignationstructstmt',<0>,56:33].[@-1,31:42='assignstruct',<0>,56:55]
2023-10-30 17:35:48:397 action-translator LogManager.java:25 translate  $prnt = instructions.NewPrint($PRINT.line, $PRINT.pos, $listParams.l)
2023-10-30 17:35:48:397 action-translator LogManager.java:25 attr [@-1,2:5='prnt',<0>,60:43]
2023-10-30 17:35:48:397 action-translator LogManager.java:25 qattr [@-1,32:36='PRINT',<0>,60:73].[@-1,38:41='line',<0>,60:79]
2023-10-30 17:35:48:397 action-translator LogManager.java:25 qattr [@-1,45:49='PRINT',<0>,60:86].[@-1,51:53='pos',<0>,60:92]
2023-10-30 17:35:48:398 action-translator LogManager.java:25 qattr [@-1,57:66='listParams',<0>,60:98].[@-1,68:68='l',<0>,60:109]
2023-10-30 17:35:48:398 action-translator LogManager.java:25 translate $dec = instructions.NewTodeclare($VAR.line, $VAR.pos, $ID.text, $type.t, $expr.e, false)
2023-10-30 17:35:48:398 action-translator LogManager.java:25 attr [@-1,1:3='dec',<0>,65:41]
2023-10-30 17:35:48:398 action-translator LogManager.java:25 qattr [@-1,34:36='VAR',<0>,65:74].[@-1,38:41='line',<0>,65:78]
2023-10-30 17:35:48:398 action-translator LogManager.java:25 qattr [@-1,45:47='VAR',<0>,65:85].[@-1,49:51='pos',<0>,65:89]
2023-10-30 17:35:48:398 action-translator LogManager.java:25 qattr [@-1,55:56='ID',<0>,65:95].[@-1,58:61='text',<0>,65:98]
2023-10-30 17:35:48:398 action-translator LogManager.java:25 qattr [@-1,65:68='type',<0>,65:105].[@-1,70:70='t',<0>,65:110]
2023-10-30 17:35:48:398 action-translator LogManager.java:25 qattr [@-1,74:77='expr',<0>,65:114].[@-1,79:79='e',<0>,65:119]
2023-10-30 17:35:48:400 action-translator LogManager.java:25 translate $dec = instructions.NewTodeclare($VAR.line, $VAR.pos, $ID.text, environment.NULL, $expr.e, false)
2023-10-30 17:35:48:400 action-translator LogManager.java:25 attr [@-1,1:3='dec',<0>,66:26]
2023-10-30 17:35:48:400 action-translator LogManager.java:25 qattr [@-1,34:36='VAR',<0>,66:59].[@-1,38:41='line',<0>,66:63]
2023-10-30 17:35:48:400 action-translator LogManager.java:25 qattr [@-1,45:47='VAR',<0>,66:70].[@-1,49:51='pos',<0>,66:74]
2023-10-30 17:35:48:400 action-translator LogManager.java:25 qattr [@-1,55:56='ID',<0>,66:80].[@-1,58:61='text',<0>,66:83]
2023-10-30 17:35:48:400 action-translator LogManager.java:25 qattr [@-1,83:86='expr',<0>,66:108].[@-1,88:88='e',<0>,66:113]
2023-10-30 17:35:48:400 action-translator LogManager.java:25 translate $dec = instructions.NewTodeclare($VAR.line, $VAR.pos, $ID.text, $type.t, nil, false)
2023-10-30 17:35:48:400 action-translator LogManager.java:25 attr [@-1,1:3='dec',<0>,67:42]
2023-10-30 17:35:48:400 action-translator LogManager.java:25 qattr [@-1,34:36='VAR',<0>,67:75].[@-1,38:41='line',<0>,67:79]
2023-10-30 17:35:48:401 action-translator LogManager.java:25 qattr [@-1,45:47='VAR',<0>,67:86].[@-1,49:51='pos',<0>,67:90]
2023-10-30 17:35:48:401 action-translator LogManager.java:25 qattr [@-1,55:56='ID',<0>,67:96].[@-1,58:61='text',<0>,67:99]
2023-10-30 17:35:48:401 action-translator LogManager.java:25 qattr [@-1,65:68='type',<0>,67:106].[@-1,70:70='t',<0>,67:111]
2023-10-30 17:35:48:401 action-translator LogManager.java:25 translate $const = instructions.NewTodeclare($LET.line, $LET.pos, $ID.text, $type.t, $expr.e, true)
2023-10-30 17:35:48:401 action-translator LogManager.java:25 attr [@-1,1:5='const',<0>,71:41]
2023-10-30 17:35:48:402 action-translator LogManager.java:25 qattr [@-1,36:38='LET',<0>,71:76].[@-1,40:43='line',<0>,71:80]
2023-10-30 17:35:48:402 action-translator LogManager.java:25 qattr [@-1,47:49='LET',<0>,71:87].[@-1,51:53='pos',<0>,71:91]
2023-10-30 17:35:48:402 action-translator LogManager.java:25 qattr [@-1,57:58='ID',<0>,71:97].[@-1,60:63='text',<0>,71:100]
2023-10-30 17:35:48:402 action-translator LogManager.java:25 qattr [@-1,67:70='type',<0>,71:107].[@-1,72:72='t',<0>,71:112]
2023-10-30 17:35:48:402 action-translator LogManager.java:25 qattr [@-1,76:79='expr',<0>,71:116].[@-1,81:81='e',<0>,71:121]
2023-10-30 17:35:48:402 action-translator LogManager.java:25 translate $const = instructions.NewTodeclare($LET.line, $LET.pos, $ID.text, environment.NULL, $expr.e, true)
2023-10-30 17:35:48:403 action-translator LogManager.java:25 attr [@-1,1:5='const',<0>,72:26]
2023-10-30 17:35:48:403 action-translator LogManager.java:25 qattr [@-1,36:38='LET',<0>,72:61].[@-1,40:43='line',<0>,72:65]
2023-10-30 17:35:48:403 action-translator LogManager.java:25 qattr [@-1,47:49='LET',<0>,72:72].[@-1,51:53='pos',<0>,72:76]
2023-10-30 17:35:48:403 action-translator LogManager.java:25 qattr [@-1,57:58='ID',<0>,72:82].[@-1,60:63='text',<0>,72:85]
2023-10-30 17:35:48:403 action-translator LogManager.java:25 qattr [@-1,85:88='expr',<0>,72:110].[@-1,90:90='e',<0>,72:115]
2023-10-30 17:35:48:404 action-translator LogManager.java:25 translate 
$blkef = []interface{}{}
    var listifs []IIfstmtContext
    
  
2023-10-30 17:35:48:404 action-translator LogManager.java:25 attr [@-1,3:7='blkef',<0>,79:1]
2023-10-30 17:35:48:404 action-translator LogManager.java:25 translate    
        listifs = localctx.(*BlockelifsContext).GetElif()
        for _, a := range listifs {
            $blkef = append($blkef, a.GetIft())
            
        }
    
2023-10-30 17:35:48:404 action-translator LogManager.java:25 attr [@-1,114:118='blkef',<0>,88:13]
2023-10-30 17:35:48:404 action-translator LogManager.java:25 attr [@-1,130:134='blkef',<0>,88:29]
2023-10-30 17:35:48:406 action-translator LogManager.java:25 translate  $ift = instructions.NewIf($IF.line, $IF.pos, $expr.e, $ifb.blk, nil); 
                                        $el = $ifb.blk
2023-10-30 17:35:48:407 action-translator LogManager.java:25 setAttr [@-1,2:4='ift',<0>,95:41] [@-1,7:68=' instructions.NewIf($IF.line, $IF.pos, $expr.e, $ifb.blk, nil)',<0>,95:46]
2023-10-30 17:35:48:407 action-translator LogManager.java:25 translate  instructions.NewIf($IF.line, $IF.pos, $expr.e, $ifb.blk, nil)
2023-10-30 17:35:48:407 action-translator LogManager.java:25 qattr [@-1,21:22='IF',<0>,95:60].[@-1,24:27='line',<0>,95:63]
2023-10-30 17:35:48:407 action-translator LogManager.java:25 qattr [@-1,31:32='IF',<0>,95:70].[@-1,34:36='pos',<0>,95:73]
2023-10-30 17:35:48:407 action-translator LogManager.java:25 qattr [@-1,40:43='expr',<0>,95:79].[@-1,45:45='e',<0>,95:84]
2023-10-30 17:35:48:408 action-translator LogManager.java:25 qattr [@-1,49:51='ifb',<0>,95:88].[@-1,53:55='blk',<0>,95:92]
2023-10-30 17:35:48:408 action-translator LogManager.java:25 attr [@-1,114:115='el',<0>,96:41]
2023-10-30 17:35:48:408 action-translator LogManager.java:25 qattr [@-1,120:122='ifb',<0>,96:47].[@-1,124:126='blk',<0>,96:51]
2023-10-30 17:35:48:408 action-translator LogManager.java:25 translate  $ift = instructions.NewIf($IF.line, $IF.pos, $expr.e, $ifelseblck.blk, $elseifblck.blk); 
                                                                                        $el = $ifelseblck.blk;
                                                                                        
                                                                                        
2023-10-30 17:35:48:408 action-translator LogManager.java:25 setAttr [@-1,2:4='ift',<0>,97:88] [@-1,7:87=' instructions.NewIf($IF.line, $IF.pos, $expr.e, $ifelseblck.blk, $elseifblck.blk)',<0>,97:93]
2023-10-30 17:35:48:408 action-translator LogManager.java:25 translate  instructions.NewIf($IF.line, $IF.pos, $expr.e, $ifelseblck.blk, $elseifblck.blk)
2023-10-30 17:35:48:408 action-translator LogManager.java:25 qattr [@-1,21:22='IF',<0>,97:107].[@-1,24:27='line',<0>,97:110]
2023-10-30 17:35:48:408 action-translator LogManager.java:25 qattr [@-1,31:32='IF',<0>,97:117].[@-1,34:36='pos',<0>,97:120]
2023-10-30 17:35:48:408 action-translator LogManager.java:25 qattr [@-1,40:43='expr',<0>,97:126].[@-1,45:45='e',<0>,97:131]
2023-10-30 17:35:48:408 action-translator LogManager.java:25 qattr [@-1,49:58='ifelseblck',<0>,97:135].[@-1,60:62='blk',<0>,97:146]
2023-10-30 17:35:48:408 action-translator LogManager.java:25 qattr [@-1,66:75='elseifblck',<0>,97:152].[@-1,77:79='blk',<0>,97:163]
2023-10-30 17:35:48:408 action-translator LogManager.java:25 setAttr [@-1,181:182='el',<0>,98:89] [@-1,185:200=' $ifelseblck.blk',<0>,98:93]
2023-10-30 17:35:48:409 action-translator LogManager.java:25 translate  $ifelseblck.blk
2023-10-30 17:35:48:409 action-translator LogManager.java:25 qattr [@-1,2:11='ifelseblck',<0>,97:88].[@-1,13:15='blk',<0>,97:99]
2023-10-30 17:35:48:410 action-translator LogManager.java:25 translate  $ift = instructions.NewIf($IF.line, $IF.pos, $expr.e, $elif.blk, $blockelifs.blkef); 
2023-10-30 17:35:48:410 action-translator LogManager.java:25 setAttr [@-1,2:4='ift',<0>,101:59] [@-1,7:83=' instructions.NewIf($IF.line, $IF.pos, $expr.e, $elif.blk, $blockelifs.blkef)',<0>,101:64]
2023-10-30 17:35:48:410 action-translator LogManager.java:25 translate  instructions.NewIf($IF.line, $IF.pos, $expr.e, $elif.blk, $blockelifs.blkef)
2023-10-30 17:35:48:410 action-translator LogManager.java:25 qattr [@-1,21:22='IF',<0>,101:78].[@-1,24:27='line',<0>,101:81]
2023-10-30 17:35:48:410 action-translator LogManager.java:25 qattr [@-1,31:32='IF',<0>,101:88].[@-1,34:36='pos',<0>,101:91]
2023-10-30 17:35:48:410 action-translator LogManager.java:25 qattr [@-1,40:43='expr',<0>,101:97].[@-1,45:45='e',<0>,101:102]
2023-10-30 17:35:48:410 action-translator LogManager.java:25 qattr [@-1,49:52='elif',<0>,101:106].[@-1,54:56='blk',<0>,101:111]
2023-10-30 17:35:48:410 action-translator LogManager.java:25 qattr [@-1,60:69='blockelifs',<0>,101:117].[@-1,71:75='blkef',<0>,101:128]
2023-10-30 17:35:48:412 action-translator LogManager.java:25 translate  $switch = instructions.NewSwitch($SWITCH.line, $SWITCH.pos, $expr.e, nil,  nil, $block.blk);
2023-10-30 17:35:48:412 action-translator LogManager.java:25 setAttr [@-1,2:7='switch',<0>,143:58] [@-1,10:91=' instructions.NewSwitch($SWITCH.line, $SWITCH.pos, $expr.e, nil,  nil, $block.blk)',<0>,143:66]
2023-10-30 17:35:48:412 action-translator LogManager.java:25 translate  instructions.NewSwitch($SWITCH.line, $SWITCH.pos, $expr.e, nil,  nil, $block.blk)
2023-10-30 17:35:48:412 action-translator LogManager.java:25 qattr [@-1,25:30='SWITCH',<0>,143:81].[@-1,32:35='line',<0>,143:88]
2023-10-30 17:35:48:412 action-translator LogManager.java:25 qattr [@-1,39:44='SWITCH',<0>,143:95].[@-1,46:48='pos',<0>,143:102]
2023-10-30 17:35:48:412 action-translator LogManager.java:25 qattr [@-1,52:55='expr',<0>,143:108].[@-1,57:57='e',<0>,143:113]
2023-10-30 17:35:48:412 action-translator LogManager.java:25 qattr [@-1,72:76='block',<0>,143:128].[@-1,78:80='blk',<0>,143:134]
2023-10-30 17:35:48:413 action-translator LogManager.java:25 translate $switch = instructions.NewSwitch($SWITCH.line, $SWITCH.pos, $expr.e, nil, $casestmt.cas, nil);
2023-10-30 17:35:48:413 action-translator LogManager.java:25 setAttr [@-1,1:6='switch',<0>,144:44] [@-1,9:92=' instructions.NewSwitch($SWITCH.line, $SWITCH.pos, $expr.e, nil, $casestmt.cas, nil)',<0>,144:52]
2023-10-30 17:35:48:413 action-translator LogManager.java:25 translate  instructions.NewSwitch($SWITCH.line, $SWITCH.pos, $expr.e, nil, $casestmt.cas, nil)
2023-10-30 17:35:48:413 action-translator LogManager.java:25 qattr [@-1,25:30='SWITCH',<0>,144:68].[@-1,32:35='line',<0>,144:75]
2023-10-30 17:35:48:413 action-translator LogManager.java:25 qattr [@-1,39:44='SWITCH',<0>,144:82].[@-1,46:48='pos',<0>,144:89]
2023-10-30 17:35:48:413 action-translator LogManager.java:25 qattr [@-1,52:55='expr',<0>,144:95].[@-1,57:57='e',<0>,144:100]
2023-10-30 17:35:48:413 action-translator LogManager.java:25 qattr [@-1,66:73='casestmt',<0>,144:109].[@-1,75:77='cas',<0>,144:118]
2023-10-30 17:35:48:414 action-translator LogManager.java:25 translate  $cas = instructions.NewCase($CASE.line,$CASE.pos, $expr.e,$block.blk, $blockcases.blkcase)
                                
2023-10-30 17:35:48:414 action-translator LogManager.java:25 attr [@-1,2:4='cas',<0>,147:41]
2023-10-30 17:35:48:414 action-translator LogManager.java:25 qattr [@-1,30:33='CASE',<0>,147:69].[@-1,35:38='line',<0>,147:74]
2023-10-30 17:35:48:414 action-translator LogManager.java:25 qattr [@-1,41:44='CASE',<0>,147:80].[@-1,46:48='pos',<0>,147:85]
2023-10-30 17:35:48:414 action-translator LogManager.java:25 qattr [@-1,52:55='expr',<0>,147:91].[@-1,57:57='e',<0>,147:96]
2023-10-30 17:35:48:415 action-translator LogManager.java:25 qattr [@-1,60:64='block',<0>,147:99].[@-1,66:68='blk',<0>,147:105]
2023-10-30 17:35:48:415 action-translator LogManager.java:25 qattr [@-1,72:81='blockcases',<0>,147:111].[@-1,83:89='blkcase',<0>,147:122]
2023-10-30 17:35:48:415 action-translator LogManager.java:25 translate  $cas = instructions.NewCase($CASE.line,$CASE.pos, $expr.e,$sen.blk, $def.blk)
2023-10-30 17:35:48:415 action-translator LogManager.java:25 attr [@-1,2:4='cas',<0>,149:63]
2023-10-30 17:35:48:415 action-translator LogManager.java:25 qattr [@-1,30:33='CASE',<0>,149:91].[@-1,35:38='line',<0>,149:96]
2023-10-30 17:35:48:415 action-translator LogManager.java:25 qattr [@-1,41:44='CASE',<0>,149:102].[@-1,46:48='pos',<0>,149:107]
2023-10-30 17:35:48:415 action-translator LogManager.java:25 qattr [@-1,52:55='expr',<0>,149:113].[@-1,57:57='e',<0>,149:118]
2023-10-30 17:35:48:415 action-translator LogManager.java:25 qattr [@-1,60:62='sen',<0>,149:121].[@-1,64:66='blk',<0>,149:125]
2023-10-30 17:35:48:415 action-translator LogManager.java:25 qattr [@-1,70:72='def',<0>,149:131].[@-1,74:76='blk',<0>,149:135]
2023-10-30 17:35:48:416 action-translator LogManager.java:25 translate 
    $blkcase = []interface{}{}
    var listcases []ICasestmtContext
  
2023-10-30 17:35:48:416 action-translator LogManager.java:25 attr [@-1,7:13='blkcase',<0>,153:5]
2023-10-30 17:35:48:416 action-translator LogManager.java:25 translate 
        listcases = localctx.(*BlockcasesContext).GetCasedef()
        for _, a := range listcases {
            $blkcase = append($blkcase, a.GetCas())
      
        }
    
2023-10-30 17:35:48:416 action-translator LogManager.java:25 attr [@-1,118:124='blkcase',<0>,160:13]
2023-10-30 17:35:48:417 action-translator LogManager.java:25 attr [@-1,136:142='blkcase',<0>,160:31]
2023-10-30 17:35:48:417 action-translator LogManager.java:25 translate $assign = instructions.NewAssignation($ID.line, $ID.pos,  $ID.text, $expr.e)
2023-10-30 17:35:48:417 action-translator LogManager.java:25 attr [@-1,1:6='assign',<0>,168:22]
2023-10-30 17:35:48:417 action-translator LogManager.java:25 qattr [@-1,39:40='ID',<0>,168:60].[@-1,42:45='line',<0>,168:63]
2023-10-30 17:35:48:417 action-translator LogManager.java:25 qattr [@-1,49:50='ID',<0>,168:70].[@-1,52:54='pos',<0>,168:73]
2023-10-30 17:35:48:417 action-translator LogManager.java:25 qattr [@-1,59:60='ID',<0>,168:80].[@-1,62:65='text',<0>,168:83]
2023-10-30 17:35:48:417 action-translator LogManager.java:25 qattr [@-1,69:72='expr',<0>,168:90].[@-1,74:74='e',<0>,168:95]
2023-10-30 17:35:48:418 action-translator LogManager.java:25 translate $assignstruct = instructions.NewAssignationStruct($ID.line, $ID.pos, $ID.text, $second.text, $expr.e)
2023-10-30 17:35:48:418 action-translator LogManager.java:25 attr [@-1,1:12='assignstruct',<0>,172:38]
2023-10-30 17:35:48:418 action-translator LogManager.java:25 qattr [@-1,51:52='ID',<0>,172:88].[@-1,54:57='line',<0>,172:91]
2023-10-30 17:35:48:418 action-translator LogManager.java:25 qattr [@-1,61:62='ID',<0>,172:98].[@-1,64:66='pos',<0>,172:101]
2023-10-30 17:35:48:419 action-translator LogManager.java:25 qattr [@-1,70:71='ID',<0>,172:107].[@-1,73:76='text',<0>,172:110]
2023-10-30 17:35:48:419 action-translator LogManager.java:25 qattr [@-1,80:85='second',<0>,172:117].[@-1,87:90='text',<0>,172:124]
2023-10-30 17:35:48:419 action-translator LogManager.java:25 qattr [@-1,94:97='expr',<0>,172:131].[@-1,99:99='e',<0>,172:136]
2023-10-30 17:35:48:420 action-translator LogManager.java:25 translate $while = instructions.NewWhile($WHILE.line, $WHILE.pos,  $expr.e, $block.blk)
2023-10-30 17:35:48:420 action-translator LogManager.java:25 attr [@-1,1:5='while',<0>,176:38]
2023-10-30 17:35:48:420 action-translator LogManager.java:25 qattr [@-1,32:36='WHILE',<0>,176:69].[@-1,38:41='line',<0>,176:75]
2023-10-30 17:35:48:421 action-translator LogManager.java:25 qattr [@-1,45:49='WHILE',<0>,176:82].[@-1,51:53='pos',<0>,176:88]
2023-10-30 17:35:48:421 action-translator LogManager.java:25 qattr [@-1,58:61='expr',<0>,176:95].[@-1,63:63='e',<0>,176:100]
2023-10-30 17:35:48:421 action-translator LogManager.java:25 qattr [@-1,67:71='block',<0>,176:104].[@-1,73:75='blk',<0>,176:110]
2023-10-30 17:35:48:422 action-translator LogManager.java:25 translate $for = instructions.NewFor($FOR.line, $FOR.pos, $ID.text, $expr.e, nil, $block.blk)
2023-10-30 17:35:48:422 action-translator LogManager.java:25 attr [@-1,1:3='for',<0>,180:43]
2023-10-30 17:35:48:422 action-translator LogManager.java:25 qattr [@-1,28:30='FOR',<0>,180:70].[@-1,32:35='line',<0>,180:74]
2023-10-30 17:35:48:422 action-translator LogManager.java:25 qattr [@-1,39:41='FOR',<0>,180:81].[@-1,43:45='pos',<0>,180:85]
2023-10-30 17:35:48:422 action-translator LogManager.java:25 qattr [@-1,49:50='ID',<0>,180:91].[@-1,52:55='text',<0>,180:94]
2023-10-30 17:35:48:422 action-translator LogManager.java:25 qattr [@-1,59:62='expr',<0>,180:101].[@-1,64:64='e',<0>,180:106]
2023-10-30 17:35:48:422 action-translator LogManager.java:25 qattr [@-1,73:77='block',<0>,180:115].[@-1,79:81='blk',<0>,180:121]
2023-10-30 17:35:48:422 action-translator LogManager.java:25 translate $for = instructions.NewFor($FOR.line, $FOR.pos, $ID.text, $first.e, $second.e, $block.blk)
2023-10-30 17:35:48:422 action-translator LogManager.java:25 attr [@-1,1:3='for',<0>,181:72]
2023-10-30 17:35:48:423 action-translator LogManager.java:25 qattr [@-1,28:30='FOR',<0>,181:99].[@-1,32:35='line',<0>,181:103]
2023-10-30 17:35:48:423 action-translator LogManager.java:25 qattr [@-1,39:41='FOR',<0>,181:110].[@-1,43:45='pos',<0>,181:114]
2023-10-30 17:35:48:423 action-translator LogManager.java:25 qattr [@-1,49:50='ID',<0>,181:120].[@-1,52:55='text',<0>,181:123]
2023-10-30 17:35:48:423 action-translator LogManager.java:25 qattr [@-1,59:63='first',<0>,181:130].[@-1,65:65='e',<0>,181:136]
2023-10-30 17:35:48:423 action-translator LogManager.java:25 qattr [@-1,69:74='second',<0>,181:140].[@-1,76:76='e',<0>,181:147]
2023-10-30 17:35:48:423 action-translator LogManager.java:25 qattr [@-1,80:84='block',<0>,181:151].[@-1,86:88='blk',<0>,181:157]
2023-10-30 17:35:48:424 action-translator LogManager.java:25 translate $gua = instructions.NewGuard($GUARD.line, $GUARD.pos, $expr.e, $block.blk)
2023-10-30 17:35:48:424 action-translator LogManager.java:25 attr [@-1,1:3='gua',<0>,187:43]
2023-10-30 17:35:48:424 action-translator LogManager.java:25 qattr [@-1,30:34='GUARD',<0>,187:72].[@-1,36:39='line',<0>,187:78]
2023-10-30 17:35:48:424 action-translator LogManager.java:25 qattr [@-1,43:47='GUARD',<0>,187:85].[@-1,49:51='pos',<0>,187:91]
2023-10-30 17:35:48:424 action-translator LogManager.java:25 qattr [@-1,55:58='expr',<0>,187:97].[@-1,60:60='e',<0>,187:102]
2023-10-30 17:35:48:424 action-translator LogManager.java:25 qattr [@-1,64:68='block',<0>,187:106].[@-1,70:72='blk',<0>,187:112]
2023-10-30 17:35:48:425 action-translator LogManager.java:25 translate $tran = instructions.NewReturnIn($RETURN.line, $RETURN.pos, nil)
2023-10-30 17:35:48:425 action-translator LogManager.java:25 attr [@-1,1:4='tran',<0>,191:18]
2023-10-30 17:35:48:425 action-translator LogManager.java:25 qattr [@-1,34:39='RETURN',<0>,191:51].[@-1,41:44='line',<0>,191:58]
2023-10-30 17:35:48:425 action-translator LogManager.java:25 qattr [@-1,48:53='RETURN',<0>,191:65].[@-1,55:57='pos',<0>,191:72]
2023-10-30 17:35:48:426 action-translator LogManager.java:25 translate $tran = instructions.NewReturnIn($RETURN.line, $RETURN.pos, $expr.e)
2023-10-30 17:35:48:426 action-translator LogManager.java:25 attr [@-1,1:4='tran',<0>,192:23]
2023-10-30 17:35:48:426 action-translator LogManager.java:25 qattr [@-1,34:39='RETURN',<0>,192:56].[@-1,41:44='line',<0>,192:63]
2023-10-30 17:35:48:426 action-translator LogManager.java:25 qattr [@-1,48:53='RETURN',<0>,192:70].[@-1,55:57='pos',<0>,192:77]
2023-10-30 17:35:48:426 action-translator LogManager.java:25 qattr [@-1,61:64='expr',<0>,192:83].[@-1,66:66='e',<0>,192:88]
2023-10-30 17:35:48:426 action-translator LogManager.java:25 translate $tran = instructions.NewContinue($CONTINUE.line, $CONTINUE.pos)
2023-10-30 17:35:48:426 action-translator LogManager.java:25 attr [@-1,1:4='tran',<0>,193:20]
2023-10-30 17:35:48:426 action-translator LogManager.java:25 qattr [@-1,34:41='CONTINUE',<0>,193:53].[@-1,43:46='line',<0>,193:62]
2023-10-30 17:35:48:426 action-translator LogManager.java:25 qattr [@-1,50:57='CONTINUE',<0>,193:69].[@-1,59:61='pos',<0>,193:78]
2023-10-30 17:35:48:426 action-translator LogManager.java:25 translate $tran = instructions.NewBreak($BREAK.line, $BREAK.pos)
2023-10-30 17:35:48:427 action-translator LogManager.java:25 attr [@-1,1:4='tran',<0>,194:17]
2023-10-30 17:35:48:427 action-translator LogManager.java:25 qattr [@-1,31:35='BREAK',<0>,194:47].[@-1,37:40='line',<0>,194:53]
2023-10-30 17:35:48:427 action-translator LogManager.java:25 qattr [@-1,44:48='BREAK',<0>,194:60].[@-1,50:52='pos',<0>,194:66]
2023-10-30 17:35:48:428 action-translator LogManager.java:25 translate $decvec = instructions.NewToDeclareVector($VAR.line, $VAR.pos, $ID.text, $type.t, $listParams.l, "")
2023-10-30 17:35:48:428 action-translator LogManager.java:25 attr [@-1,1:6='decvec',<0>,198:95]
2023-10-30 17:35:48:428 action-translator LogManager.java:25 qattr [@-1,43:45='VAR',<0>,198:137].[@-1,47:50='line',<0>,198:141]
2023-10-30 17:35:48:428 action-translator LogManager.java:25 qattr [@-1,54:56='VAR',<0>,198:148].[@-1,58:60='pos',<0>,198:152]
2023-10-30 17:35:48:428 action-translator LogManager.java:25 qattr [@-1,64:65='ID',<0>,198:158].[@-1,67:70='text',<0>,198:161]
2023-10-30 17:35:48:428 action-translator LogManager.java:25 qattr [@-1,74:77='type',<0>,198:168].[@-1,79:79='t',<0>,198:173]
2023-10-30 17:35:48:428 action-translator LogManager.java:25 qattr [@-1,83:92='listParams',<0>,198:177].[@-1,94:94='l',<0>,198:188]
2023-10-30 17:35:48:429 action-translator LogManager.java:25 translate $decvec = instructions.NewToDeclareVector($VAR.line, $VAR.pos, $ID.text, $type.t, nil, "")
2023-10-30 17:35:48:429 action-translator LogManager.java:25 attr [@-1,1:6='decvec',<0>,199:84]
2023-10-30 17:35:48:429 action-translator LogManager.java:25 qattr [@-1,43:45='VAR',<0>,199:126].[@-1,47:50='line',<0>,199:130]
2023-10-30 17:35:48:429 action-translator LogManager.java:25 qattr [@-1,54:56='VAR',<0>,199:137].[@-1,58:60='pos',<0>,199:141]
2023-10-30 17:35:48:429 action-translator LogManager.java:25 qattr [@-1,64:65='ID',<0>,199:147].[@-1,67:70='text',<0>,199:150]
2023-10-30 17:35:48:429 action-translator LogManager.java:25 qattr [@-1,74:77='type',<0>,199:157].[@-1,79:79='t',<0>,199:162]
2023-10-30 17:35:48:430 action-translator LogManager.java:25 translate $decvec = instructions.NewToDeclareVector($VAR.line, $VAR.pos, $F.text, $type.t, nil, $S.text)
2023-10-30 17:35:48:430 action-translator LogManager.java:25 attr [@-1,1:6='decvec',<0>,201:67]
2023-10-30 17:35:48:430 action-translator LogManager.java:25 qattr [@-1,43:45='VAR',<0>,201:109].[@-1,47:50='line',<0>,201:113]
2023-10-30 17:35:48:430 action-translator LogManager.java:25 qattr [@-1,54:56='VAR',<0>,201:120].[@-1,58:60='pos',<0>,201:124]
2023-10-30 17:35:48:430 action-translator LogManager.java:25 qattr [@-1,64:64='F',<0>,201:130].[@-1,66:69='text',<0>,201:132]
2023-10-30 17:35:48:430 action-translator LogManager.java:25 qattr [@-1,73:76='type',<0>,201:139].[@-1,78:78='t',<0>,201:144]
2023-10-30 17:35:48:430 action-translator LogManager.java:25 qattr [@-1,87:87='S',<0>,201:153].[@-1,89:92='text',<0>,201:155]
2023-10-30 17:35:48:431 action-translator LogManager.java:25 translate $accessfuncin = instructions.NewCallFunction($ID.line, $ID.pos, $ID.text, $listParams.l, 1)
2023-10-30 17:35:48:431 action-translator LogManager.java:25 attr [@-1,1:12='accessfuncin',<0>,205:38]
2023-10-30 17:35:48:431 action-translator LogManager.java:25 qattr [@-1,46:47='ID',<0>,205:83].[@-1,49:52='line',<0>,205:86]
2023-10-30 17:35:48:431 action-translator LogManager.java:25 qattr [@-1,56:57='ID',<0>,205:93].[@-1,59:61='pos',<0>,205:96]
2023-10-30 17:35:48:431 action-translator LogManager.java:25 qattr [@-1,65:66='ID',<0>,205:102].[@-1,68:71='text',<0>,205:105]
2023-10-30 17:35:48:431 action-translator LogManager.java:25 qattr [@-1,75:84='listParams',<0>,205:112].[@-1,86:86='l',<0>,205:123]
2023-10-30 17:35:48:432 action-translator LogManager.java:25 translate $app = instructions.NewAppend($ID.line, $ID.pos, $ID.text, $expr.e)
2023-10-30 17:35:48:432 action-translator LogManager.java:25 attr [@-1,1:3='app',<0>,210:46]
2023-10-30 17:35:48:432 action-translator LogManager.java:25 qattr [@-1,31:32='ID',<0>,210:76].[@-1,34:37='line',<0>,210:79]
2023-10-30 17:35:48:433 action-translator LogManager.java:25 qattr [@-1,41:42='ID',<0>,210:86].[@-1,44:46='pos',<0>,210:89]
2023-10-30 17:35:48:433 action-translator LogManager.java:25 qattr [@-1,50:51='ID',<0>,210:95].[@-1,53:56='text',<0>,210:98]
2023-10-30 17:35:48:434 action-translator LogManager.java:25 qattr [@-1,60:63='expr',<0>,210:105].[@-1,65:65='e',<0>,210:110]
2023-10-30 17:35:48:434 action-translator LogManager.java:25 translate $removl = instructions.NewRemoveLast($ID.line, $ID.pos, $ID.text)
2023-10-30 17:35:48:435 action-translator LogManager.java:25 attr [@-1,1:6='removl',<0>,214:45]
2023-10-30 17:35:48:435 action-translator LogManager.java:25 qattr [@-1,38:39='ID',<0>,214:82].[@-1,41:44='line',<0>,214:85]
2023-10-30 17:35:48:435 action-translator LogManager.java:25 qattr [@-1,48:49='ID',<0>,214:92].[@-1,51:53='pos',<0>,214:95]
2023-10-30 17:35:48:435 action-translator LogManager.java:25 qattr [@-1,57:58='ID',<0>,214:101].[@-1,60:63='text',<0>,214:104]
2023-10-30 17:35:48:436 action-translator LogManager.java:25 translate $remov = instructions.NewRemove($ID.line, $ID.pos, $ID.text, $expr.e)
2023-10-30 17:35:48:436 action-translator LogManager.java:25 attr [@-1,1:5='remov',<0>,219:59]
2023-10-30 17:35:48:436 action-translator LogManager.java:25 qattr [@-1,33:34='ID',<0>,219:91].[@-1,36:39='line',<0>,219:94]
2023-10-30 17:35:48:436 action-translator LogManager.java:25 qattr [@-1,43:44='ID',<0>,219:101].[@-1,46:48='pos',<0>,219:104]
2023-10-30 17:35:48:437 action-translator LogManager.java:25 qattr [@-1,52:53='ID',<0>,219:110].[@-1,55:58='text',<0>,219:113]
2023-10-30 17:35:48:437 action-translator LogManager.java:25 qattr [@-1,62:65='expr',<0>,219:120].[@-1,67:67='e',<0>,219:125]
2023-10-30 17:35:48:437 action-translator LogManager.java:25 translate $emptyvec = expressions.NewEmptyVector($ID.line, $ID.pos, $ID.text)
2023-10-30 17:35:48:437 action-translator LogManager.java:25 attr [@-1,1:8='emptyvec',<0>,223:21]
2023-10-30 17:35:48:438 action-translator LogManager.java:25 qattr [@-1,40:41='ID',<0>,223:60].[@-1,43:46='line',<0>,223:63]
2023-10-30 17:35:48:439 action-translator LogManager.java:25 qattr [@-1,50:51='ID',<0>,223:70].[@-1,53:55='pos',<0>,223:73]
2023-10-30 17:35:48:439 action-translator LogManager.java:25 qattr [@-1,59:60='ID',<0>,223:79].[@-1,62:65='text',<0>,223:82]
2023-10-30 17:35:48:439 action-translator LogManager.java:25 translate $count = expressions.NewCount($ID.line, $ID.pos, $ID.text)
2023-10-30 17:35:48:439 action-translator LogManager.java:25 attr [@-1,1:5='count',<0>,227:18]
2023-10-30 17:35:48:439 action-translator LogManager.java:25 qattr [@-1,31:32='ID',<0>,227:48].[@-1,34:37='line',<0>,227:51]
2023-10-30 17:35:48:439 action-translator LogManager.java:25 qattr [@-1,41:42='ID',<0>,227:58].[@-1,44:46='pos',<0>,227:61]
2023-10-30 17:35:48:439 action-translator LogManager.java:25 qattr [@-1,50:51='ID',<0>,227:67].[@-1,53:56='text',<0>,227:70]
2023-10-30 17:35:48:439 action-translator LogManager.java:25 translate $accessvec = expressions.NewAccessVector($ID.line, $ID.pos, $ID.text, $expr.e)
2023-10-30 17:35:48:440 action-translator LogManager.java:25 attr [@-1,1:9='accessvec',<0>,231:35]
2023-10-30 17:35:48:440 action-translator LogManager.java:25 qattr [@-1,42:43='ID',<0>,231:76].[@-1,45:48='line',<0>,231:79]
2023-10-30 17:35:48:440 action-translator LogManager.java:25 qattr [@-1,52:53='ID',<0>,231:86].[@-1,55:57='pos',<0>,231:89]
2023-10-30 17:35:48:440 action-translator LogManager.java:25 qattr [@-1,61:62='ID',<0>,231:95].[@-1,64:67='text',<0>,231:98]
2023-10-30 17:35:48:440 action-translator LogManager.java:25 qattr [@-1,71:74='expr',<0>,231:105].[@-1,76:76='e',<0>,231:110]
2023-10-30 17:35:48:440 action-translator LogManager.java:25 translate $assignvec = instructions.NewAssignationVector($ID.line, $ID.pos, $ID.text, $expprim.e, $expsegundo.e)
2023-10-30 17:35:48:440 action-translator LogManager.java:25 attr [@-1,1:9='assignvec',<0>,236:70]
2023-10-30 17:35:48:441 action-translator LogManager.java:25 qattr [@-1,48:49='ID',<0>,236:117].[@-1,51:54='line',<0>,236:120]
2023-10-30 17:35:48:441 action-translator LogManager.java:25 qattr [@-1,58:59='ID',<0>,236:127].[@-1,61:63='pos',<0>,236:130]
2023-10-30 17:35:48:441 action-translator LogManager.java:25 qattr [@-1,67:68='ID',<0>,236:136].[@-1,70:73='text',<0>,236:139]
2023-10-30 17:35:48:441 action-translator LogManager.java:25 qattr [@-1,77:83='expprim',<0>,236:146].[@-1,85:85='e',<0>,236:154]
2023-10-30 17:35:48:441 action-translator LogManager.java:25 qattr [@-1,89:98='expsegundo',<0>,236:158].[@-1,100:100='e',<0>,236:169]
2023-10-30 17:35:48:443 action-translator LogManager.java:25 translate $decfunc = instructions.NewToDeclareFunction($ID.line, $ID.pos, $ID.text, $listParamsFunc.lf, $type.t, $block.blk, 1)
2023-10-30 17:35:48:443 action-translator LogManager.java:25 attr [@-1,1:7='decfunc',<0>,246:79]
2023-10-30 17:35:48:443 action-translator LogManager.java:25 qattr [@-1,46:47='ID',<0>,246:124].[@-1,49:52='line',<0>,246:127]
2023-10-30 17:35:48:443 action-translator LogManager.java:25 qattr [@-1,56:57='ID',<0>,246:134].[@-1,59:61='pos',<0>,246:137]
2023-10-30 17:35:48:444 action-translator LogManager.java:25 qattr [@-1,65:66='ID',<0>,246:143].[@-1,68:71='text',<0>,246:146]
2023-10-30 17:35:48:444 action-translator LogManager.java:25 qattr [@-1,75:88='listParamsFunc',<0>,246:153].[@-1,90:91='lf',<0>,246:168]
2023-10-30 17:35:48:444 action-translator LogManager.java:25 qattr [@-1,95:98='type',<0>,246:173].[@-1,100:100='t',<0>,246:178]
2023-10-30 17:35:48:444 action-translator LogManager.java:25 qattr [@-1,104:108='block',<0>,246:182].[@-1,110:112='blk',<0>,246:188]
2023-10-30 17:35:48:444 action-translator LogManager.java:25 translate 
    
    $decfunc = instructions.NewToDeclareFunction($ID.line, $ID.pos, $ID.text, $listParamsFunc.lf, environment.NULL, $block.blk, 2);
2023-10-30 17:35:48:444 action-translator LogManager.java:25 setAttr [@-1,13:19='decfunc',<0>,249:5] [@-1,22:137=' instructions.NewToDeclareFunction($ID.line, $ID.pos, $ID.text, $listParamsFunc.lf, environment.NULL, $block.blk, 2)',<0>,249:14]
2023-10-30 17:35:48:444 action-translator LogManager.java:25 translate  instructions.NewToDeclareFunction($ID.line, $ID.pos, $ID.text, $listParamsFunc.lf, environment.NULL, $block.blk, 2)
2023-10-30 17:35:48:444 action-translator LogManager.java:25 qattr [@-1,36:37='ID',<0>,247:99].[@-1,39:42='line',<0>,247:102]
2023-10-30 17:35:48:444 action-translator LogManager.java:25 qattr [@-1,46:47='ID',<0>,247:109].[@-1,49:51='pos',<0>,247:112]
2023-10-30 17:35:48:445 action-translator LogManager.java:25 qattr [@-1,55:56='ID',<0>,247:118].[@-1,58:61='text',<0>,247:121]
2023-10-30 17:35:48:445 action-translator LogManager.java:25 qattr [@-1,65:78='listParamsFunc',<0>,247:128].[@-1,80:81='lf',<0>,247:143]
2023-10-30 17:35:48:445 action-translator LogManager.java:25 qattr [@-1,103:107='block',<0>,247:166].[@-1,109:111='blk',<0>,247:172]
2023-10-30 17:35:48:445 action-translator LogManager.java:25 translate $decfunc = instructions.NewToDeclareFunction($ID.line, $ID.pos, $ID.text, nil, $type.t, $block.blk, 3)
2023-10-30 17:35:48:445 action-translator LogManager.java:25 attr [@-1,1:7='decfunc',<0>,250:64]
2023-10-30 17:35:48:445 action-translator LogManager.java:25 qattr [@-1,46:47='ID',<0>,250:109].[@-1,49:52='line',<0>,250:112]
2023-10-30 17:35:48:446 action-translator LogManager.java:25 qattr [@-1,56:57='ID',<0>,250:119].[@-1,59:61='pos',<0>,250:122]
2023-10-30 17:35:48:446 action-translator LogManager.java:25 qattr [@-1,65:66='ID',<0>,250:128].[@-1,68:71='text',<0>,250:131]
2023-10-30 17:35:48:446 action-translator LogManager.java:25 qattr [@-1,80:83='type',<0>,250:143].[@-1,85:85='t',<0>,250:148]
2023-10-30 17:35:48:446 action-translator LogManager.java:25 qattr [@-1,89:93='block',<0>,250:152].[@-1,95:97='blk',<0>,250:158]
2023-10-30 17:35:48:446 action-translator LogManager.java:25 translate 
    if($block.blk!=nil){ 
         $decfunc = instructions.NewToDeclareFunction($ID.line, $ID.pos, $ID.text, nil, environment.NULL, $block.blk, 4)
    }

2023-10-30 17:35:48:446 action-translator LogManager.java:25 qattr [@-1,10:14='block',<0>,252:8].[@-1,16:18='blk',<0>,252:14]
2023-10-30 17:35:48:446 action-translator LogManager.java:25 attr [@-1,39:45='decfunc',<0>,253:10]
2023-10-30 17:35:48:446 action-translator LogManager.java:25 qattr [@-1,84:85='ID',<0>,253:55].[@-1,87:90='line',<0>,253:58]
2023-10-30 17:35:48:446 action-translator LogManager.java:25 qattr [@-1,94:95='ID',<0>,253:65].[@-1,97:99='pos',<0>,253:68]
2023-10-30 17:35:48:447 action-translator LogManager.java:25 qattr [@-1,103:104='ID',<0>,253:74].[@-1,106:109='text',<0>,253:77]
2023-10-30 17:35:48:447 action-translator LogManager.java:25 qattr [@-1,136:140='block',<0>,253:107].[@-1,142:144='blk',<0>,253:113]
2023-10-30 17:35:48:447 action-translator LogManager.java:25 translate 
2023-10-30 17:35:48:448 action-translator LogManager.java:25 translate 
    
            $lf = []interface{}{}
            $lf = append($lf, $parameterfuncstmt.parameterfunc)
        
2023-10-30 17:35:48:448 action-translator LogManager.java:25 attr [@-1,21:22='lf',<0>,4:13]
2023-10-30 17:35:48:448 action-translator LogManager.java:25 attr [@-1,56:57='lf',<0>,5:13]
2023-10-30 17:35:48:448 action-translator LogManager.java:25 attr [@-1,69:70='lf',<0>,5:26]
2023-10-30 17:35:48:448 action-translator LogManager.java:25 qattr [@-1,74:90='parameterfuncstmt',<0>,5:31].[@-1,92:104='parameterfunc',<0>,5:49]
2023-10-30 17:35:48:448 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 2)
2023-10-30 17:35:48:448 action-translator LogManager.java:25 translate 
                              
                                          var arrf []interface{}
                                          arrf = append($listf.lf, $parameterfuncstmt.parameterfunc)
                                          $lf = arrf
                                      
2023-10-30 17:35:48:449 action-translator LogManager.java:25 qattr [@-1,157:161='listf',<0>,12:57].[@-1,163:164='lf',<0>,12:63]
2023-10-30 17:35:48:449 action-translator LogManager.java:25 qattr [@-1,168:184='parameterfuncstmt',<0>,12:68].[@-1,186:198='parameterfunc',<0>,12:86]
2023-10-30 17:35:48:449 action-translator LogManager.java:25 attr [@-1,245:246='lf',<0>,13:43]
2023-10-30 17:35:48:450 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 2)
2023-10-30 17:35:48:452 action-translator LogManager.java:25 translate $parameterfunc = expressions.NewParameters($exte.line, $exte.pos, $type.t, $exte.text,  $ID.text, 1)
2023-10-30 17:35:48:452 action-translator LogManager.java:25 attr [@-1,1:13='parameterfunc',<0>,272:42]
2023-10-30 17:35:48:452 action-translator LogManager.java:25 qattr [@-1,44:47='exte',<0>,272:85].[@-1,49:52='line',<0>,272:90]
2023-10-30 17:35:48:452 action-translator LogManager.java:25 qattr [@-1,56:59='exte',<0>,272:97].[@-1,61:63='pos',<0>,272:102]
2023-10-30 17:35:48:452 action-translator LogManager.java:25 qattr [@-1,67:70='type',<0>,272:108].[@-1,72:72='t',<0>,272:113]
2023-10-30 17:35:48:452 action-translator LogManager.java:25 qattr [@-1,76:79='exte',<0>,272:117].[@-1,81:84='text',<0>,272:122]
2023-10-30 17:35:48:452 action-translator LogManager.java:25 qattr [@-1,89:90='ID',<0>,272:130].[@-1,92:95='text',<0>,272:133]
2023-10-30 17:35:48:453 action-translator LogManager.java:25 translate $parameterfunc = expressions.NewParameters($exte.line, $exte.pos, $type.t, $exte.text,  $ID.text,2);
2023-10-30 17:35:48:453 action-translator LogManager.java:25 setAttr [@-1,1:13='parameterfunc',<0>,273:73] [@-1,16:98=' expressions.NewParameters($exte.line, $exte.pos, $type.t, $exte.text,  $ID.text,2)',<0>,273:88]
2023-10-30 17:35:48:453 action-translator LogManager.java:25 translate  expressions.NewParameters($exte.line, $exte.pos, $type.t, $exte.text,  $ID.text,2)
2023-10-30 17:35:48:453 action-translator LogManager.java:25 qattr [@-1,28:31='exte',<0>,273:100].[@-1,33:36='line',<0>,273:105]
2023-10-30 17:35:48:453 action-translator LogManager.java:25 qattr [@-1,40:43='exte',<0>,273:112].[@-1,45:47='pos',<0>,273:117]
2023-10-30 17:35:48:453 action-translator LogManager.java:25 qattr [@-1,51:54='type',<0>,273:123].[@-1,56:56='t',<0>,273:128]
2023-10-30 17:35:48:453 action-translator LogManager.java:25 qattr [@-1,60:63='exte',<0>,273:132].[@-1,65:68='text',<0>,273:137]
2023-10-30 17:35:48:453 action-translator LogManager.java:25 qattr [@-1,73:74='ID',<0>,273:145].[@-1,76:79='text',<0>,273:148]
2023-10-30 17:35:48:453 action-translator LogManager.java:25 translate $parameterfunc = expressions.NewParameters($ID.line, $ID.pos, $type.t, "_",  $ID.text, 1)
2023-10-30 17:35:48:453 action-translator LogManager.java:25 attr [@-1,1:13='parameterfunc',<0>,274:22]
2023-10-30 17:35:48:454 action-translator LogManager.java:25 qattr [@-1,44:45='ID',<0>,274:65].[@-1,47:50='line',<0>,274:68]
2023-10-30 17:35:48:454 action-translator LogManager.java:25 qattr [@-1,54:55='ID',<0>,274:75].[@-1,57:59='pos',<0>,274:78]
2023-10-30 17:35:48:454 action-translator LogManager.java:25 qattr [@-1,63:66='type',<0>,274:84].[@-1,68:68='t',<0>,274:89]
2023-10-30 17:35:48:454 action-translator LogManager.java:25 qattr [@-1,78:79='ID',<0>,274:99].[@-1,81:84='text',<0>,274:102]
2023-10-30 17:35:48:454 action-translator LogManager.java:25 translate  $decstruct = instructions.NewToDeclareStruct($STRUCT.line, $STRUCT.pos, $ID.text, $listStruct.l) 
2023-10-30 17:35:48:454 action-translator LogManager.java:25 attr [@-1,2:10='decstruct',<0>,278:43]
2023-10-30 17:35:48:454 action-translator LogManager.java:25 qattr [@-1,47:52='STRUCT',<0>,278:88].[@-1,54:57='line',<0>,278:95]
2023-10-30 17:35:48:454 action-translator LogManager.java:25 qattr [@-1,61:66='STRUCT',<0>,278:102].[@-1,68:70='pos',<0>,278:109]
2023-10-30 17:35:48:454 action-translator LogManager.java:25 qattr [@-1,74:75='ID',<0>,278:115].[@-1,77:80='text',<0>,278:118]
2023-10-30 17:35:48:454 action-translator LogManager.java:25 qattr [@-1,84:93='listStruct',<0>,278:125].[@-1,95:95='l',<0>,278:136]
2023-10-30 17:35:48:455 action-translator LogManager.java:25 translate 
2023-10-30 17:35:48:455 action-translator LogManager.java:25 translate 
                        var arr []interface{}
                        newParams := environment.NewStructType($ID.text, $type.t)
                        arr = append(arr, newParams)
                        $l = arr

2023-10-30 17:35:48:455 action-translator LogManager.java:25 qattr [@-1,113:114='ID',<0>,4:64].[@-1,116:119='text',<0>,4:67]
2023-10-30 17:35:48:456 action-translator LogManager.java:25 qattr [@-1,123:126='type',<0>,4:74].[@-1,128:128='t',<0>,4:79]
2023-10-30 17:35:48:456 action-translator LogManager.java:25 attr [@-1,211:211='l',<0>,6:25]
2023-10-30 17:35:48:456 action-translator LogManager.java:25 translate  $l = []interface{}{} 
2023-10-30 17:35:48:456 action-translator LogManager.java:25 attr [@-1,2:2='l',<0>,8:12]
2023-10-30 17:35:48:456 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 3)
2023-10-30 17:35:48:456 action-translator LogManager.java:25 translate 
                                      var arr []interface{}
                                      newParams := environment.NewStructType($ID.text, $type.t)
                                      arr = append($list.l, newParams)
                                      $l = arr

          
2023-10-30 17:35:48:456 action-translator LogManager.java:25 qattr [@-1,141:142='ID',<0>,13:78].[@-1,144:147='text',<0>,13:81]
2023-10-30 17:35:48:456 action-translator LogManager.java:25 qattr [@-1,151:154='type',<0>,13:88].[@-1,156:156='t',<0>,13:93]
2023-10-30 17:35:48:457 action-translator LogManager.java:25 qattr [@-1,212:215='list',<0>,14:52].[@-1,217:217='l',<0>,14:57]
2023-10-30 17:35:48:457 action-translator LogManager.java:25 attr [@-1,271:271='l',<0>,15:39]
2023-10-30 17:35:48:457 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 3)
2023-10-30 17:35:48:459 action-translator LogManager.java:25 translate 
2023-10-30 17:35:48:459 action-translator LogManager.java:25 translate  $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $left.e) 
2023-10-30 17:35:48:459 action-translator LogManager.java:25 attr [@-1,2:2='e',<0>,2:74]
2023-10-30 17:35:48:459 action-translator LogManager.java:25 qattr [@-1,32:35='left',<0>,2:104].[@-1,37:41='start',<0>,2:109]
2023-10-30 17:35:48:460 action-translator LogManager.java:25 qattr [@-1,55:58='left',<0>,2:127].[@-1,60:64='start',<0>,2:132]
2023-10-30 17:35:48:460 action-translator LogManager.java:25 qattr [@-1,80:83='left',<0>,2:152].[@-1,85:85='e',<0>,2:157]
2023-10-30 17:35:48:460 action-translator LogManager.java:25 qattr [@-1,89:90='op',<0>,2:161].[@-1,92:95='text',<0>,2:164]
2023-10-30 17:35:48:460 action-translator LogManager.java:25 qattr [@-1,99:102='left',<0>,2:171].[@-1,104:104='e',<0>,2:176]
2023-10-30 17:35:48:460 action-translator LogManager.java:25 translate  $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e,  $op.text, nil)
2023-10-30 17:35:48:461 action-translator LogManager.java:25 attr [@-1,2:2='e',<0>,3:71]
2023-10-30 17:35:48:461 action-translator LogManager.java:25 qattr [@-1,32:35='left',<0>,3:101].[@-1,37:41='start',<0>,3:106]
2023-10-30 17:35:48:461 action-translator LogManager.java:25 qattr [@-1,55:58='left',<0>,3:124].[@-1,60:64='start',<0>,3:129]
2023-10-30 17:35:48:461 action-translator LogManager.java:25 qattr [@-1,80:83='left',<0>,3:149].[@-1,85:85='e',<0>,3:154]
2023-10-30 17:35:48:462 action-translator LogManager.java:25 qattr [@-1,90:91='op',<0>,3:159].[@-1,93:96='text',<0>,3:162]
2023-10-30 17:35:48:462 action-translator LogManager.java:25 translate  $e = $expr.e 
2023-10-30 17:35:48:462 action-translator LogManager.java:25 attr [@-1,2:2='e',<0>,4:82]
2023-10-30 17:35:48:462 action-translator LogManager.java:25 qattr [@-1,7:10='expr',<0>,4:87].[@-1,12:12='e',<0>,4:92]
2023-10-30 17:35:48:463 action-translator LogManager.java:25 translate    
        
        if (strings.Contains($NUMBER.text,".")){
           
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,$NUMBER.text,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.INTEGER)
        }
    
2023-10-30 17:35:48:463 action-translator LogManager.java:25 qattr [@-1,45:50='NUMBER',<0>,8:30].[@-1,52:55='text',<0>,8:37]
2023-10-30 17:35:48:463 action-translator LogManager.java:25 attr [@-1,91:91='e',<0>,10:13]
2023-10-30 17:35:48:463 action-translator LogManager.java:25 qattr [@-1,121:126='NUMBER',<0>,10:43].[@-1,128:131='line',<0>,10:50]
2023-10-30 17:35:48:463 action-translator LogManager.java:25 qattr [@-1,134:139='NUMBER',<0>,10:56].[@-1,141:143='pos',<0>,10:63]
2023-10-30 17:35:48:463 action-translator LogManager.java:25 qattr [@-1,146:151='NUMBER',<0>,10:68].[@-1,153:156='text',<0>,10:75]
2023-10-30 17:35:48:463 action-translator LogManager.java:25 qattr [@-1,231:236='NUMBER',<0>,12:37].[@-1,238:241='text',<0>,12:44]
2023-10-30 17:35:48:463 action-translator LogManager.java:25 attr [@-1,334:334='e',<0>,16:13]
2023-10-30 17:35:48:463 action-translator LogManager.java:25 qattr [@-1,364:369='NUMBER',<0>,16:43].[@-1,371:374='line',<0>,16:50]
2023-10-30 17:35:48:463 action-translator LogManager.java:25 qattr [@-1,377:382='NUMBER',<0>,16:56].[@-1,384:386='pos',<0>,16:63]
2023-10-30 17:35:48:464 action-translator LogManager.java:25 translate 
        str := $STRING.text
        $e = expressions.NewPrimitive($STRING.line, $STRING.pos, str[1:len(str)-1],environment.STRING)
    
2023-10-30 17:35:48:464 action-translator LogManager.java:25 qattr [@-1,18:23='STRING',<0>,21:16].[@-1,25:28='text',<0>,21:23]
2023-10-30 17:35:48:464 action-translator LogManager.java:25 attr [@-1,40:40='e',<0>,22:9]
2023-10-30 17:35:48:464 action-translator LogManager.java:25 qattr [@-1,70:75='STRING',<0>,22:39].[@-1,77:80='line',<0>,22:46]
2023-10-30 17:35:48:464 action-translator LogManager.java:25 qattr [@-1,84:89='STRING',<0>,22:53].[@-1,91:93='pos',<0>,22:60]
2023-10-30 17:35:48:465 action-translator LogManager.java:25 translate  $e = expressions.NewPrimitive($TRUE.line, $TRUE.pos, true, environment.BOOLEAN) 
2023-10-30 17:35:48:465 action-translator LogManager.java:25 attr [@-1,2:2='e',<0>,24:34]
2023-10-30 17:35:48:465 action-translator LogManager.java:25 qattr [@-1,32:35='TRUE',<0>,24:64].[@-1,37:40='line',<0>,24:69]
2023-10-30 17:35:48:465 action-translator LogManager.java:25 qattr [@-1,44:47='TRUE',<0>,24:76].[@-1,49:51='pos',<0>,24:81]
2023-10-30 17:35:48:465 action-translator LogManager.java:25 translate  $e = expressions.NewPrimitive($FALSE.line, $FALSE.pos, false, environment.BOOLEAN) 
2023-10-30 17:35:48:465 action-translator LogManager.java:25 attr [@-1,2:2='e',<0>,25:35]
2023-10-30 17:35:48:466 action-translator LogManager.java:25 qattr [@-1,32:36='FALSE',<0>,25:65].[@-1,38:41='line',<0>,25:71]
2023-10-30 17:35:48:466 action-translator LogManager.java:25 qattr [@-1,45:49='FALSE',<0>,25:78].[@-1,51:53='pos',<0>,25:84]
2023-10-30 17:35:48:466 action-translator LogManager.java:25 translate  $e = expressions.NewPrimitive($NIL.line, $NIL.pos, nil, environment.NULL) 
2023-10-30 17:35:48:466 action-translator LogManager.java:25 attr [@-1,2:2='e',<0>,26:33]
2023-10-30 17:35:48:466 action-translator LogManager.java:25 qattr [@-1,32:34='NIL',<0>,26:63].[@-1,36:39='line',<0>,26:67]
2023-10-30 17:35:48:466 action-translator LogManager.java:25 qattr [@-1,43:45='NIL',<0>,26:74].[@-1,47:49='pos',<0>,26:78]
2023-10-30 17:35:48:466 action-translator LogManager.java:25 translate $e = $accessstmt.access
2023-10-30 17:35:48:466 action-translator LogManager.java:25 attr [@-1,1:1='e',<0>,27:39]
2023-10-30 17:35:48:466 action-translator LogManager.java:25 qattr [@-1,6:15='accessstmt',<0>,27:44].[@-1,17:22='access',<0>,27:55]
2023-10-30 17:35:48:467 action-translator LogManager.java:25 translate $e = $emptvecstmt.emptyvec
2023-10-30 17:35:48:467 action-translator LogManager.java:25 attr [@-1,1:1='e',<0>,28:40]
2023-10-30 17:35:48:467 action-translator LogManager.java:25 qattr [@-1,6:16='emptvecstmt',<0>,28:45].[@-1,18:25='emptyvec',<0>,28:57]
2023-10-30 17:35:48:467 action-translator LogManager.java:25 translate $e = $countvecstmt.count
2023-10-30 17:35:48:467 action-translator LogManager.java:25 attr [@-1,1:1='e',<0>,29:41]
2023-10-30 17:35:48:467 action-translator LogManager.java:25 qattr [@-1,6:17='countvecstmt',<0>,29:46].[@-1,19:23='count',<0>,29:59]
2023-10-30 17:35:48:467 action-translator LogManager.java:25 translate $e = $accessvecstmt.accessvec
2023-10-30 17:35:48:467 action-translator LogManager.java:25 attr [@-1,1:1='e',<0>,30:42]
2023-10-30 17:35:48:467 action-translator LogManager.java:25 qattr [@-1,6:18='accessvecstmt',<0>,30:47].[@-1,20:28='accessvec',<0>,30:61]
2023-10-30 17:35:48:467 action-translator LogManager.java:25 translate $e = $intfunctionstmt.intfunc
2023-10-30 17:35:48:468 action-translator LogManager.java:25 attr [@-1,1:1='e',<0>,31:44]
2023-10-30 17:35:48:468 action-translator LogManager.java:25 qattr [@-1,6:20='intfunctionstmt',<0>,31:49].[@-1,22:28='intfunc',<0>,31:65]
2023-10-30 17:35:48:468 action-translator LogManager.java:25 translate $e = $floatfunctionstmt.floatfunc
2023-10-30 17:35:48:468 action-translator LogManager.java:25 attr [@-1,1:1='e',<0>,32:46]
2023-10-30 17:35:48:468 action-translator LogManager.java:25 qattr [@-1,6:22='floatfunctionstmt',<0>,32:51].[@-1,24:32='floatfunc',<0>,32:69]
2023-10-30 17:35:48:468 action-translator LogManager.java:25 translate $e = $stringfunctionstmt.stringfunc
2023-10-30 17:35:48:468 action-translator LogManager.java:25 attr [@-1,1:1='e',<0>,33:47]
2023-10-30 17:35:48:468 action-translator LogManager.java:25 qattr [@-1,6:23='stringfunctionstmt',<0>,33:52].[@-1,25:34='stringfunc',<0>,33:71]
2023-10-30 17:35:48:468 action-translator LogManager.java:25 translate $e = $accessfuncstmt.funcexp
2023-10-30 17:35:48:468 action-translator LogManager.java:25 attr [@-1,1:1='e',<0>,34:47]
2023-10-30 17:35:48:468 action-translator LogManager.java:25 qattr [@-1,6:19='accessfuncstmt',<0>,34:52].[@-1,21:27='funcexp',<0>,34:67]
2023-10-30 17:35:48:469 action-translator LogManager.java:25 translate  $e = expressions.NewStructExp($ID.line, $ID.pos, $ID.text, $listStructExp.l ) 
2023-10-30 17:35:48:469 action-translator LogManager.java:25 attr [@-1,2:2='e',<0>,35:167]
2023-10-30 17:35:48:469 action-translator LogManager.java:25 qattr [@-1,32:33='ID',<0>,35:197].[@-1,35:38='line',<0>,35:200]
2023-10-30 17:35:48:469 action-translator LogManager.java:25 qattr [@-1,42:43='ID',<0>,35:207].[@-1,45:47='pos',<0>,35:210]
2023-10-30 17:35:48:469 action-translator LogManager.java:25 qattr [@-1,51:52='ID',<0>,35:216].[@-1,54:57='text',<0>,35:219]
2023-10-30 17:35:48:469 action-translator LogManager.java:25 qattr [@-1,61:73='listStructExp',<0>,35:226].[@-1,75:75='l',<0>,35:240]
2023-10-30 17:35:48:470 action-translator LogManager.java:25 translate $e = $accessstructstmt.accessstruct
2023-10-30 17:35:48:470 action-translator LogManager.java:25 attr [@-1,1:1='e',<0>,36:45]
2023-10-30 17:35:48:470 action-translator LogManager.java:25 qattr [@-1,6:21='accessstructstmt',<0>,36:50].[@-1,23:34='accessstruct',<0>,36:67]
2023-10-30 17:35:48:470 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 25)
2023-10-30 17:35:48:470 action-translator LogManager.java:25 translate  $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) 
2023-10-30 17:35:48:470 action-translator LogManager.java:25 attr [@-1,2:2='e',<0>,39:142]
2023-10-30 17:35:48:470 action-translator LogManager.java:25 qattr [@-1,32:35='left',<0>,39:172].[@-1,37:41='start',<0>,39:177]
2023-10-30 17:35:48:470 action-translator LogManager.java:25 qattr [@-1,55:58='left',<0>,39:195].[@-1,60:64='start',<0>,39:200]
2023-10-30 17:35:48:471 action-translator LogManager.java:25 qattr [@-1,80:83='left',<0>,39:220].[@-1,85:85='e',<0>,39:225]
2023-10-30 17:35:48:471 action-translator LogManager.java:25 qattr [@-1,89:90='op',<0>,39:229].[@-1,92:95='text',<0>,39:232]
2023-10-30 17:35:48:471 action-translator LogManager.java:25 qattr [@-1,99:103='right',<0>,39:239].[@-1,105:105='e',<0>,39:245]
2023-10-30 17:35:48:471 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 24)
2023-10-30 17:35:48:471 action-translator LogManager.java:25 translate  $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) 
2023-10-30 17:35:48:471 action-translator LogManager.java:25 attr [@-1,2:2='e',<0>,40:177]
2023-10-30 17:35:48:471 action-translator LogManager.java:25 qattr [@-1,32:35='left',<0>,40:207].[@-1,37:41='start',<0>,40:212]
2023-10-30 17:35:48:471 action-translator LogManager.java:25 qattr [@-1,55:58='left',<0>,40:230].[@-1,60:64='start',<0>,40:235]
2023-10-30 17:35:48:471 action-translator LogManager.java:25 qattr [@-1,80:83='left',<0>,40:255].[@-1,85:85='e',<0>,40:260]
2023-10-30 17:35:48:471 action-translator LogManager.java:25 qattr [@-1,89:90='op',<0>,40:264].[@-1,92:95='text',<0>,40:267]
2023-10-30 17:35:48:471 action-translator LogManager.java:25 qattr [@-1,99:103='right',<0>,40:274].[@-1,105:105='e',<0>,40:280]
2023-10-30 17:35:48:471 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 23)
2023-10-30 17:35:48:472 action-translator LogManager.java:25 translate  $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) 
2023-10-30 17:35:48:472 action-translator LogManager.java:25 attr [@-1,2:2='e',<0>,41:157]
2023-10-30 17:35:48:472 action-translator LogManager.java:25 qattr [@-1,32:35='left',<0>,41:187].[@-1,37:41='start',<0>,41:192]
2023-10-30 17:35:48:472 action-translator LogManager.java:25 qattr [@-1,55:58='left',<0>,41:210].[@-1,60:64='start',<0>,41:215]
2023-10-30 17:35:48:472 action-translator LogManager.java:25 qattr [@-1,80:83='left',<0>,41:235].[@-1,85:85='e',<0>,41:240]
2023-10-30 17:35:48:472 action-translator LogManager.java:25 qattr [@-1,89:90='op',<0>,41:244].[@-1,92:95='text',<0>,41:247]
2023-10-30 17:35:48:472 action-translator LogManager.java:25 qattr [@-1,99:103='right',<0>,41:254].[@-1,105:105='e',<0>,41:260]
2023-10-30 17:35:48:472 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 22)
2023-10-30 17:35:48:473 action-translator LogManager.java:25 translate  $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) 
2023-10-30 17:35:48:473 action-translator LogManager.java:25 attr [@-1,2:2='e',<0>,42:157]
2023-10-30 17:35:48:473 action-translator LogManager.java:25 qattr [@-1,32:35='left',<0>,42:187].[@-1,37:41='start',<0>,42:192]
2023-10-30 17:35:48:473 action-translator LogManager.java:25 qattr [@-1,55:58='left',<0>,42:210].[@-1,60:64='start',<0>,42:215]
2023-10-30 17:35:48:474 action-translator LogManager.java:25 qattr [@-1,80:83='left',<0>,42:235].[@-1,85:85='e',<0>,42:240]
2023-10-30 17:35:48:474 action-translator LogManager.java:25 qattr [@-1,89:90='op',<0>,42:244].[@-1,92:95='text',<0>,42:247]
2023-10-30 17:35:48:474 action-translator LogManager.java:25 qattr [@-1,99:103='right',<0>,42:254].[@-1,105:105='e',<0>,42:260]
2023-10-30 17:35:48:474 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 21)
2023-10-30 17:35:48:474 action-translator LogManager.java:25 translate  $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) 
2023-10-30 17:35:48:474 action-translator LogManager.java:25 attr [@-1,2:2='e',<0>,43:154]
2023-10-30 17:35:48:475 action-translator LogManager.java:25 qattr [@-1,32:35='left',<0>,43:184].[@-1,37:41='start',<0>,43:189]
2023-10-30 17:35:48:475 action-translator LogManager.java:25 qattr [@-1,55:58='left',<0>,43:207].[@-1,60:64='start',<0>,43:212]
2023-10-30 17:35:48:475 action-translator LogManager.java:25 qattr [@-1,80:83='left',<0>,43:232].[@-1,85:85='e',<0>,43:237]
2023-10-30 17:35:48:475 action-translator LogManager.java:25 qattr [@-1,89:90='op',<0>,43:241].[@-1,92:95='text',<0>,43:244]
2023-10-30 17:35:48:475 action-translator LogManager.java:25 qattr [@-1,99:103='right',<0>,43:251].[@-1,105:105='e',<0>,43:257]
2023-10-30 17:35:48:475 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 20)
2023-10-30 17:35:48:475 action-translator LogManager.java:25 translate  $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) 
2023-10-30 17:35:48:475 action-translator LogManager.java:25 attr [@-1,2:2='e',<0>,44:129]
2023-10-30 17:35:48:475 action-translator LogManager.java:25 qattr [@-1,32:35='left',<0>,44:159].[@-1,37:41='start',<0>,44:164]
2023-10-30 17:35:48:476 action-translator LogManager.java:25 qattr [@-1,55:58='left',<0>,44:182].[@-1,60:64='start',<0>,44:187]
2023-10-30 17:35:48:476 action-translator LogManager.java:25 qattr [@-1,80:83='left',<0>,44:207].[@-1,85:85='e',<0>,44:212]
2023-10-30 17:35:48:476 action-translator LogManager.java:25 qattr [@-1,89:90='op',<0>,44:216].[@-1,92:95='text',<0>,44:219]
2023-10-30 17:35:48:476 action-translator LogManager.java:25 qattr [@-1,99:103='right',<0>,44:226].[@-1,105:105='e',<0>,44:232]
2023-10-30 17:35:48:476 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 19)
2023-10-30 17:35:48:477 action-translator LogManager.java:25 translate  $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) 
2023-10-30 17:35:48:477 action-translator LogManager.java:25 attr [@-1,2:2='e',<0>,45:128]
2023-10-30 17:35:48:477 action-translator LogManager.java:25 qattr [@-1,32:35='left',<0>,45:158].[@-1,37:41='start',<0>,45:163]
2023-10-30 17:35:48:477 action-translator LogManager.java:25 qattr [@-1,55:58='left',<0>,45:181].[@-1,60:64='start',<0>,45:186]
2023-10-30 17:35:48:477 action-translator LogManager.java:25 qattr [@-1,80:83='left',<0>,45:206].[@-1,85:85='e',<0>,45:211]
2023-10-30 17:35:48:477 action-translator LogManager.java:25 qattr [@-1,89:90='op',<0>,45:215].[@-1,92:95='text',<0>,45:218]
2023-10-30 17:35:48:477 action-translator LogManager.java:25 qattr [@-1,99:103='right',<0>,45:225].[@-1,105:105='e',<0>,45:231]
2023-10-30 17:35:48:477 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 25)
2023-10-30 17:35:48:478 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 24)
2023-10-30 17:35:48:478 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 23)
2023-10-30 17:35:48:478 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 22)
2023-10-30 17:35:48:478 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 21)
2023-10-30 17:35:48:478 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 20)
2023-10-30 17:35:48:478 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 19)
2023-10-30 17:35:48:478 action-translator LogManager.java:25 translate  $accessstruct = expressions.NewAccessStruct($list.line, $list.pos, $list.text, $ID.text, "nil")  
2023-10-30 17:35:48:478 action-translator LogManager.java:25 attr [@-1,2:13='accessstruct',<0>,348:20]
2023-10-30 17:35:48:479 action-translator LogManager.java:25 qattr [@-1,46:49='list',<0>,348:64].[@-1,51:54='line',<0>,348:69]
2023-10-30 17:35:48:479 action-translator LogManager.java:25 qattr [@-1,58:61='list',<0>,348:76].[@-1,63:65='pos',<0>,348:81]
2023-10-30 17:35:48:479 action-translator LogManager.java:25 qattr [@-1,69:72='list',<0>,348:87].[@-1,74:77='text',<0>,348:92]
2023-10-30 17:35:48:479 action-translator LogManager.java:25 qattr [@-1,81:82='ID',<0>,348:99].[@-1,84:87='text',<0>,348:102]
2023-10-30 17:35:48:479 action-translator LogManager.java:25 translate  $accessstruct = expressions.NewAccessStruct($list.line, $list.pos, $list.text, $ID.text, $sec.text)  
2023-10-30 17:35:48:479 action-translator LogManager.java:25 attr [@-1,2:13='accessstruct',<0>,349:35]
2023-10-30 17:35:48:479 action-translator LogManager.java:25 qattr [@-1,46:49='list',<0>,349:79].[@-1,51:54='line',<0>,349:84]
2023-10-30 17:35:48:479 action-translator LogManager.java:25 qattr [@-1,58:61='list',<0>,349:91].[@-1,63:65='pos',<0>,349:96]
2023-10-30 17:35:48:479 action-translator LogManager.java:25 qattr [@-1,69:72='list',<0>,349:102].[@-1,74:77='text',<0>,349:107]
2023-10-30 17:35:48:480 action-translator LogManager.java:25 qattr [@-1,81:82='ID',<0>,349:114].[@-1,84:87='text',<0>,349:117]
2023-10-30 17:35:48:480 action-translator LogManager.java:25 qattr [@-1,91:93='sec',<0>,349:124].[@-1,95:98='text',<0>,349:128]
2023-10-30 17:35:48:480 action-translator LogManager.java:25 translate $funcexp = expressions.NewAccessFunction($ID.line, $ID.pos, $ID.text, $listParams.l, 1)
2023-10-30 17:35:48:480 action-translator LogManager.java:25 attr [@-1,1:7='funcexp',<0>,354:31]
2023-10-30 17:35:48:480 action-translator LogManager.java:25 qattr [@-1,42:43='ID',<0>,354:72].[@-1,45:48='line',<0>,354:75]
2023-10-30 17:35:48:480 action-translator LogManager.java:25 qattr [@-1,52:53='ID',<0>,354:82].[@-1,55:57='pos',<0>,354:85]
2023-10-30 17:35:48:481 action-translator LogManager.java:25 qattr [@-1,61:62='ID',<0>,354:91].[@-1,64:67='text',<0>,354:94]
2023-10-30 17:35:48:481 action-translator LogManager.java:25 qattr [@-1,71:80='listParams',<0>,354:101].[@-1,82:82='l',<0>,354:112]
2023-10-30 17:35:48:481 action-translator LogManager.java:25 translate $intfunc = expressions.NewFunctionInt($INTS.line, $INTS.pos, $expr.e)
2023-10-30 17:35:48:481 action-translator LogManager.java:25 attr [@-1,1:7='intfunc',<0>,359:27]
2023-10-30 17:35:48:481 action-translator LogManager.java:25 qattr [@-1,39:42='INTS',<0>,359:65].[@-1,44:47='line',<0>,359:70]
2023-10-30 17:35:48:481 action-translator LogManager.java:25 qattr [@-1,51:54='INTS',<0>,359:77].[@-1,56:58='pos',<0>,359:82]
2023-10-30 17:35:48:481 action-translator LogManager.java:25 qattr [@-1,62:65='expr',<0>,359:88].[@-1,67:67='e',<0>,359:93]
2023-10-30 17:35:48:482 action-translator LogManager.java:25 translate $floatfunc = expressions.NewFunctionFloat($FLOATS.line, $FLOATS.pos, $expr.e)
2023-10-30 17:35:48:482 action-translator LogManager.java:25 attr [@-1,1:9='floatfunc',<0>,363:29]
2023-10-30 17:35:48:482 action-translator LogManager.java:25 qattr [@-1,43:48='FLOATS',<0>,363:71].[@-1,50:53='line',<0>,363:78]
2023-10-30 17:35:48:482 action-translator LogManager.java:25 qattr [@-1,57:62='FLOATS',<0>,363:85].[@-1,64:66='pos',<0>,363:92]
2023-10-30 17:35:48:482 action-translator LogManager.java:25 qattr [@-1,70:73='expr',<0>,363:98].[@-1,75:75='e',<0>,363:103]
2023-10-30 17:35:48:482 action-translator LogManager.java:25 translate $stringfunc = expressions.NewFunctionString($STRINGS.line, $STRINGS.pos, $expr.e)
2023-10-30 17:35:48:482 action-translator LogManager.java:25 attr [@-1,1:10='stringfunc',<0>,367:30]
2023-10-30 17:35:48:483 action-translator LogManager.java:25 qattr [@-1,45:51='STRINGS',<0>,367:74].[@-1,53:56='line',<0>,367:82]
2023-10-30 17:35:48:483 action-translator LogManager.java:25 qattr [@-1,60:66='STRINGS',<0>,367:89].[@-1,68:70='pos',<0>,367:97]
2023-10-30 17:35:48:483 action-translator LogManager.java:25 qattr [@-1,74:77='expr',<0>,367:103].[@-1,79:79='e',<0>,367:108]
2023-10-30 17:35:48:483 action-translator LogManager.java:25 translate $access = expressions.NewAccess($op.line, $op.pos, $op.text)
2023-10-30 17:35:48:483 action-translator LogManager.java:25 attr [@-1,1:6='access',<0>,373:9]
2023-10-30 17:35:48:483 action-translator LogManager.java:25 qattr [@-1,33:34='op',<0>,373:41].[@-1,36:39='line',<0>,373:44]
2023-10-30 17:35:48:483 action-translator LogManager.java:25 qattr [@-1,43:44='op',<0>,373:51].[@-1,46:48='pos',<0>,373:54]
2023-10-30 17:35:48:483 action-translator LogManager.java:25 qattr [@-1,52:53='op',<0>,373:60].[@-1,55:58='text',<0>,373:63]
2023-10-30 17:35:48:484 action-translator LogManager.java:25 translate $increasedecrease = instructions.NewIncreaseDecrease($ID.line, $ID.pos, $ID.text, $IG_ADD.text, $expr.e)
2023-10-30 17:35:48:485 action-translator LogManager.java:25 attr [@-1,1:16='increasedecrease',<0>,378:25]
2023-10-30 17:35:48:485 action-translator LogManager.java:25 qattr [@-1,54:55='ID',<0>,378:78].[@-1,57:60='line',<0>,378:81]
2023-10-30 17:35:48:485 action-translator LogManager.java:25 qattr [@-1,64:65='ID',<0>,378:88].[@-1,67:69='pos',<0>,378:91]
2023-10-30 17:35:48:485 action-translator LogManager.java:25 qattr [@-1,73:74='ID',<0>,378:97].[@-1,76:79='text',<0>,378:100]
2023-10-30 17:35:48:485 action-translator LogManager.java:25 qattr [@-1,83:88='IG_ADD',<0>,378:107].[@-1,90:93='text',<0>,378:114]
2023-10-30 17:35:48:485 action-translator LogManager.java:25 qattr [@-1,97:100='expr',<0>,378:121].[@-1,102:102='e',<0>,378:126]
2023-10-30 17:35:48:485 action-translator LogManager.java:25 translate $increasedecrease = instructions.NewIncreaseDecrease($ID.line, $ID.pos, $ID.text, $IG_SUB.text, $expr.e)
2023-10-30 17:35:48:486 action-translator LogManager.java:25 attr [@-1,1:16='increasedecrease',<0>,379:26]
2023-10-30 17:35:48:486 action-translator LogManager.java:25 qattr [@-1,54:55='ID',<0>,379:79].[@-1,57:60='line',<0>,379:82]
2023-10-30 17:35:48:486 action-translator LogManager.java:25 qattr [@-1,64:65='ID',<0>,379:89].[@-1,67:69='pos',<0>,379:92]
2023-10-30 17:35:48:486 action-translator LogManager.java:25 qattr [@-1,73:74='ID',<0>,379:98].[@-1,76:79='text',<0>,379:101]
2023-10-30 17:35:48:486 action-translator LogManager.java:25 qattr [@-1,83:88='IG_SUB',<0>,379:108].[@-1,90:93='text',<0>,379:115]
2023-10-30 17:35:48:486 action-translator LogManager.java:25 qattr [@-1,97:100='expr',<0>,379:122].[@-1,102:102='e',<0>,379:127]
2023-10-30 17:35:48:487 action-translator LogManager.java:25 translate $t = environment.STRING
2023-10-30 17:35:48:487 action-translator LogManager.java:25 attr [@-1,1:1='t',<0>,384:13]
2023-10-30 17:35:48:487 action-translator LogManager.java:25 translate $t = environment.INTEGER
2023-10-30 17:35:48:487 action-translator LogManager.java:25 attr [@-1,1:1='t',<0>,385:10]
2023-10-30 17:35:48:487 action-translator LogManager.java:25 translate $t = environment.FLOAT
2023-10-30 17:35:48:487 action-translator LogManager.java:25 attr [@-1,1:1='t',<0>,386:12]
2023-10-30 17:35:48:487 action-translator LogManager.java:25 translate $t = environment.BOOLEAN 
2023-10-30 17:35:48:487 action-translator LogManager.java:25 attr [@-1,1:1='t',<0>,387:17]
2023-10-30 17:35:48:487 action-translator LogManager.java:25 translate $t = environment.CHARACTER
2023-10-30 17:35:48:488 action-translator LogManager.java:25 attr [@-1,1:1='t',<0>,388:19]
2023-10-30 17:35:48:488 action-translator LogManager.java:25 translate  $t = environment.STRUCT  
2023-10-30 17:35:48:488 action-translator LogManager.java:25 attr [@-1,2:2='t',<0>,389:9]
2023-10-30 17:35:48:489 action-translator LogManager.java:25 translate 
2023-10-30 17:35:48:489 action-translator LogManager.java:25 translate 
            $l = []interface{}{}
            $l = append($l, $expr.e)
        
2023-10-30 17:35:48:489 action-translator LogManager.java:25 attr [@-1,15:15='l',<0>,3:13]
2023-10-30 17:35:48:489 action-translator LogManager.java:25 attr [@-1,49:49='l',<0>,4:13]
2023-10-30 17:35:48:490 action-translator LogManager.java:25 attr [@-1,61:61='l',<0>,4:25]
2023-10-30 17:35:48:490 action-translator LogManager.java:25 qattr [@-1,65:68='expr',<0>,4:29].[@-1,70:70='e',<0>,4:34]
2023-10-30 17:35:48:490 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 2)
2023-10-30 17:35:48:490 action-translator LogManager.java:25 translate 
                                          var arr []interface{}
                                          arr = append($list.l, $expr.e)
                                          $l = arr
                                      
2023-10-30 17:35:48:491 action-translator LogManager.java:25 qattr [@-1,123:126='list',<0>,10:56].[@-1,128:128='l',<0>,10:61]
2023-10-30 17:35:48:491 action-translator LogManager.java:25 qattr [@-1,132:135='expr',<0>,10:65].[@-1,137:137='e',<0>,10:70]
2023-10-30 17:35:48:491 action-translator LogManager.java:25 attr [@-1,184:184='l',<0>,11:43]
2023-10-30 17:35:48:491 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 2)
2023-10-30 17:35:48:491 action-translator LogManager.java:25 translate 
2023-10-30 17:35:48:492 action-translator LogManager.java:25 translate 
                    var arr []interface{}
                    StrExp := environment.NewStructContent($ID.text, $expr.e)
                    arr = append(arr, StrExp)
                    $l = arr
                
2023-10-30 17:35:48:492 action-translator LogManager.java:25 qattr [@-1,105:106='ID',<0>,4:60].[@-1,108:111='text',<0>,4:63]
2023-10-30 17:35:48:492 action-translator LogManager.java:25 qattr [@-1,115:118='expr',<0>,4:70].[@-1,120:120='e',<0>,4:75]
2023-10-30 17:35:48:492 action-translator LogManager.java:25 attr [@-1,192:192='l',<0>,6:21]
2023-10-30 17:35:48:492 action-translator LogManager.java:25 translate 
        $l = []interface{}{}
    
2023-10-30 17:35:48:492 action-translator LogManager.java:25 attr [@-1,11:11='l',<0>,9:9]
2023-10-30 17:35:48:492 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 3)
2023-10-30 17:35:48:492 action-translator LogManager.java:25 translate 
                                                      var arr []interface{}
                                                      StrExp := environment.NewStructContent($ID.text, $expr.e)
                                                      arr = append($list.l, StrExp)
                                                      $l = arr
                                                  
2023-10-30 17:35:48:492 action-translator LogManager.java:25 qattr [@-1,173:174='ID',<0>,15:94].[@-1,176:179='text',<0>,15:97]
2023-10-30 17:35:48:492 action-translator LogManager.java:25 qattr [@-1,183:186='expr',<0>,15:104].[@-1,188:188='e',<0>,15:109]
2023-10-30 17:35:48:492 action-translator LogManager.java:25 qattr [@-1,260:263='list',<0>,16:68].[@-1,265:265='l',<0>,16:73]
2023-10-30 17:35:48:492 action-translator LogManager.java:25 attr [@-1,332:332='l',<0>,17:55]
2023-10-30 17:35:48:493 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 3)
2023-10-30 17:35:48:959 action-translator LogManager.java:25 translate 
    import "Server/Interfaces"
    import "Server/Environment"
    import "Server/Expression"
    import "Server/Instruction"
    import "strings"

2023-10-30 17:35:48:960 action-translator LogManager.java:25 translate 
    import "Server/Interfaces"
    import "Server/Environment"
    import "Server/Expression"
    import "Server/Instruction"
    import "strings"

2023-10-30 17:35:49:097 action-translator LogManager.java:25 translate 
    import "Server/Interfaces"
    import "Server/Environment"
    import "Server/Expression"
    import "Server/Instruction"
    import "strings"

2023-10-30 17:35:49:097 action-translator LogManager.java:25 translate 
    import "Server/Interfaces"
    import "Server/Environment"
    import "Server/Expression"
    import "Server/Instruction"
    import "strings"

